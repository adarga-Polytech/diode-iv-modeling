/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"assets/samplefiles/T279K.txt\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2FtcGxlZmlsZXMvVDI3OUsudHh0P2VjZmMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL3NhbXBsZWZpbGVzL1QyNzlLLnR4dFwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fzc2V0cy9zYW1wbGVmaWxlcy9UMjc5Sy50eHRcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"index.html\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5odG1sPzhiZTkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW5kZXguaHRtbFwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(6)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./index.css\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./index.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5jc3M/Y2I3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = drawGraph;\n/* This file takes care of plotting the result in a graph.\r\n * I wrote this back when I was learning JavaScript and haven't\r\n * touched it since then (besides linting).\r\n * At the time, I could not find a plotting library that would\r\n * render scientific graphs that could be used directly in a\r\n * publication.\r\n * Also I thought it was a good exercice to code this myself.\r\n */\r\n\r\nfunction changePrecision(precision, number) {\r\n  return Math.round(number * Math.pow(10, precision)) / Math.pow(10, precision);\r\n}\r\n\r\n// returns the min value of an array\r\nfunction min(array) {\r\n  var min = '+Infinity',\r\n    element;\r\n\r\n  for (var i = 1; i < array.length; i++) {\r\n    element = array[i];\r\n    if (element < min && element != '-Infinity') {\r\n      min = element;\r\n\r\n    }\r\n  }\r\n  //alert(min);\r\n  return min;\r\n}\r\n\r\n// returns the max value of an array\r\nfunction max(array) {\r\n  var max;\r\n  for (var i = 0; i < array.length; i++) {\r\n    if (!max || array[i] > max) {\r\n      max = array[i];\r\n    }\r\n  }\r\n  return max;\r\n}\r\n\r\nfunction orderOfMagn(value) {\r\n  return Math.pow(10, Math.floor(log10(Math.abs(value))));\r\n}\r\n\r\nfunction log10(val) {\r\n  return Math.log(val) / Math.log(10);\r\n}\r\n\r\nlet array;\r\n\r\nfunction drawGraph(canvasId, arrayMult, focusedPlot, plotStyle, scaleType, xTitle, yTitle) {\r\n\r\n  //array will be used to build the graph area, max and min, distance between 2 ticks etc.\r\n  array = arrayMult[focusedPlot];\r\n  var xArray = [],\r\n    yArray = [],\r\n    y, xy;\r\n\r\n  for (var i = 0; i <= array.length - 1; i++) {\r\n    xy = array[i];\r\n    y = xy[1];\r\n    if (scaleType == 'logScale') {\r\n      if (y != 0) { //when scale is Log, don't include the points for which y = 0\r\n        xArray.push(xy[0]);\r\n        yArray.push(log10(Math.abs(y)));\r\n      }\r\n    } else {\r\n      xArray.push(xy[0]);\r\n      yArray.push(y);\r\n    }\r\n  }\r\n\r\n  var yMin = min(yArray);\r\n\r\n  if (scaleType == 'logScale' && yMin < -15) {\r\n    var index = yArray.indexOf(yMin);\r\n    xArray.splice(index, 1);\r\n    yArray.splice(index, 1);\r\n  }\r\n\r\n  var xMin = min(xArray),\r\n    xMax = max(xArray);\r\n  yMin = min(yArray);\r\n  var yMax = max(yArray),\r\n\r\n    //alert(xMin);\r\n    xyStep = calcStep(xMin, xMax, yMin, yMax),\r\n    xStep = xyStep[0],\r\n    yStep = xyStep[1],\r\n\r\n    axesMaxMin = calcAxesMaxMin(xMin, xMax, xStep, yMin, yMax, yStep),\r\n    xAxisMin = axesMaxMin[0],\r\n    xAxisMax = axesMaxMin[1],\r\n    yAxisMin = axesMaxMin[2],\r\n    yAxisMax = axesMaxMin[3],\r\n\r\n    canvas = document.getElementById(canvasId),\r\n    context = canvas.getContext('2d'),\r\n    canvasWidth = canvas.width,\r\n    canvasHeight = canvas.height,\r\n    margin = 40.5,\r\n    unitPx = calcUnitPx(xAxisMin, xAxisMax, canvasWidth, yAxisMin, yAxisMax, canvasHeight, margin),\r\n    xUnitPx = unitPx[0],\r\n    yUnitPx = unitPx[1];\r\n\r\n  canvas.height = canvasHeight; //clears the canvas\r\n\r\n  var axesPosition = drawAxis(context, scaleType, margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, xTitle, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yTitle),\r\n    xAxisPosition = axesPosition[0],\r\n    xTicksSide = axesPosition[1] / Math.abs(axesPosition[1]),\r\n    yAxisPosition = axesPosition[2],\r\n    yTicksSide = axesPosition[3] / Math.abs(axesPosition[3]);\r\n\r\n  drawTicks(context, scaleType, margin, xAxisMin, xAxisMax, xStep, canvasWidth, xUnitPx, xAxisPosition, xTicksSide, yAxisMin, yAxisMax, yStep, canvasHeight, yUnitPx, yAxisPosition, yTicksSide);\r\n\r\n  legend(context, scaleType, arrayMult, plotStyle, margin, xAxisMin, xUnitPx, yAxisMin, yUnitPx, canvasHeight);\r\n\r\n  for (var i = 0; i < arrayMult.length; i++) {\r\n    plot(arrayMult[i], context, scaleType, plotStyle[i], margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yAxisPosition);\r\n  }\r\n}\r\n\r\nfunction calcStep(xMin, xMax, yMin, yMax) {\r\n\r\n  var oOfMagn = orderOfMagn(xMax - xMin),\r\n    xStep = oOfMagn * 0.2,\r\n    xAxisMax,\r\n    xAxisMin;\r\n\r\n  if (xMax - xMin > oOfMagn * 4 / 3) {\r\n    xStep = oOfMagn * 0.5;\r\n  }\r\n  if (xMax - xMin > oOfMagn * 10 / 3) {\r\n    xStep = oOfMagn;\r\n  }\r\n  if (xMax - xMin > oOfMagn * 20 / 3) {\r\n    xStep = oOfMagn * 2;\r\n  }\r\n\r\n  oOfMagn = orderOfMagn(yMax - yMin);\r\n  var yStep = oOfMagn * 0.2,\r\n    yAxisMax,\r\n    yAxisMin;\r\n\r\n  if (yMax - yMin > oOfMagn * 4 / 3) {\r\n    yStep = oOfMagn * 0.5;\r\n  }\r\n  if (yMax - yMin > oOfMagn * 10 / 3) {\r\n    yStep = oOfMagn;\r\n  }\r\n  if (yMax - yMin > oOfMagn * 20 / 3) {\r\n    yStep = oOfMagn * 2;\r\n  }\r\n\r\n  return [xStep, yStep];\r\n}\r\n\r\nfunction calcAxesMaxMin(xMin, xMax, xStep, yMin, yMax, yStep) {\r\n\r\n  var min = [xMin, yMin],\r\n    max = [xMax, yMax],\r\n    step = [xStep, yStep],\r\n    axisMin = [0, 0],\r\n    axisMax = [0, 0];\r\n\r\n  for (var i = 0; i <= 1; i++) {\r\n    if (min[i] <= 0) {\r\n      while (axisMin[i] >= min[i]) {\r\n        axisMin[i] = axisMin[i] - step[i];\r\n      }\r\n      axisMax[i] = axisMin[i];\r\n      while (axisMax[i] <= max[i]) {\r\n        axisMax[i] = axisMax[i] + step[i];\r\n      }\r\n    } else {\r\n      while (axisMax[i] <= max[i]) {\r\n        axisMax[i] = axisMax[i] + step[i];\r\n      }\r\n      axisMin[i] = axisMax[i];\r\n      while (axisMin[i] >= min[i]) {\r\n        axisMin[i] = axisMin[i] - step[i];\r\n      }\r\n    }\r\n  }\r\n  return [axisMin[0], axisMax[0], axisMin[1], axisMax[1]];\r\n}\r\n\r\nfunction calcUnitPx(xAxisMin, xAxisMax, canvasWidth, yAxisMin, yAxisMax, canvasHeight, margin) {\r\n  var xUnitPx = (canvasWidth - 2 * margin) / (xAxisMax - xAxisMin),\r\n    yUnitPx = (canvasHeight - 2 * margin) / (yAxisMax - yAxisMin);\r\n\r\n  return [xUnitPx, yUnitPx];\r\n}\r\n\r\nfunction xDataToCanvas(value, margin, unitPx) {\r\n  return margin + Math.floor(value * unitPx);\r\n}\r\n\r\nfunction yDataToCanvas(value, margin, unitPx, canvasHeight) {\r\n  return canvasHeight - margin - Math.floor(value * unitPx);\r\n}\r\n\r\nfunction drawAxis(context, type, margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, xTitle, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yTitle) {\r\n  context.font = '10px Arial';\r\n  context.strokeStyle = 'black';\r\n  context.lineWidth = 1;\r\n  var yAxisPosition,\r\n    xAxisPosition,\r\n    yTitlePosition,\r\n    xTitlePosition,\r\n    yTitleSide,\r\n    xTitleSide;\r\n\r\n  //determine yAxis position\r\n  if (xAxisMin <= 0 && xAxisMax >= 0) { yAxisPosition = 0; }\r\n  else {\r\n    if (xAxisMin > 0) { yAxisPosition = xAxisMin; }\r\n    else { yAxisPosition = xAxisMax; }\r\n  }\r\n\r\n  //draw y Axis\r\n  context.beginPath(); // prevents weird behavior with IE9\r\n  context.moveTo(Math.floor((yAxisPosition - xAxisMin) * xUnitPx) + margin, canvasHeight - margin);\r\n  context.lineTo(Math.floor((yAxisPosition - xAxisMin) * xUnitPx) + margin, margin);\r\n\r\n  //determine x title position and y title's side\r\n  if (xAxisMax - yAxisPosition >= yAxisPosition - xAxisMin) { xTitlePosition = (xAxisMax + yAxisPosition) / 2; yTitleSide = -30; }\r\n  else { xTitlePosition = (yAxisPosition + xAxisMin) / 2; yTitleSide = +30; }\r\n  //alert(xTitlePosition);\r\n\r\n  //determine xAxis position\r\n  if (yAxisMin <= 0 && yAxisMax >= 0 && type == 'linearScale') { xAxisPosition = 0; }\r\n  else {\r\n    if (yAxisMin > 0 || type == 'logScale') { xAxisPosition = yAxisMin; }\r\n    else { xAxisPosition = yAxisMax; }\r\n  }\r\n\r\n  //draw x Axis\r\n\r\n  context.moveTo(margin, canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx));\r\n  context.lineTo(canvasWidth - margin, canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx));\r\n\r\n  //determine y title position and x title's side\r\n  if (yAxisMax - xAxisPosition >= xAxisPosition - yAxisMin) { yTitlePosition = (yAxisMax + xAxisPosition) / 2; xTitleSide = 25; }\r\n  else { yTitlePosition = (xAxisPosition + yAxisMin) / 2; xTitleSide = -25; }\r\n\r\n  //write x title\r\n  context.textAlign = 'center';\r\n  if (xTitleSide > 0) { context.textBaseline = 'top'; }\r\n  else { context.textBaseline = 'bottom'; }\r\n  context.fillText(xTitle, margin + Math.floor((xTitlePosition - xAxisMin) * xUnitPx), canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx) + xTitleSide);\r\n\r\n  //write y title\r\n  context.rotate(-Math.PI / 2); //rotate the whole canvas to write y title vertically\r\n  context.textAlign = 'center';\r\n  if (yTitleSide > 0) { context.textBaseline = 'top'; }\r\n  else { context.textBaseline = 'bottom'; }\r\n\r\n  var x = margin + Math.floor((yAxisPosition - xAxisMin) * xUnitPx) + yTitleSide,\r\n    y = canvasHeight - margin - Math.floor((yTitlePosition - yAxisMin) * yUnitPx);\r\n  context.fillText(yTitle, -y, x);\r\n  context.rotate(Math.PI / 2);\r\n\r\n\r\n  return [xAxisPosition, xTitleSide, yAxisPosition, yTitleSide];\r\n}\r\n\r\nfunction drawTicks(context, type, margin, xAxisMin, xAxisMax, xStep, canvasWidth, xUnitPx, xAxisPosition, xTicksSide, yAxisMin, yAxisMax, yStep, canvasHeight, yUnitPx, yAxisPosition, yTicksSide) {\r\n  var xPx,\r\n    yPx,\r\n    tickLabel;\r\n\r\n  //x Axis\r\n  context.textAlign = 'center';\r\n  if (xTicksSide > 0) { context.textBaseline = 'top'; }\r\n  else { context.textBaseline = 'bottom'; }\r\n\r\n  //major ticks\r\n  for (var x = xAxisMin; x <= xAxisMax; x += xStep) {\r\n    xPx = margin + Math.floor((x - xAxisMin) * xUnitPx);\r\n    yPx = canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx);\r\n    context.moveTo(xPx, yPx);\r\n    context.lineTo(xPx, yPx + 2 * xTicksSide);\r\n\r\n    if (x == xAxisPosition && xAxisPosition != yAxisMin && xAxisPosition != yAxisMax) {\r\n      xPx = xPx - 10 * yTicksSide;\r\n    } //avoids the messy zero labels at the axes' intersections\r\n    tickLabel = changePrecision(7, x);\r\n    context.fillText(tickLabel, xPx, yPx + 5 * xTicksSide); //tick label\r\n  }\r\n\r\n  //minor ticks\r\n  for (var x = xAxisMin; x < xAxisMax; x += xStep / 2) {\r\n    xPx = margin + Math.floor((x - xAxisMin) * xUnitPx);\r\n    yPx = canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx);\r\n    context.moveTo(xPx, yPx);\r\n    context.lineTo(xPx, yPx + 1 * xTicksSide);\r\n  }\r\n\r\n  //y Axis\r\n  context.textBaseline = 'middle';\r\n  if (yTicksSide > 0) { context.textAlign = 'left'; }\r\n  else { context.textAlign = 'right'; }\r\n  //major ticks\r\n  for (var y = yAxisMin; y <= yAxisMax; y += yStep) {\r\n    yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n    xPx = margin + Math.floor((yAxisPosition - xAxisMin) * xUnitPx);\r\n    context.moveTo(xPx, yPx);\r\n    context.lineTo(xPx + 2 * yTicksSide, yPx);\r\n\r\n    if (type == 'logScale' && y < yAxisMax) {\r\n      for (var j = 1; j <= 10; j++) {\r\n        var yMinor = Math.floor(yPx - yStep * yUnitPx * log10(j / 10) - yStep * yUnitPx) + 0.5;\r\n\r\n        context.moveTo(xPx, yMinor);\r\n        context.lineTo(xPx + 1 * yTicksSide, yMinor);\r\n      }\r\n    }\r\n    tickLabel = changePrecision(7, y);\r\n    if (type == 'logScale') {\r\n      tickLabel = '1E' + y;\r\n    }\r\n    if (y == xAxisPosition && yAxisPosition != xAxisMin && yAxisPosition != xAxisMax) {\r\n      yPx = yPx - 10 * xTicksSide;\r\n    } //avoids the messy labels at the axes' intersections\r\n    context.fillText(tickLabel, xPx + 5 * yTicksSide, yPx); //tick label\r\n  }\r\n  //minor ticks\r\n  if (type == 'linearScale') {\r\n    for (var y = yAxisMin; y < yAxisMax; y += yStep / 2) {\r\n\r\n      yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n      xPx = margin + Math.floor((yAxisPosition - xAxisMin) * xUnitPx);\r\n\r\n      context.moveTo(xPx, yPx);\r\n      context.lineTo(xPx + 1 * yTicksSide, yPx);\r\n    }\r\n  }\r\n  context.stroke();\r\n}\r\n\r\nfunction legend(context, type, arrayMult, plotStyle, margin, xAxisMin, xUnitPx, yAxisMin, yUnitPx, canvasHeight) {\r\n  context.textBaseline = 'middle';\r\n  context.textAlign = 'left';\r\n  var x, y, xPx, yPx = '+Infinity', index, xy, array = [];\r\n  for (var i = 0; i < arrayMult.length; i++) {\r\n    array = arrayMult[i];\r\n    index = array.length - 1;//last point\r\n    xy = array[index];\r\n    x = xy[0];\r\n    y = xy[1];\r\n\r\n    xPx = 10 + margin + Math.floor((x - xAxisMin) * xUnitPx);\r\n    if (type == 'logScale') { y = log10(Math.abs(y)); }\r\n    if (isFinite(y)) {\r\n      yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n      context.fillStyle = plotStyle[i][1]; //color\r\n      context.fillText(plotStyle[i][2], xPx, yPx);\r\n    }\r\n  }\r\n}\r\n\r\nfunction plot(array, context, type, plotStyle, margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yAxisPosition) {\r\n  var xPx, yPx, y, j = 0;\r\n  context.strokeStyle = plotStyle[1];\r\n  for (var i = 0; i < array.length; i++) { //one loop for each data point\r\n    xPx = margin + Math.floor((array[i][0] - xAxisMin) * xUnitPx);\r\n    y = (array[i][1]);\r\n    if (type == 'logScale') {\r\n      y = log10(Math.abs(y));\r\n    }\r\n    if (y != '-Infinity') {//y = '-Infinity' when y = 0 and scale is Log\r\n      yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n      switch (plotStyle[0]) {\r\n        case 'line': {\r\n          if (j == 0) { // j==0 <=> 1st plotted point, not necessarily 1st point in the array \r\n            context.beginPath();\r\n            context.moveTo(xPx, yPx);\r\n          }\r\n          context.lineTo(xPx, yPx);\r\n          break;\r\n        }\r\n        case 'circles': {\r\n          context.beginPath();\r\n          context.arc(xPx, yPx, 3, 0, 2 * Math.PI);\r\n          context.stroke();\r\n          break;\r\n        }\r\n        case 'diagonalCross': {\r\n          context.beginPath();\r\n          context.moveTo(xPx - 2, yPx - 2);\r\n          context.lineTo(xPx + 2, yPx + 2);\r\n          context.moveTo(xPx + 2, yPx - 2);\r\n          context.lineTo(xPx - 2, yPx + 2);\r\n          context.stroke();\r\n          break;\r\n        }\r\n        case 'verticalCross': {\r\n          context.beginPath();\r\n          context.moveTo(xPx, yPx - 2);\r\n          context.lineTo(xPx, yPx + 2);\r\n          context.moveTo(xPx + 2, yPx);\r\n          context.lineTo(xPx - 2, yPx);\r\n          context.stroke();\r\n          break;\r\n        }\r\n      }\r\n      j++;\r\n    }\r\n  }\r\n  if (plotStyle[0] == 'line') { context.stroke(); }\r\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hc3NldHMvanMvYm9iR3JhcGguanM/NjZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGlzIGZpbGUgdGFrZXMgY2FyZSBvZiBwbG90dGluZyB0aGUgcmVzdWx0IGluIGEgZ3JhcGguXHJcbiAqIEkgd3JvdGUgdGhpcyBiYWNrIHdoZW4gSSB3YXMgbGVhcm5pbmcgSmF2YVNjcmlwdCBhbmQgaGF2ZW4ndFxyXG4gKiB0b3VjaGVkIGl0IHNpbmNlIHRoZW4gKGJlc2lkZXMgbGludGluZykuXHJcbiAqIEF0IHRoZSB0aW1lLCBJIGNvdWxkIG5vdCBmaW5kIGEgcGxvdHRpbmcgbGlicmFyeSB0aGF0IHdvdWxkXHJcbiAqIHJlbmRlciBzY2llbnRpZmljIGdyYXBocyB0aGF0IGNvdWxkIGJlIHVzZWQgZGlyZWN0bHkgaW4gYVxyXG4gKiBwdWJsaWNhdGlvbi5cclxuICogQWxzbyBJIHRob3VnaHQgaXQgd2FzIGEgZ29vZCBleGVyY2ljZSB0byBjb2RlIHRoaXMgbXlzZWxmLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZVByZWNpc2lvbihwcmVjaXNpb24sIG51bWJlcikge1xyXG4gIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBwcmVjaXNpb24pKSAvIE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIHRoZSBtaW4gdmFsdWUgb2YgYW4gYXJyYXlcclxuZnVuY3Rpb24gbWluKGFycmF5KSB7XHJcbiAgdmFyIG1pbiA9ICcrSW5maW5pdHknLFxyXG4gICAgZWxlbWVudDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xyXG4gICAgaWYgKGVsZW1lbnQgPCBtaW4gJiYgZWxlbWVudCAhPSAnLUluZmluaXR5Jykge1xyXG4gICAgICBtaW4gPSBlbGVtZW50O1xyXG5cclxuICAgIH1cclxuICB9XHJcbiAgLy9hbGVydChtaW4pO1xyXG4gIHJldHVybiBtaW47XHJcbn1cclxuXHJcbi8vIHJldHVybnMgdGhlIG1heCB2YWx1ZSBvZiBhbiBhcnJheVxyXG5mdW5jdGlvbiBtYXgoYXJyYXkpIHtcclxuICB2YXIgbWF4O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghbWF4IHx8IGFycmF5W2ldID4gbWF4KSB7XHJcbiAgICAgIG1heCA9IGFycmF5W2ldO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbWF4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcmRlck9mTWFnbih2YWx1ZSkge1xyXG4gIHJldHVybiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChNYXRoLmFicyh2YWx1ZSkpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZzEwKHZhbCkge1xyXG4gIHJldHVybiBNYXRoLmxvZyh2YWwpIC8gTWF0aC5sb2coMTApO1xyXG59XHJcblxyXG5sZXQgYXJyYXk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkcmF3R3JhcGgoY2FudmFzSWQsIGFycmF5TXVsdCwgZm9jdXNlZFBsb3QsIHBsb3RTdHlsZSwgc2NhbGVUeXBlLCB4VGl0bGUsIHlUaXRsZSkge1xyXG5cclxuICAvL2FycmF5IHdpbGwgYmUgdXNlZCB0byBidWlsZCB0aGUgZ3JhcGggYXJlYSwgbWF4IGFuZCBtaW4sIGRpc3RhbmNlIGJldHdlZW4gMiB0aWNrcyBldGMuXHJcbiAgYXJyYXkgPSBhcnJheU11bHRbZm9jdXNlZFBsb3RdO1xyXG4gIHZhciB4QXJyYXkgPSBbXSxcclxuICAgIHlBcnJheSA9IFtdLFxyXG4gICAgeSwgeHk7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGFycmF5Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgeHkgPSBhcnJheVtpXTtcclxuICAgIHkgPSB4eVsxXTtcclxuICAgIGlmIChzY2FsZVR5cGUgPT0gJ2xvZ1NjYWxlJykge1xyXG4gICAgICBpZiAoeSAhPSAwKSB7IC8vd2hlbiBzY2FsZSBpcyBMb2csIGRvbid0IGluY2x1ZGUgdGhlIHBvaW50cyBmb3Igd2hpY2ggeSA9IDBcclxuICAgICAgICB4QXJyYXkucHVzaCh4eVswXSk7XHJcbiAgICAgICAgeUFycmF5LnB1c2gobG9nMTAoTWF0aC5hYnMoeSkpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeEFycmF5LnB1c2goeHlbMF0pO1xyXG4gICAgICB5QXJyYXkucHVzaCh5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciB5TWluID0gbWluKHlBcnJheSk7XHJcblxyXG4gIGlmIChzY2FsZVR5cGUgPT0gJ2xvZ1NjYWxlJyAmJiB5TWluIDwgLTE1KSB7XHJcbiAgICB2YXIgaW5kZXggPSB5QXJyYXkuaW5kZXhPZih5TWluKTtcclxuICAgIHhBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgeUFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgfVxyXG5cclxuICB2YXIgeE1pbiA9IG1pbih4QXJyYXkpLFxyXG4gICAgeE1heCA9IG1heCh4QXJyYXkpO1xyXG4gIHlNaW4gPSBtaW4oeUFycmF5KTtcclxuICB2YXIgeU1heCA9IG1heCh5QXJyYXkpLFxyXG5cclxuICAgIC8vYWxlcnQoeE1pbik7XHJcbiAgICB4eVN0ZXAgPSBjYWxjU3RlcCh4TWluLCB4TWF4LCB5TWluLCB5TWF4KSxcclxuICAgIHhTdGVwID0geHlTdGVwWzBdLFxyXG4gICAgeVN0ZXAgPSB4eVN0ZXBbMV0sXHJcblxyXG4gICAgYXhlc01heE1pbiA9IGNhbGNBeGVzTWF4TWluKHhNaW4sIHhNYXgsIHhTdGVwLCB5TWluLCB5TWF4LCB5U3RlcCksXHJcbiAgICB4QXhpc01pbiA9IGF4ZXNNYXhNaW5bMF0sXHJcbiAgICB4QXhpc01heCA9IGF4ZXNNYXhNaW5bMV0sXHJcbiAgICB5QXhpc01pbiA9IGF4ZXNNYXhNaW5bMl0sXHJcbiAgICB5QXhpc01heCA9IGF4ZXNNYXhNaW5bM10sXHJcblxyXG4gICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpLFxyXG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGgsXHJcbiAgICBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0LFxyXG4gICAgbWFyZ2luID0gNDAuNSxcclxuICAgIHVuaXRQeCA9IGNhbGNVbml0UHgoeEF4aXNNaW4sIHhBeGlzTWF4LCBjYW52YXNXaWR0aCwgeUF4aXNNaW4sIHlBeGlzTWF4LCBjYW52YXNIZWlnaHQsIG1hcmdpbiksXHJcbiAgICB4VW5pdFB4ID0gdW5pdFB4WzBdLFxyXG4gICAgeVVuaXRQeCA9IHVuaXRQeFsxXTtcclxuXHJcbiAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDsgLy9jbGVhcnMgdGhlIGNhbnZhc1xyXG5cclxuICB2YXIgYXhlc1Bvc2l0aW9uID0gZHJhd0F4aXMoY29udGV4dCwgc2NhbGVUeXBlLCBtYXJnaW4sIHhBeGlzTWluLCB4QXhpc01heCwgY2FudmFzV2lkdGgsIHhVbml0UHgsIHhUaXRsZSwgeUF4aXNNaW4sIHlBeGlzTWF4LCBjYW52YXNIZWlnaHQsIHlVbml0UHgsIHlUaXRsZSksXHJcbiAgICB4QXhpc1Bvc2l0aW9uID0gYXhlc1Bvc2l0aW9uWzBdLFxyXG4gICAgeFRpY2tzU2lkZSA9IGF4ZXNQb3NpdGlvblsxXSAvIE1hdGguYWJzKGF4ZXNQb3NpdGlvblsxXSksXHJcbiAgICB5QXhpc1Bvc2l0aW9uID0gYXhlc1Bvc2l0aW9uWzJdLFxyXG4gICAgeVRpY2tzU2lkZSA9IGF4ZXNQb3NpdGlvblszXSAvIE1hdGguYWJzKGF4ZXNQb3NpdGlvblszXSk7XHJcblxyXG4gIGRyYXdUaWNrcyhjb250ZXh0LCBzY2FsZVR5cGUsIG1hcmdpbiwgeEF4aXNNaW4sIHhBeGlzTWF4LCB4U3RlcCwgY2FudmFzV2lkdGgsIHhVbml0UHgsIHhBeGlzUG9zaXRpb24sIHhUaWNrc1NpZGUsIHlBeGlzTWluLCB5QXhpc01heCwgeVN0ZXAsIGNhbnZhc0hlaWdodCwgeVVuaXRQeCwgeUF4aXNQb3NpdGlvbiwgeVRpY2tzU2lkZSk7XHJcblxyXG4gIGxlZ2VuZChjb250ZXh0LCBzY2FsZVR5cGUsIGFycmF5TXVsdCwgcGxvdFN0eWxlLCBtYXJnaW4sIHhBeGlzTWluLCB4VW5pdFB4LCB5QXhpc01pbiwgeVVuaXRQeCwgY2FudmFzSGVpZ2h0KTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU11bHQubGVuZ3RoOyBpKyspIHtcclxuICAgIHBsb3QoYXJyYXlNdWx0W2ldLCBjb250ZXh0LCBzY2FsZVR5cGUsIHBsb3RTdHlsZVtpXSwgbWFyZ2luLCB4QXhpc01pbiwgeEF4aXNNYXgsIGNhbnZhc1dpZHRoLCB4VW5pdFB4LCB5QXhpc01pbiwgeUF4aXNNYXgsIGNhbnZhc0hlaWdodCwgeVVuaXRQeCwgeUF4aXNQb3NpdGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjU3RlcCh4TWluLCB4TWF4LCB5TWluLCB5TWF4KSB7XHJcblxyXG4gIHZhciBvT2ZNYWduID0gb3JkZXJPZk1hZ24oeE1heCAtIHhNaW4pLFxyXG4gICAgeFN0ZXAgPSBvT2ZNYWduICogMC4yLFxyXG4gICAgeEF4aXNNYXgsXHJcbiAgICB4QXhpc01pbjtcclxuXHJcbiAgaWYgKHhNYXggLSB4TWluID4gb09mTWFnbiAqIDQgLyAzKSB7XHJcbiAgICB4U3RlcCA9IG9PZk1hZ24gKiAwLjU7XHJcbiAgfVxyXG4gIGlmICh4TWF4IC0geE1pbiA+IG9PZk1hZ24gKiAxMCAvIDMpIHtcclxuICAgIHhTdGVwID0gb09mTWFnbjtcclxuICB9XHJcbiAgaWYgKHhNYXggLSB4TWluID4gb09mTWFnbiAqIDIwIC8gMykge1xyXG4gICAgeFN0ZXAgPSBvT2ZNYWduICogMjtcclxuICB9XHJcblxyXG4gIG9PZk1hZ24gPSBvcmRlck9mTWFnbih5TWF4IC0geU1pbik7XHJcbiAgdmFyIHlTdGVwID0gb09mTWFnbiAqIDAuMixcclxuICAgIHlBeGlzTWF4LFxyXG4gICAgeUF4aXNNaW47XHJcblxyXG4gIGlmICh5TWF4IC0geU1pbiA+IG9PZk1hZ24gKiA0IC8gMykge1xyXG4gICAgeVN0ZXAgPSBvT2ZNYWduICogMC41O1xyXG4gIH1cclxuICBpZiAoeU1heCAtIHlNaW4gPiBvT2ZNYWduICogMTAgLyAzKSB7XHJcbiAgICB5U3RlcCA9IG9PZk1hZ247XHJcbiAgfVxyXG4gIGlmICh5TWF4IC0geU1pbiA+IG9PZk1hZ24gKiAyMCAvIDMpIHtcclxuICAgIHlTdGVwID0gb09mTWFnbiAqIDI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gW3hTdGVwLCB5U3RlcF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGNBeGVzTWF4TWluKHhNaW4sIHhNYXgsIHhTdGVwLCB5TWluLCB5TWF4LCB5U3RlcCkge1xyXG5cclxuICB2YXIgbWluID0gW3hNaW4sIHlNaW5dLFxyXG4gICAgbWF4ID0gW3hNYXgsIHlNYXhdLFxyXG4gICAgc3RlcCA9IFt4U3RlcCwgeVN0ZXBdLFxyXG4gICAgYXhpc01pbiA9IFswLCAwXSxcclxuICAgIGF4aXNNYXggPSBbMCwgMF07XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xyXG4gICAgaWYgKG1pbltpXSA8PSAwKSB7XHJcbiAgICAgIHdoaWxlIChheGlzTWluW2ldID49IG1pbltpXSkge1xyXG4gICAgICAgIGF4aXNNaW5baV0gPSBheGlzTWluW2ldIC0gc3RlcFtpXTtcclxuICAgICAgfVxyXG4gICAgICBheGlzTWF4W2ldID0gYXhpc01pbltpXTtcclxuICAgICAgd2hpbGUgKGF4aXNNYXhbaV0gPD0gbWF4W2ldKSB7XHJcbiAgICAgICAgYXhpc01heFtpXSA9IGF4aXNNYXhbaV0gKyBzdGVwW2ldO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aGlsZSAoYXhpc01heFtpXSA8PSBtYXhbaV0pIHtcclxuICAgICAgICBheGlzTWF4W2ldID0gYXhpc01heFtpXSArIHN0ZXBbaV07XHJcbiAgICAgIH1cclxuICAgICAgYXhpc01pbltpXSA9IGF4aXNNYXhbaV07XHJcbiAgICAgIHdoaWxlIChheGlzTWluW2ldID49IG1pbltpXSkge1xyXG4gICAgICAgIGF4aXNNaW5baV0gPSBheGlzTWluW2ldIC0gc3RlcFtpXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gW2F4aXNNaW5bMF0sIGF4aXNNYXhbMF0sIGF4aXNNaW5bMV0sIGF4aXNNYXhbMV1dO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjVW5pdFB4KHhBeGlzTWluLCB4QXhpc01heCwgY2FudmFzV2lkdGgsIHlBeGlzTWluLCB5QXhpc01heCwgY2FudmFzSGVpZ2h0LCBtYXJnaW4pIHtcclxuICB2YXIgeFVuaXRQeCA9IChjYW52YXNXaWR0aCAtIDIgKiBtYXJnaW4pIC8gKHhBeGlzTWF4IC0geEF4aXNNaW4pLFxyXG4gICAgeVVuaXRQeCA9IChjYW52YXNIZWlnaHQgLSAyICogbWFyZ2luKSAvICh5QXhpc01heCAtIHlBeGlzTWluKTtcclxuXHJcbiAgcmV0dXJuIFt4VW5pdFB4LCB5VW5pdFB4XTtcclxufVxyXG5cclxuZnVuY3Rpb24geERhdGFUb0NhbnZhcyh2YWx1ZSwgbWFyZ2luLCB1bml0UHgpIHtcclxuICByZXR1cm4gbWFyZ2luICsgTWF0aC5mbG9vcih2YWx1ZSAqIHVuaXRQeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHlEYXRhVG9DYW52YXModmFsdWUsIG1hcmdpbiwgdW5pdFB4LCBjYW52YXNIZWlnaHQpIHtcclxuICByZXR1cm4gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcih2YWx1ZSAqIHVuaXRQeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdBeGlzKGNvbnRleHQsIHR5cGUsIG1hcmdpbiwgeEF4aXNNaW4sIHhBeGlzTWF4LCBjYW52YXNXaWR0aCwgeFVuaXRQeCwgeFRpdGxlLCB5QXhpc01pbiwgeUF4aXNNYXgsIGNhbnZhc0hlaWdodCwgeVVuaXRQeCwgeVRpdGxlKSB7XHJcbiAgY29udGV4dC5mb250ID0gJzEwcHggQXJpYWwnO1xyXG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xyXG4gIGNvbnRleHQubGluZVdpZHRoID0gMTtcclxuICB2YXIgeUF4aXNQb3NpdGlvbixcclxuICAgIHhBeGlzUG9zaXRpb24sXHJcbiAgICB5VGl0bGVQb3NpdGlvbixcclxuICAgIHhUaXRsZVBvc2l0aW9uLFxyXG4gICAgeVRpdGxlU2lkZSxcclxuICAgIHhUaXRsZVNpZGU7XHJcblxyXG4gIC8vZGV0ZXJtaW5lIHlBeGlzIHBvc2l0aW9uXHJcbiAgaWYgKHhBeGlzTWluIDw9IDAgJiYgeEF4aXNNYXggPj0gMCkgeyB5QXhpc1Bvc2l0aW9uID0gMDsgfVxyXG4gIGVsc2Uge1xyXG4gICAgaWYgKHhBeGlzTWluID4gMCkgeyB5QXhpc1Bvc2l0aW9uID0geEF4aXNNaW47IH1cclxuICAgIGVsc2UgeyB5QXhpc1Bvc2l0aW9uID0geEF4aXNNYXg7IH1cclxuICB9XHJcblxyXG4gIC8vZHJhdyB5IEF4aXNcclxuICBjb250ZXh0LmJlZ2luUGF0aCgpOyAvLyBwcmV2ZW50cyB3ZWlyZCBiZWhhdmlvciB3aXRoIElFOVxyXG4gIGNvbnRleHQubW92ZVRvKE1hdGguZmxvb3IoKHlBeGlzUG9zaXRpb24gLSB4QXhpc01pbikgKiB4VW5pdFB4KSArIG1hcmdpbiwgY2FudmFzSGVpZ2h0IC0gbWFyZ2luKTtcclxuICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKCh5QXhpc1Bvc2l0aW9uIC0geEF4aXNNaW4pICogeFVuaXRQeCkgKyBtYXJnaW4sIG1hcmdpbik7XHJcblxyXG4gIC8vZGV0ZXJtaW5lIHggdGl0bGUgcG9zaXRpb24gYW5kIHkgdGl0bGUncyBzaWRlXHJcbiAgaWYgKHhBeGlzTWF4IC0geUF4aXNQb3NpdGlvbiA+PSB5QXhpc1Bvc2l0aW9uIC0geEF4aXNNaW4pIHsgeFRpdGxlUG9zaXRpb24gPSAoeEF4aXNNYXggKyB5QXhpc1Bvc2l0aW9uKSAvIDI7IHlUaXRsZVNpZGUgPSAtMzA7IH1cclxuICBlbHNlIHsgeFRpdGxlUG9zaXRpb24gPSAoeUF4aXNQb3NpdGlvbiArIHhBeGlzTWluKSAvIDI7IHlUaXRsZVNpZGUgPSArMzA7IH1cclxuICAvL2FsZXJ0KHhUaXRsZVBvc2l0aW9uKTtcclxuXHJcbiAgLy9kZXRlcm1pbmUgeEF4aXMgcG9zaXRpb25cclxuICBpZiAoeUF4aXNNaW4gPD0gMCAmJiB5QXhpc01heCA+PSAwICYmIHR5cGUgPT0gJ2xpbmVhclNjYWxlJykgeyB4QXhpc1Bvc2l0aW9uID0gMDsgfVxyXG4gIGVsc2Uge1xyXG4gICAgaWYgKHlBeGlzTWluID4gMCB8fCB0eXBlID09ICdsb2dTY2FsZScpIHsgeEF4aXNQb3NpdGlvbiA9IHlBeGlzTWluOyB9XHJcbiAgICBlbHNlIHsgeEF4aXNQb3NpdGlvbiA9IHlBeGlzTWF4OyB9XHJcbiAgfVxyXG5cclxuICAvL2RyYXcgeCBBeGlzXHJcblxyXG4gIGNvbnRleHQubW92ZVRvKG1hcmdpbiwgY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeEF4aXNQb3NpdGlvbiAtIHlBeGlzTWluKSAqIHlVbml0UHgpKTtcclxuICBjb250ZXh0LmxpbmVUbyhjYW52YXNXaWR0aCAtIG1hcmdpbiwgY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeEF4aXNQb3NpdGlvbiAtIHlBeGlzTWluKSAqIHlVbml0UHgpKTtcclxuXHJcbiAgLy9kZXRlcm1pbmUgeSB0aXRsZSBwb3NpdGlvbiBhbmQgeCB0aXRsZSdzIHNpZGVcclxuICBpZiAoeUF4aXNNYXggLSB4QXhpc1Bvc2l0aW9uID49IHhBeGlzUG9zaXRpb24gLSB5QXhpc01pbikgeyB5VGl0bGVQb3NpdGlvbiA9ICh5QXhpc01heCArIHhBeGlzUG9zaXRpb24pIC8gMjsgeFRpdGxlU2lkZSA9IDI1OyB9XHJcbiAgZWxzZSB7IHlUaXRsZVBvc2l0aW9uID0gKHhBeGlzUG9zaXRpb24gKyB5QXhpc01pbikgLyAyOyB4VGl0bGVTaWRlID0gLTI1OyB9XHJcblxyXG4gIC8vd3JpdGUgeCB0aXRsZVxyXG4gIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgaWYgKHhUaXRsZVNpZGUgPiAwKSB7IGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7IH1cclxuICBlbHNlIHsgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJzsgfVxyXG4gIGNvbnRleHQuZmlsbFRleHQoeFRpdGxlLCBtYXJnaW4gKyBNYXRoLmZsb29yKCh4VGl0bGVQb3NpdGlvbiAtIHhBeGlzTWluKSAqIHhVbml0UHgpLCBjYW52YXNIZWlnaHQgLSBtYXJnaW4gLSBNYXRoLmZsb29yKCh4QXhpc1Bvc2l0aW9uIC0geUF4aXNNaW4pICogeVVuaXRQeCkgKyB4VGl0bGVTaWRlKTtcclxuXHJcbiAgLy93cml0ZSB5IHRpdGxlXHJcbiAgY29udGV4dC5yb3RhdGUoLU1hdGguUEkgLyAyKTsgLy9yb3RhdGUgdGhlIHdob2xlIGNhbnZhcyB0byB3cml0ZSB5IHRpdGxlIHZlcnRpY2FsbHlcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gIGlmICh5VGl0bGVTaWRlID4gMCkgeyBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnOyB9XHJcbiAgZWxzZSB7IGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7IH1cclxuXHJcbiAgdmFyIHggPSBtYXJnaW4gKyBNYXRoLmZsb29yKCh5QXhpc1Bvc2l0aW9uIC0geEF4aXNNaW4pICogeFVuaXRQeCkgKyB5VGl0bGVTaWRlLFxyXG4gICAgeSA9IGNhbnZhc0hlaWdodCAtIG1hcmdpbiAtIE1hdGguZmxvb3IoKHlUaXRsZVBvc2l0aW9uIC0geUF4aXNNaW4pICogeVVuaXRQeCk7XHJcbiAgY29udGV4dC5maWxsVGV4dCh5VGl0bGUsIC15LCB4KTtcclxuICBjb250ZXh0LnJvdGF0ZShNYXRoLlBJIC8gMik7XHJcblxyXG5cclxuICByZXR1cm4gW3hBeGlzUG9zaXRpb24sIHhUaXRsZVNpZGUsIHlBeGlzUG9zaXRpb24sIHlUaXRsZVNpZGVdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3VGlja3MoY29udGV4dCwgdHlwZSwgbWFyZ2luLCB4QXhpc01pbiwgeEF4aXNNYXgsIHhTdGVwLCBjYW52YXNXaWR0aCwgeFVuaXRQeCwgeEF4aXNQb3NpdGlvbiwgeFRpY2tzU2lkZSwgeUF4aXNNaW4sIHlBeGlzTWF4LCB5U3RlcCwgY2FudmFzSGVpZ2h0LCB5VW5pdFB4LCB5QXhpc1Bvc2l0aW9uLCB5VGlja3NTaWRlKSB7XHJcbiAgdmFyIHhQeCxcclxuICAgIHlQeCxcclxuICAgIHRpY2tMYWJlbDtcclxuXHJcbiAgLy94IEF4aXNcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gIGlmICh4VGlja3NTaWRlID4gMCkgeyBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnOyB9XHJcbiAgZWxzZSB7IGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7IH1cclxuXHJcbiAgLy9tYWpvciB0aWNrc1xyXG4gIGZvciAodmFyIHggPSB4QXhpc01pbjsgeCA8PSB4QXhpc01heDsgeCArPSB4U3RlcCkge1xyXG4gICAgeFB4ID0gbWFyZ2luICsgTWF0aC5mbG9vcigoeCAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgeVB4ID0gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeEF4aXNQb3NpdGlvbiAtIHlBeGlzTWluKSAqIHlVbml0UHgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oeFB4LCB5UHgpO1xyXG4gICAgY29udGV4dC5saW5lVG8oeFB4LCB5UHggKyAyICogeFRpY2tzU2lkZSk7XHJcblxyXG4gICAgaWYgKHggPT0geEF4aXNQb3NpdGlvbiAmJiB4QXhpc1Bvc2l0aW9uICE9IHlBeGlzTWluICYmIHhBeGlzUG9zaXRpb24gIT0geUF4aXNNYXgpIHtcclxuICAgICAgeFB4ID0geFB4IC0gMTAgKiB5VGlja3NTaWRlO1xyXG4gICAgfSAvL2F2b2lkcyB0aGUgbWVzc3kgemVybyBsYWJlbHMgYXQgdGhlIGF4ZXMnIGludGVyc2VjdGlvbnNcclxuICAgIHRpY2tMYWJlbCA9IGNoYW5nZVByZWNpc2lvbig3LCB4KTtcclxuICAgIGNvbnRleHQuZmlsbFRleHQodGlja0xhYmVsLCB4UHgsIHlQeCArIDUgKiB4VGlja3NTaWRlKTsgLy90aWNrIGxhYmVsXHJcbiAgfVxyXG5cclxuICAvL21pbm9yIHRpY2tzXHJcbiAgZm9yICh2YXIgeCA9IHhBeGlzTWluOyB4IDwgeEF4aXNNYXg7IHggKz0geFN0ZXAgLyAyKSB7XHJcbiAgICB4UHggPSBtYXJnaW4gKyBNYXRoLmZsb29yKCh4IC0geEF4aXNNaW4pICogeFVuaXRQeCk7XHJcbiAgICB5UHggPSBjYW52YXNIZWlnaHQgLSBtYXJnaW4gLSBNYXRoLmZsb29yKCh4QXhpc1Bvc2l0aW9uIC0geUF4aXNNaW4pICogeVVuaXRQeCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyh4UHgsIHlQeCk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyh4UHgsIHlQeCArIDEgKiB4VGlja3NTaWRlKTtcclxuICB9XHJcblxyXG4gIC8veSBBeGlzXHJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICBpZiAoeVRpY2tzU2lkZSA+IDApIHsgY29udGV4dC50ZXh0QWxpZ24gPSAnbGVmdCc7IH1cclxuICBlbHNlIHsgY29udGV4dC50ZXh0QWxpZ24gPSAncmlnaHQnOyB9XHJcbiAgLy9tYWpvciB0aWNrc1xyXG4gIGZvciAodmFyIHkgPSB5QXhpc01pbjsgeSA8PSB5QXhpc01heDsgeSArPSB5U3RlcCkge1xyXG4gICAgeVB4ID0gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeSAtIHlBeGlzTWluKSAqIHlVbml0UHgpO1xyXG4gICAgeFB4ID0gbWFyZ2luICsgTWF0aC5mbG9vcigoeUF4aXNQb3NpdGlvbiAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oeFB4LCB5UHgpO1xyXG4gICAgY29udGV4dC5saW5lVG8oeFB4ICsgMiAqIHlUaWNrc1NpZGUsIHlQeCk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT0gJ2xvZ1NjYWxlJyAmJiB5IDwgeUF4aXNNYXgpIHtcclxuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMTA7IGorKykge1xyXG4gICAgICAgIHZhciB5TWlub3IgPSBNYXRoLmZsb29yKHlQeCAtIHlTdGVwICogeVVuaXRQeCAqIGxvZzEwKGogLyAxMCkgLSB5U3RlcCAqIHlVbml0UHgpICsgMC41O1xyXG5cclxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UHgsIHlNaW5vcik7XHJcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFB4ICsgMSAqIHlUaWNrc1NpZGUsIHlNaW5vcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRpY2tMYWJlbCA9IGNoYW5nZVByZWNpc2lvbig3LCB5KTtcclxuICAgIGlmICh0eXBlID09ICdsb2dTY2FsZScpIHtcclxuICAgICAgdGlja0xhYmVsID0gJzFFJyArIHk7XHJcbiAgICB9XHJcbiAgICBpZiAoeSA9PSB4QXhpc1Bvc2l0aW9uICYmIHlBeGlzUG9zaXRpb24gIT0geEF4aXNNaW4gJiYgeUF4aXNQb3NpdGlvbiAhPSB4QXhpc01heCkge1xyXG4gICAgICB5UHggPSB5UHggLSAxMCAqIHhUaWNrc1NpZGU7XHJcbiAgICB9IC8vYXZvaWRzIHRoZSBtZXNzeSBsYWJlbHMgYXQgdGhlIGF4ZXMnIGludGVyc2VjdGlvbnNcclxuICAgIGNvbnRleHQuZmlsbFRleHQodGlja0xhYmVsLCB4UHggKyA1ICogeVRpY2tzU2lkZSwgeVB4KTsgLy90aWNrIGxhYmVsXHJcbiAgfVxyXG4gIC8vbWlub3IgdGlja3NcclxuICBpZiAodHlwZSA9PSAnbGluZWFyU2NhbGUnKSB7XHJcbiAgICBmb3IgKHZhciB5ID0geUF4aXNNaW47IHkgPCB5QXhpc01heDsgeSArPSB5U3RlcCAvIDIpIHtcclxuXHJcbiAgICAgIHlQeCA9IGNhbnZhc0hlaWdodCAtIG1hcmdpbiAtIE1hdGguZmxvb3IoKHkgLSB5QXhpc01pbikgKiB5VW5pdFB4KTtcclxuICAgICAgeFB4ID0gbWFyZ2luICsgTWF0aC5mbG9vcigoeUF4aXNQb3NpdGlvbiAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG5cclxuICAgICAgY29udGV4dC5tb3ZlVG8oeFB4LCB5UHgpO1xyXG4gICAgICBjb250ZXh0LmxpbmVUbyh4UHggKyAxICogeVRpY2tzU2lkZSwgeVB4KTtcclxuICAgIH1cclxuICB9XHJcbiAgY29udGV4dC5zdHJva2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVnZW5kKGNvbnRleHQsIHR5cGUsIGFycmF5TXVsdCwgcGxvdFN0eWxlLCBtYXJnaW4sIHhBeGlzTWluLCB4VW5pdFB4LCB5QXhpc01pbiwgeVVuaXRQeCwgY2FudmFzSGVpZ2h0KSB7XHJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdsZWZ0JztcclxuICB2YXIgeCwgeSwgeFB4LCB5UHggPSAnK0luZmluaXR5JywgaW5kZXgsIHh5LCBhcnJheSA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlNdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBhcnJheSA9IGFycmF5TXVsdFtpXTtcclxuICAgIGluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTsvL2xhc3QgcG9pbnRcclxuICAgIHh5ID0gYXJyYXlbaW5kZXhdO1xyXG4gICAgeCA9IHh5WzBdO1xyXG4gICAgeSA9IHh5WzFdO1xyXG5cclxuICAgIHhQeCA9IDEwICsgbWFyZ2luICsgTWF0aC5mbG9vcigoeCAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgaWYgKHR5cGUgPT0gJ2xvZ1NjYWxlJykgeyB5ID0gbG9nMTAoTWF0aC5hYnMoeSkpOyB9XHJcbiAgICBpZiAoaXNGaW5pdGUoeSkpIHtcclxuICAgICAgeVB4ID0gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeSAtIHlBeGlzTWluKSAqIHlVbml0UHgpO1xyXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBsb3RTdHlsZVtpXVsxXTsgLy9jb2xvclxyXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHBsb3RTdHlsZVtpXVsyXSwgeFB4LCB5UHgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcGxvdChhcnJheSwgY29udGV4dCwgdHlwZSwgcGxvdFN0eWxlLCBtYXJnaW4sIHhBeGlzTWluLCB4QXhpc01heCwgY2FudmFzV2lkdGgsIHhVbml0UHgsIHlBeGlzTWluLCB5QXhpc01heCwgY2FudmFzSGVpZ2h0LCB5VW5pdFB4LCB5QXhpc1Bvc2l0aW9uKSB7XHJcbiAgdmFyIHhQeCwgeVB4LCB5LCBqID0gMDtcclxuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcGxvdFN0eWxlWzFdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgLy9vbmUgbG9vcCBmb3IgZWFjaCBkYXRhIHBvaW50XHJcbiAgICB4UHggPSBtYXJnaW4gKyBNYXRoLmZsb29yKChhcnJheVtpXVswXSAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgeSA9IChhcnJheVtpXVsxXSk7XHJcbiAgICBpZiAodHlwZSA9PSAnbG9nU2NhbGUnKSB7XHJcbiAgICAgIHkgPSBsb2cxMChNYXRoLmFicyh5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoeSAhPSAnLUluZmluaXR5Jykgey8veSA9ICctSW5maW5pdHknIHdoZW4geSA9IDAgYW5kIHNjYWxlIGlzIExvZ1xyXG4gICAgICB5UHggPSBjYW52YXNIZWlnaHQgLSBtYXJnaW4gLSBNYXRoLmZsb29yKCh5IC0geUF4aXNNaW4pICogeVVuaXRQeCk7XHJcbiAgICAgIHN3aXRjaCAocGxvdFN0eWxlWzBdKSB7XHJcbiAgICAgICAgY2FzZSAnbGluZSc6IHtcclxuICAgICAgICAgIGlmIChqID09IDApIHsgLy8gaj09MCA8PT4gMXN0IHBsb3R0ZWQgcG9pbnQsIG5vdCBuZWNlc3NhcmlseSAxc3QgcG9pbnQgaW4gdGhlIGFycmF5IFxyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UHgsIHlQeCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4UHgsIHlQeCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnY2lyY2xlcyc6IHtcclxuICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICBjb250ZXh0LmFyYyh4UHgsIHlQeCwgMywgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdkaWFnb25hbENyb3NzJzoge1xyXG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQeCAtIDIsIHlQeCAtIDIpO1xyXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oeFB4ICsgMiwgeVB4ICsgMik7XHJcbiAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UHggKyAyLCB5UHggLSAyKTtcclxuICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQeCAtIDIsIHlQeCArIDIpO1xyXG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICd2ZXJ0aWNhbENyb3NzJzoge1xyXG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQeCwgeVB4IC0gMik7XHJcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4UHgsIHlQeCArIDIpO1xyXG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oeFB4ICsgMiwgeVB4KTtcclxuICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQeCAtIDIsIHlQeCk7XHJcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGorKztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHBsb3RTdHlsZVswXSA9PSAnbGluZScpIHsgY29udGV4dC5zdHJva2UoKTsgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2pzL2JvYkdyYXBoLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"/*\\r\\n * Base structure\\r\\n */\\r\\n\\r\\n/* Move down content because we have a fixed navbar that is 50px tall */\\r\\nbody {\\r\\n  padding-top: 60px;\\r\\n}\\r\\n\\r\\n.navbar-brand {\\r\\n  font-size: 36px;\\r\\n}\\r\\n\\r\\n/*\\r\\n * Global add-ons\\r\\n */\\r\\n\\r\\n.sub-header {\\r\\n  padding-bottom: 10px;\\r\\n  border-bottom: 1px solid #eee;\\r\\n}\\r\\n\\r\\n/*\\r\\n * Top navigation\\r\\n * Hide default border to remove 1px line.\\r\\n */\\r\\n.navbar-fixed-top {\\r\\n  border: 0;\\r\\n  height: 60px;\\r\\n}\\r\\n\\r\\n/*\\r\\n * Sidebar\\r\\n */\\r\\n\\r\\n@media (min-width: 768px) {\\r\\n  .sidebar {\\r\\n    position: fixed;\\r\\n    top: 60px;\\r\\n    bottom: 0;\\r\\n    left: 0;\\r\\n    z-index: 1000;\\r\\n    display: block;\\r\\n    padding: 20px;\\r\\n    overflow-x: hidden;\\r\\n    overflow-y: auto; /* Scrollable contents if viewport is shorter than content. */\\r\\n    background-color: #f5f5f5;\\r\\n    border-right: 1px solid #eee;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Sidebar navigation */\\r\\n.nav-sidebar {\\r\\n  margin-right: -21px; /* 20px padding + 1px border */\\r\\n  margin-bottom: 20px;\\r\\n  margin-left: -20px;\\r\\n}\\r\\n.nav-sidebar > li > a {\\r\\n  padding-right: 20px;\\r\\n  padding-left: 20px;\\r\\n}\\r\\n.nav-sidebar > .active > a,\\r\\n.nav-sidebar > .active > a:hover,\\r\\n.nav-sidebar > .active > a:focus {\\r\\n  color: #fff;\\r\\n  background-color: #428bca;\\r\\n}\\r\\n\\r\\n\\r\\n/*\\r\\n * Main content\\r\\n */\\r\\n\\r\\n.main {\\r\\n  padding: 20px;\\r\\n}\\r\\n@media (min-width: 768px) {\\r\\n  .main {\\r\\n    padding-right: 40px;\\r\\n    padding-left: 40px;\\r\\n  }\\r\\n}\\r\\n.main .page-header {\\r\\n  margin-top: 0;\\r\\n}\\r\\n\\r\\n/* fa icons */\\r\\n.fa-toggle-on, .fa-toggle-off {\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.fa-toggle-on {\\r\\n  /*color: #f1f1f1;*/\\r\\n  color: #dddddd;\\r\\n  color: #8ce196;\\r\\n}\\r\\n\\r\\n.fa-toggle-off {\\r\\n  color: #dddddd;\\r\\n}\\r\\n\\r\\nbutton.play > span#pause {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\nbutton.pause > span#play {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\ndiv.input-group#ds {\\r\\n  width: 60%;\\r\\n}\\r\\n\\r\\n.panel {\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.panel.nofile:after {\\r\\n  content: \\\" \\\";\\r\\n  z-index: 10;\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  background: rgba(255, 255, 255, 0.5);\\r\\n  border-radius: 4px;\\r\\n}\", \"\"]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5jc3M/NGNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcclxcbiAqIEJhc2Ugc3RydWN0dXJlXFxyXFxuICovXFxyXFxuXFxyXFxuLyogTW92ZSBkb3duIGNvbnRlbnQgYmVjYXVzZSB3ZSBoYXZlIGEgZml4ZWQgbmF2YmFyIHRoYXQgaXMgNTBweCB0YWxsICovXFxyXFxuYm9keSB7XFxyXFxuICBwYWRkaW5nLXRvcDogNjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLm5hdmJhci1icmFuZCB7XFxyXFxuICBmb250LXNpemU6IDM2cHg7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuICogR2xvYmFsIGFkZC1vbnNcXHJcXG4gKi9cXHJcXG5cXHJcXG4uc3ViLWhlYWRlciB7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXHJcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiAqIFRvcCBuYXZpZ2F0aW9uXFxyXFxuICogSGlkZSBkZWZhdWx0IGJvcmRlciB0byByZW1vdmUgMXB4IGxpbmUuXFxyXFxuICovXFxyXFxuLm5hdmJhci1maXhlZC10b3Age1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgaGVpZ2h0OiA2MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiAqIFNpZGViYXJcXHJcXG4gKi9cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXHJcXG4gIC5zaWRlYmFyIHtcXHJcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgICB0b3A6IDYwcHg7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgbGVmdDogMDtcXHJcXG4gICAgei1pbmRleDogMTAwMDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHBhZGRpbmc6IDIwcHg7XFxyXFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG4gICAgb3ZlcmZsb3cteTogYXV0bzsgLyogU2Nyb2xsYWJsZSBjb250ZW50cyBpZiB2aWV3cG9ydCBpcyBzaG9ydGVyIHRoYW4gY29udGVudC4gKi9cXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTtcXHJcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2VlZTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogU2lkZWJhciBuYXZpZ2F0aW9uICovXFxyXFxuLm5hdi1zaWRlYmFyIHtcXHJcXG4gIG1hcmdpbi1yaWdodDogLTIxcHg7IC8qIDIwcHggcGFkZGluZyArIDFweCBib3JkZXIgKi9cXHJcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxuICBtYXJnaW4tbGVmdDogLTIwcHg7XFxyXFxufVxcclxcbi5uYXYtc2lkZWJhciA+IGxpID4gYSB7XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xcclxcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcclxcbn1cXHJcXG4ubmF2LXNpZGViYXIgPiAuYWN0aXZlID4gYSxcXHJcXG4ubmF2LXNpZGViYXIgPiAuYWN0aXZlID4gYTpob3ZlcixcXHJcXG4ubmF2LXNpZGViYXIgPiAuYWN0aXZlID4gYTpmb2N1cyB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0MjhiY2E7XFxyXFxufVxcclxcblxcclxcblxcclxcbi8qXFxyXFxuICogTWFpbiBjb250ZW50XFxyXFxuICovXFxyXFxuXFxyXFxuLm1haW4ge1xcclxcbiAgcGFkZGluZzogMjBweDtcXHJcXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxyXFxuICAubWFpbiB7XFxyXFxuICAgIHBhZGRpbmctcmlnaHQ6IDQwcHg7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogNDBweDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuLm1haW4gLnBhZ2UtaGVhZGVyIHtcXHJcXG4gIG1hcmdpbi10b3A6IDA7XFxyXFxufVxcclxcblxcclxcbi8qIGZhIGljb25zICovXFxyXFxuLmZhLXRvZ2dsZS1vbiwgLmZhLXRvZ2dsZS1vZmYge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uZmEtdG9nZ2xlLW9uIHtcXHJcXG4gIC8qY29sb3I6ICNmMWYxZjE7Ki9cXHJcXG4gIGNvbG9yOiAjZGRkZGRkO1xcclxcbiAgY29sb3I6ICM4Y2UxOTY7XFxyXFxufVxcclxcblxcclxcbi5mYS10b2dnbGUtb2ZmIHtcXHJcXG4gIGNvbG9yOiAjZGRkZGRkO1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24ucGxheSA+IHNwYW4jcGF1c2Uge1xcclxcbiAgZGlzcGxheTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uLnBhdXNlID4gc3BhbiNwbGF5IHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbmRpdi5pbnB1dC1ncm91cCNkcyB7XFxyXFxuICB3aWR0aDogNjAlO1xcclxcbn1cXHJcXG5cXHJcXG4ucGFuZWwge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4ucGFuZWwubm9maWxlOmFmdGVyIHtcXHJcXG4gIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXHJcXG4gIHotaW5kZXg6IDEwO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxyXFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vc3JjL2luZGV4LmNzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/ZGEwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\t// Test for IE <= 9 as proposed by Browserhacks\n\t\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t\t// Tests for existence of standard globals is to allow style-loader \n\t\t// to operate correctly into non-standard environments\n\t\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\t\treturn window && document && document.all && !window.atob;\n\t}),\n\tgetElement = (function(fn) {\n\t\tvar memo = {};\n\t\treturn function(selector) {\n\t\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t\t}\n\t\t\treturn memo[selector]\n\t\t};\n\t})(function (styleTarget) {\n\t\treturn document.querySelector(styleTarget)\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [],\n\tfixUrls = __webpack_require__(7);\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (typeof options.insertInto === \"undefined\") options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar styleTarget = getElement(options.insertInto)\n\tif (!styleTarget) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\tstyleTarget.insertBefore(styleElement, styleTarget.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\tstyleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\tstyleTarget.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\tstyleTarget.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\toptions.attrs.type = \"text/css\";\n\n\tattachTagAttrs(styleElement, options.attrs);\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\tattachTagAttrs(linkElement, options.attrs);\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction attachTagAttrs(element, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\telement.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove, transformResult;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    transformResult = options.transform(obj.css);\n\t    \n\t    if (transformResult) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = transformResult;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css. \n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement, options);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls){\n\t\tcss = fixUrls(css);\n\t}\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcz9iOTgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHRcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0XHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxuXHRcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcblx0fSksXG5cdGdldEVsZW1lbnQgPSAoZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdFx0fTtcblx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXG5cdGZpeFVybHMgPSByZXF1aXJlKFwiLi9maXhVcmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cdGlmICghc3R5bGVUYXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIHN0eWxlVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmUsIHRyYW5zZm9ybVJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHRyYW5zZm9ybVJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXHQgICAgXG5cdCAgICBpZiAodHJhbnNmb3JtUmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gdHJhbnNmb3JtUmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy4gXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscyl7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanM/NGUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bobGraph__ = __webpack_require__(3);\n\r\n\r\n__webpack_require__(1);\r\n__webpack_require__(2);\r\n__webpack_require__(0);\r\n\r\n// Immediately Invoked Function Expression\r\n(function () {\r\n  'use strict';\r\n\r\n  const mchEps = machineEpsilon();\r\n\r\n  // Elementary charge and Boltzmann constant\r\n  const q = 1.60217653E-19,\r\n    k = 1.3806488E-23;\r\n\r\n  let arrayCalc,\r\n    fileOpened = false,\r\n    plotStyle = [],\r\n    userData = {\r\n      estimatedParameters: {\r\n        Rp: undefined\r\n      },\r\n      current: {\r\n        shunt: undefined,\r\n        nonLinear: undefined,\r\n        noIrpNoSCLCarray: undefined\r\n      },\r\n      dataArray: [],\r\n      modifDataArray: []\r\n    },\r\n    parameters = {\r\n      minVolt: undefined,\r\n      maxVolt: undefined,\r\n      stepVolt: undefined,\r\n      iph: undefined,\r\n      t: undefined,\r\n      n1: undefined,\r\n      n2: undefined,\r\n      is1: undefined,\r\n      is2: undefined,\r\n      rp1: undefined,\r\n      rp2: undefined,\r\n      rs: undefined,\r\n      // Methods:\r\n      init: initParameters,\r\n      update: updateParameter\r\n    },\r\n    model = {};\r\n\r\n  function initParameters() {\r\n    // Used as a method by parameter object\r\n    for (let property in this) {\r\n      const isDataProperty = typeof this[property] !== 'function';\r\n      if (isDataProperty) {\r\n        const $inputNumber = $('[type=number].' + property),\r\n          $inputCheckBox = $('[type=checkbox].' + property);\r\n        this[property] = {\r\n          value: parseFloat($inputNumber.val()),\r\n          checked: $inputCheckBox.is(':checked')\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateParameter($element) {\r\n    // Used as a method by parameter object\r\n    for (let property in this) {\r\n      if ($element.hasClass(property)) {\r\n        const elementValue = parseFloat($element.val()),\r\n          inputIsLogRange = $element.hasClass('logscale') && $element.attr('type') === 'range',\r\n          newValue = (inputIsLogRange) ? Math.pow(10, elementValue) : elementValue;\r\n        this[property] = {\r\n          value: newValue,\r\n          checked: $element.is(':checked')\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  function machineEpsilon() {\r\n    // Calculate Machine Epsilon\r\n    let temp1, temp2;\r\n    temp1 = 1.0;\r\n    do {\r\n      temp1 /= 2;\r\n      temp2 = 1.0 + temp1;\r\n    } while (temp2 > 1.0);\r\n    return temp1;\r\n  }\r\n\r\n  $(function () {\r\n    // When page is loaded\r\n\r\n    $('input[type=radio].default')\r\n      .attr('checked', true);\r\n\r\n    clearFileInput();\r\n\r\n    parameters.init();\r\n\r\n    model = getModel();\r\n\r\n    // Calculate a first time\r\n    // IV using the initial parameters\r\n    calcIVandPlot();\r\n\r\n    bindEvents();\r\n  });\r\n\r\n  function bindEvents() {\r\n    $('input[type=range].syncme')\r\n      .on('input', inputEvent)\r\n      .mouseup(rangeInputMouseUp);\r\n\r\n    $('input[type=number].syncme')\r\n      .change(inputEvent)\r\n      .keydown(numberInputKeyDown)\r\n      .blur(changeStep);\r\n\r\n    $('input[type=number].voltage')\r\n      .change(voltageInputChanged);\r\n\r\n    $('input[type=radio].model')\r\n      .change(modelChanged);\r\n\r\n    $('input[type=radio].scale')\r\n      .change(changeScaleType);\r\n\r\n    $(':file')\r\n      .change(fileInputChanged);\r\n\r\n    $('.fa-toggle-on, .fa-toggle-off')\r\n      .click(faToggleClicked);\r\n\r\n    $('#useestimatedparams')\r\n      .click(useEstimatedParams);\r\n\r\n    $('button#start')\r\n      .click(startButtonClicked);\r\n\r\n    $('input#clear')\r\n      .click(clearData);\r\n\r\n    $('[type=checkbox]')\r\n      .change(parameterCheckBoxChanged);\r\n  }\r\n\r\n  function changeScaleType() {\r\n    // Event handler\r\n    // fired when user clicks on a scale type radio button\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function rangeInputMouseUp() {\r\n    // Event handler\r\n    adjustRange(this);\r\n  }\r\n\r\n  function numberInputKeyDown(event) {\r\n    const keyCode = event.which,\r\n      upOrDownArrowKeyDown = keyCode == 38 || keyCode == 40;\r\n\r\n    if (upOrDownArrowKeyDown) {\r\n      syncInputs(this);\r\n      adjustRange(this);\r\n      calcIVandPlot();\r\n    }\r\n  }\r\n\r\n  function calcIVandPlot() {\r\n    const ivResult = calcIV(parameters, getModel());\r\n\r\n    arrayCalc = ivResult.arrayCalc;\r\n    plotStyle = ivResult.plotStyle;\r\n\r\n    // and plot the result\r\n    combDataAndCalc();\r\n  }\r\n\r\n  function fileInputChanged() {\r\n    // Fired when user selects a new file\r\n    // to import\r\n    const file = this.files[0];\r\n    $(this)\r\n      .closest('.input-group')\r\n      .children('input:text')\r\n      .val(file.name);\r\n    processFiles(file);\r\n  }\r\n\r\n  function faToggleClicked() {\r\n    // Fired when user clicks on any of the font-awesome toggle icons\r\n    // As of now there are 2 of these icons on the page\r\n    const iElem = this; // <i> element\r\n\r\n    $(iElem)\r\n      .toggleClass('fa-toggle-on fa-toggle-off');\r\n\r\n    if (iElem.id === 'hideIrp') {\r\n      userData.modifDataArray = toggleIrp(userData.modifDataArray, userData.current.shunt, IprShowed());\r\n      combDataAndCalc();\r\n    }\r\n\r\n    if (iElem.id === 'hideNonLinCurr') {\r\n      const toggleResult = toggleNonLinCurr(userData, userData.modifDataArray, nonLinearCurrentShowed());\r\n      userData.dataArray = toggleResult.dataArray;\r\n      userData.modifDataArray = toggleResult.modifDataArray;\r\n      combDataAndCalc();\r\n    }\r\n  }\r\n\r\n  function parameterCheckBoxChanged() {\r\n    /* Fired when user clicks on any of the checkbox inputs\r\n    These checkboxes define whether the corresponding diode\r\n    parameter varies or not during optimization\r\n    Therefore, if unchecked, the parameter will not be estimated. */\r\n    findAndEstimateDiodes();\r\n  }\r\n\r\n  function syncInputs(sourceElem) {\r\n    // Sync range and number inputs\r\n\r\n    const $sourceInput = $(sourceElem),\r\n      isSourceRange = $sourceInput.attr('type') === 'range',\r\n      targetType = (isSourceRange) ? 'number' : 'range',\r\n      sourceValue = $sourceInput.val();\r\n\r\n    // Sync companion input\r\n    const $targetInput = $sourceInput\r\n      .closest('.row')\r\n      .find('input.syncme[type=' + targetType + ']'),\r\n      isScaleLog = $targetInput.hasClass('logscale');\r\n\r\n    if (isScaleLog) {\r\n      const targetValue = (isSourceRange) ? Math.pow(10, sourceValue).toExponential(2) : log10(sourceValue);\r\n      $targetInput.val(targetValue);\r\n    } else {\r\n      // Linear scale\r\n      $targetInput.val(sourceValue);\r\n    }\r\n  }\r\n\r\n  function syncAllInputs() {\r\n    $('input[type=number].syncme')\r\n      .each(function (index, element) {\r\n        syncInputs(element);\r\n      });\r\n  }\r\n\r\n  function inputEvent() {\r\n    // Event handler\r\n    // fired when user moves range input or change number input.\r\n    // So \"this\" is a number or range input element\r\n\r\n    const isNumberInput = $(this).attr('type') === 'number';\r\n\r\n    if (isNumberInput) {\r\n      adjustRange(this);\r\n    }\r\n\r\n    syncInputs(this);\r\n\r\n    parameters.update($(this));\r\n\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function voltageInputChanged() {\r\n    // Fired when one of the 3 .voltage inputs is changed by user\r\n\r\n    parameters\r\n      .update($(this));\r\n\r\n    checkVoltageInputs();\r\n\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function checkVoltageInputs() {\r\n    const minVolt = parameters.minVolt.value,\r\n      maxVolt = parameters.maxVolt.value,\r\n      stepVolt = parameters.stepVolt.value;\r\n\r\n    // Make sure maxVolt > minVolt\r\n    if (maxVolt < minVolt) {\r\n      document.getElementById('minVolt').value = maxVolt;\r\n      document.getElementById('maxVolt').value = minVolt;\r\n    }\r\n\r\n    // Make sure stepVolt != 0\r\n    if (stepVolt == 0) {\r\n      document.getElementById('stepVolt').value = 25;\r\n    }\r\n\r\n    // Make sure stepVolt > 0\r\n    if (stepVolt < 0) {\r\n      document.getElementById('stepVolt').value = Math.abs(stepVolt);\r\n    }\r\n  }\r\n\r\n  function log10(val) {\r\n    // Returns base 10 logarithmic\r\n    // (Math.log10() method is not supported by IE11)\r\n    // Can stop using this function with a transpiler\r\n    return Math.log(val) / Math.log(10);\r\n  }\r\n\r\n  function remDecimals(model, number) {\r\n    // Change a number's precision\r\n    const nbDecimals = nbAfterDot(model);\r\n    return Math.round(number * Math.pow(10, nbDecimals)) * Math.pow(10, -nbDecimals);\r\n  }\r\n\r\n  function nbAfterDot(number) {\r\n    // Return the number of digits\r\n    // after decimal separator\r\n    const n = number.toString().indexOf('.');\r\n    if (n == -1) {\r\n      return 0;\r\n    }\r\n    else {\r\n      let i = 0;\r\n      while (number.charAt(n + 1 + i) != '' && isFinite(number.charAt(n + 1 + i))) {\r\n        i++;\r\n      }\r\n      return i;\r\n    }\r\n  }\r\n\r\n  function getRowDiv($input) {\r\n    // Get parameter inputs'\r\n    // closest common ancestor\r\n    return $input\r\n      .closest('.row');\r\n  }\r\n\r\n  function adjustRange(element) {\r\n    // When value reaches input's range limit,\r\n    // modifies range so user is able to use it again\r\n\r\n    const $input = $(element),\r\n      inputType = $input.attr('type'),\r\n      $rowDiv = getRowDiv($input);\r\n\r\n    let $rangeInput = $input,\r\n      rangeInputElem = element,\r\n      $numberInput = $rowDiv\r\n        .find('[type=number]'),\r\n      numberInputElem = $numberInput.get(0);\r\n\r\n    if (inputType === 'number') {\r\n      $rangeInput = $rowDiv\r\n        .find('[type=range]');\r\n      rangeInputElem = $rangeInput.get(0);\r\n      $numberInput = $input;\r\n      numberInputElem = element;\r\n    }\r\n\r\n    let rangeChanged = false;\r\n\r\n    const rangeMax = parseFloat(rangeInputElem.max),\r\n      rangeMin = parseFloat(rangeInputElem.min),\r\n      numberValue = parseFloat(numberInputElem.value);\r\n\r\n    if ($rangeInput.hasClass('linearscale')) {\r\n      if (numberValue >= rangeMax) {\r\n        rangeInputElem.max = remDecimals(numberValue, 1.6 * numberValue);\r\n        rangeInputElem.value = numberValue;\r\n        rangeInputElem.min = remDecimals(numberValue, 0.4 * numberValue);\r\n        rangeChanged = true;\r\n      } else {\r\n        if (numberValue <= rangeMin) {\r\n          rangeInputElem.min = remDecimals(numberInputElem.value, 0.4 * numberInputElem.value);\r\n          rangeInputElem.value = numberInputElem.value;\r\n          rangeInputElem.max = remDecimals(numberInputElem.value, 1.6 * numberInputElem.value);\r\n          rangeChanged = true;\r\n        }\r\n      }\r\n      while (2 * rangeInputElem.step >= (rangeInputElem.max - rangeInputElem.min)) {\r\n        rangeInputElem.max = 2 * rangeInputElem.step + rangeInputElem.max;\r\n      }\r\n    } else {\r\n      // When scale is Log\r\n      if (numberValue >= Math.pow(10, rangeMax)) {\r\n        rangeInputElem.max = Math.round(log10(numberValue) + 3);\r\n        rangeInputElem.value = numberValue;\r\n        rangeInputElem.min = Math.round(log10(numberValue) - 3);\r\n        rangeChanged = true;\r\n      } else {\r\n        if (numberValue <= Math.pow(10, rangeMin)) {\r\n          rangeInputElem.min = Math.round(log10(numberValue) - 3);\r\n          rangeInputElem.value = numberValue;\r\n          rangeInputElem.max = Math.round(log10(numberValue) + 3);\r\n          rangeChanged = true;\r\n        }\r\n      }\r\n    }\r\n    return rangeChanged;\r\n  }\r\n\r\n  function changeStep() {\r\n    // Event handle fired when\r\n    // user blurs number input\r\n    let numberInputElem = this,\r\n      $rangeInput = getRowDiv($(numberInputElem))\r\n        .find('[type=range]'),\r\n      value = numberInputElem.value;\r\n\r\n    if ($rangeInput.hasClass('linearscale')) {\r\n      numberInputElem.value = parseFloat(value); // For Chrome\r\n      var newStep = Math.pow(10, -1 * nbAfterDot(value));\r\n\r\n      numberInputElem.step = newStep;\r\n    }\r\n\r\n    $rangeInput.get().step = newStep;\r\n  }\r\n\r\n  function modelChanged() {\r\n    // Fired when user changes number of diodes or the equivalent circuit\r\n\r\n    // Update model variable\r\n    model = getModel();\r\n\r\n    changeInputStatusBasedOnModel();\r\n\r\n    calcIVandPlot();\r\n\r\n    if (fileOpened) {\r\n      findAndEstimateDiodes();\r\n\r\n      calcSqResSum(parameters, userData.dataArray, arrayCalc);\r\n    }\r\n  }\r\n\r\n  function changeInputStatusBasedOnModel() {\r\n    if (model.circuit === 'parallel') {\r\n      $('input.rp2')\r\n        .prop('disabled', true);\r\n\r\n      const $inputs = $('input.n2, input.is2, #series, #parallel');\r\n\r\n      if (!fileOpened) {\r\n        $inputs\r\n          .not('[type=checkbox]');\r\n      }\r\n\r\n      $inputs\r\n        .prop('disabled', false);\r\n\r\n      document.getElementById('start').disabled = false;\r\n    }\r\n\r\n    if (model.diodeCount === 1) {\r\n      document.getElementById('series').checked = false;\r\n      document.getElementById('parallel').checked = true;\r\n\r\n      model.circuit = 'parallel';\r\n\r\n      $('input.n2, input.is2, #series, #parallel, input.rp2')\r\n        .prop('disabled', true);\r\n\r\n      if (fileOpened) {\r\n        // Will also enable checkboxes\r\n        $('input.n1, input.is1, input.rp1')\r\n          .prop('disabled', false);\r\n      }\r\n\r\n      document.getElementById('start').disabled = false;\r\n    }\r\n\r\n    if (model.circuit === 'series') {\r\n      $('input.n2, input.is2, input.rp2')\r\n        .prop('disabled', false);\r\n\r\n      // Disable fitting inputs because\r\n      // series model not supported for optimization\r\n      disableCheckboxes();\r\n      $('button#start')\r\n        .prop('disabled', true);\r\n    }\r\n  }\r\n\r\n  function disableCheckboxes() {\r\n    $('[type=checkbox]')\r\n      .prop('disabled', true);\r\n  }\r\n\r\n  function findAndEstimateDiodes() {\r\n    const findDiodesResult = findDiodes(userData, IprShowed(), nonLinearCurrentShowed()),\r\n      estimatedParams = estimD1D2Rs(getAllParams(), userData, findDiodesResult);\r\n\r\n    displayEstimatedParams(estimatedParams);\r\n  }\r\n\r\n  function displayEstimatedParams(estimatedParams) {\r\n    // Display the result of estimD1D2Rs into\r\n    // the results table\r\n\r\n    for (let paramName in estimatedParams) {\r\n      const id = paramName.toLowerCase(),\r\n        value = estimatedParams[paramName],\r\n        text = (isParamScaleLog(id)) ? value.toExponential(2) : value.toPrecision(2);\r\n\r\n      $('td.estimation#' + id)\r\n        .text(text);\r\n    }\r\n  }\r\n\r\n  function isParamScaleLog(elemID) {\r\n    // Returns whether scale type used for\r\n    // a given diode parameter is a logarithmic one\r\n    return $('[type=number]#' + elemID)\r\n      .hasClass('logscale');\r\n  }\r\n\r\n  function useEstimatedParams() {\r\n    // Fired when user clicks \"Use estimated parameters\" button\r\n    $('td.estimation')\r\n      .each(updateInput);\r\n\r\n    syncAllInputs();\r\n\r\n    parameters.init();\r\n\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function updateInput(index, element) {\r\n    // Update a parameter input with an estimation\r\n\r\n    const $td = $(element),\r\n      paramClass = $td.attr('id'),\r\n      $input = $('input[type=number].' + paramClass);\r\n\r\n    if ($input.prop('disabled') === false) {\r\n      const value = parseFloat($td.text());\r\n      $input.val(value);\r\n    }\r\n  }\r\n\r\n  function startButtonClicked() {\r\n    // Fired when user clicks on the play/pause button\r\n    // to start or pause the fitting\r\n\r\n    const start = $(this)\r\n      .hasClass('play');\r\n\r\n    togglePlayButton();\r\n\r\n    startPauseVary(start);\r\n  }\r\n\r\n  function togglePlayButton() {\r\n    $('#start')\r\n      .toggleClass('play pause');\r\n  }\r\n\r\n  /* The two following functions calculate\r\n     the current at a given voltage */\r\n\r\n  function Iparallel(V, Iph, prevI, T, n1, n2, Is1, Is2, Rp, Rs) {\r\n    // Double diode (in parallel) model\r\n    let i = 0, I, f, df, r, Id1, Id2, Irp;\r\n\r\n    Iph = Iph / 1000; // mA -> A\r\n\r\n    if (!prevI) {\r\n      I = Iph;\r\n      prevI = I;\r\n    }\r\n\r\n    do {\r\n      if (i > 0) {\r\n        prevI = I;\r\n      }\r\n\r\n      Id1 = Is1 * (Math.exp(q * (V + prevI * Rs) / (n1 * k * T)) - 1);\r\n      Id2 = Is2 * (Math.exp(q * (V + prevI * Rs) / (n2 * k * T)) - 1);\r\n      Irp = (V + prevI * Rs) / Rp;\r\n\r\n      // f(V,prevI)\r\n      f = Iph - Id1 - Id2 - Irp - prevI;\r\n\r\n      // df(V,prevI)/dprevI\r\n      df = -((Is1 * Rs) / (n1 * T * k / q)) * Math.exp((V + prevI * Rs) / (n1 * T * k / q))\r\n        - ((Is2 * Rs) / (n2 * T * k / q)) * Math.exp((V + prevI * Rs) / (n2 * T * k / q))\r\n        - Rs / Rp - 1;\r\n\r\n      // f/df\r\n      r = f / df;\r\n\r\n      I = prevI - r;\r\n\r\n      i++;\r\n\r\n    } while (Math.abs(I - prevI) > mchEps && i < 500);\r\n\r\n    return [I, Id1, Id2, Irp, Id1 + Id2 + Irp];\r\n  }\r\n\r\n  function Iseries(V, T, Iph, n1, n2, Is1, Is2, Rp1, Rp2, Rs) {\r\n    // Double diode (in series) model\r\n    let i = 0, Ia, Ib, V1, V2, Id1, Id2, Irp1, Irp2, H = 10, L = -10;\r\n\r\n    do {\r\n      V1 = (H + L) / 2;\r\n\r\n      Id1 = Is1 * Math.exp(q * V1 / (n1 * k * T) - 1);\r\n      Irp1 = V1 / Rp1;\r\n\r\n      Ia = Id1 + Irp1;\r\n\r\n      V2 = V - V1 - Rs * Ia;\r\n\r\n      Id2 = Is2 * Math.exp(q * V2 / (n2 * k * T) - 1);\r\n      Irp2 = V2 / Rp2;\r\n      Ib = Id2 + Irp2;\r\n\r\n      var diffI = Ib - Ia;\r\n\r\n      if (diffI > 0) {\r\n        L = V1;\r\n      } else {\r\n        H = V1;\r\n      }\r\n      i++;\r\n\r\n    } while (Math.abs(diffI) > mchEps && i < 500);\r\n    return [Ia, Id1, Id2, Irp1, Irp2];\r\n  }\r\n\r\n  function getParam$(paramClass) {\r\n    return $('input[type=number]')\r\n      .filter('.' + paramClass);\r\n  }\r\n\r\n  function getParamValue(paramClass) {\r\n    return parseFloat(\r\n      getParam$(paramClass)\r\n        .val()\r\n    );\r\n  }\r\n\r\n  function getParamChecked(paramClass) {\r\n    return $('input[type=checkbox]')\r\n      .filter('.' + paramClass)\r\n      .is(':checked');\r\n  }\r\n\r\n  function getAllParams() {\r\n    let params = {\r\n      value: {\r\n        iph: undefined,\r\n        t: undefined,\r\n        n1: undefined,\r\n        n2: undefined,\r\n        is1: undefined,\r\n        is2: undefined,\r\n        rp1: undefined,\r\n        rp2: undefined,\r\n        rs: undefined\r\n      },\r\n      checked: {\r\n        iph: undefined,\r\n        t: undefined,\r\n        n1: undefined,\r\n        n2: undefined,\r\n        is1: undefined,\r\n        is2: undefined,\r\n        rp1: undefined,\r\n        rp2: undefined,\r\n        rs: undefined\r\n      }\r\n    };\r\n\r\n    for (let paramClass in params.value) {\r\n      params.value[paramClass] = getParamValue(paramClass);\r\n      params.checked[paramClass] = getParamChecked(paramClass);\r\n    }\r\n    return params;\r\n  }\r\n\r\n  function setParamValue(paramClass, value) {\r\n    getParam$(paramClass)\r\n      .val(value);\r\n  }\r\n\r\n  function getModel() {\r\n    const isSingleDiodeChecked = document.getElementById('singleDiode').checked,\r\n      isParallelChecked = document.getElementById('parallel').checked;\r\n    return {\r\n      diodeCount: (isSingleDiodeChecked) ? 1 : 2,\r\n      circuit: (isParallelChecked) ? 'parallel' : 'series'\r\n    };\r\n  }\r\n\r\n  function calcIV(params, model) {\r\n    // Calculates current for a range of voltage values\r\n\r\n    const minVolt = params.minVolt.value,\r\n      maxVolt = params.maxVolt.value,\r\n      stepVolt = params.stepVolt.value,\r\n      Iph = params.iph.value,\r\n      T = params.t.value,\r\n      n1 = params.n1.value,\r\n      Is1 = params.is1.value;\r\n\r\n    let n2 = params.n2.value,\r\n      Is2 = params.is2.value,\r\n      Rp2 = params.rp2.value;\r\n\r\n    if (model.diodeCount === 1) {\r\n      n2 = 1;\r\n      Is2 = 0;\r\n      Rp2;\r\n    }\r\n\r\n    var Rp = params.rp1.value,\r\n      Rs = params.rs.value;\r\n\r\n    let Ipar, Iser, I, Id1, Id2,\r\n      arrayVI = [],\r\n      arrayVId1 = [],\r\n      arrayVId2 = [],\r\n      arrayVIrp1 = [],\r\n      arrayVIrp2 = [],\r\n      parallel, modelCase;\r\n\r\n    if (model.circuit === 'parallel') {\r\n      parallel = true,\r\n        modelCase = 'parallel';\r\n    }\r\n\r\n    if (model.diodeCount === 1) {\r\n      parallel = true,\r\n        modelCase = 'single';\r\n    }\r\n    if (model.circuit === 'series') {\r\n      modelCase = 'series';\r\n    }\r\n\r\n    for (var V = minVolt; V <= maxVolt; V += stepVolt / 1000) {\r\n      if (parallel) {\r\n        Ipar = Iparallel(V, Iph, I, T, n1, n2, Is1, Is2, Rp, Rs);\r\n        I = - Ipar[0];\r\n        Id1 = Ipar[1];\r\n        Id2 = Ipar[2];\r\n        var Irp = Ipar[3];\r\n        arrayVIrp1.push([V, Irp]);\r\n        // Calculated current is used as the initial current for next voltage,\r\n        // speeds up equation solving, is important for high direct bias\r\n      } else {\r\n        Iser = Iseries(V, T, Iph, n1, n2, Is1, Is2, Rp, Rp2, Rs);\r\n        I = Iser[0];\r\n        Id1 = Iser[1];\r\n        Id2 = Iser[2];\r\n        var Irp1 = Iser[3],\r\n          Irp2 = Iser[4];\r\n        arrayVIrp1.push([V, Irp1]);\r\n        arrayVIrp2.push([V, Irp2]);\r\n      }\r\n\r\n      arrayVI.push([V, I]);\r\n      arrayVId1.push([V, Id1]);\r\n      arrayVId2.push([V, Id2]);\r\n    }\r\n\r\n    const modelCases = {\r\n      parallel: {\r\n        arrayCalc: [arrayVI, arrayVId1, arrayVId2, arrayVIrp1],\r\n        plotStyle: [\r\n          ['line', 'black', 'I'],\r\n          ['line', 'orange', 'Id1'],\r\n          ['line', 'orange', 'Id2'],\r\n          ['line', 'purple', 'Irp']\r\n        ]\r\n      },\r\n      single: {\r\n        arrayCalc: [arrayVI, arrayVId1, arrayVIrp1],\r\n        plotStyle: [\r\n          ['line', 'black', 'I'],\r\n          ['line', 'orange', 'Id1'],\r\n          ['line', 'purple', 'Irp']\r\n        ]\r\n      },\r\n      series: {\r\n        arrayCalc: [arrayVI, arrayVId1, arrayVId2, arrayVIrp1, arrayVIrp1],\r\n        plotStyle: [\r\n          ['line', 'black', 'I'],\r\n          ['line', 'orange', 'Id1'],\r\n          ['line', 'orange', 'Id2'],\r\n          ['line', 'purple', 'Irp1'],\r\n          ['line', 'purple', 'Irp2']\r\n        ]\r\n      }\r\n    };\r\n\r\n    return modelCases[modelCase];\r\n  }\r\n\r\n  function scaleType() {\r\n    // Returns the type of scale for y axis\r\n    const scaleIsLinear = document.getElementById('linear').checked;\r\n    return (scaleIsLinear) ? 'linearScale' : 'logScale';\r\n  }\r\n\r\n  function processFiles(file) {\r\n    // Fired when file input changed\r\n\r\n    let reader = new FileReader();\r\n\r\n    reader.onload = readerOnLoad;\r\n    reader.filename = file.name;\r\n\r\n    reader.readAsText(file);\r\n  }\r\n\r\n  function readerOnLoad(event) {\r\n    // Fired when data is ready\r\n\r\n    // Guess T from file name\r\n    let fileName = this.filename;\r\n\r\n    while (isNaN(parseFloat(fileName)) && fileName.length > 0) {\r\n      fileName = fileName.substring(1);\r\n    }\r\n\r\n    fileName = parseFloat(fileName);\r\n\r\n    const defaultT = (isNaN(fileName)) ? 298 : fileName,\r\n      T = prompt('Temperature? (K)', defaultT);\r\n\r\n    if (isFinite(T) && T > 0) {\r\n      setParamValue('t', T);\r\n      // document.getElementById('sliderT').value = T;\r\n      userData.dataArray = [];\r\n      userData.modifDataArray = [];\r\n\r\n      stringToArray(event.target.result);\r\n    }\r\n  }\r\n\r\n  function clearData() {\r\n    // Fired when user clicks on the Clear button\r\n\r\n    userData.dataArray = [];\r\n    userData.modifDataArray = [];\r\n    fileOpened = false;\r\n    combDataAndCalc();\r\n\r\n    $('.panel')\r\n      .addClass('nofile');\r\n\r\n    $('.fa-toggle-on')\r\n      .toggleClass('fa-toggle-on fa-toggle-off');\r\n\r\n    if (window.localFile /* FF is picky about that: not importing the file through classic 'browse' button result in an error here */) {\r\n      window.localFile.reset();\r\n    }\r\n\r\n    clearFileInput();\r\n\r\n    $('.estimation')\r\n      .add('.final')\r\n      .add('#s')\r\n      .add('#ds')\r\n      .empty();\r\n\r\n    if ($('#start').hasClass('pause')) {\r\n      togglePlayButton();\r\n    }\r\n\r\n    userData.estimatedParameters.Rp = undefined;\r\n\r\n    disableCheckboxes();\r\n  }\r\n\r\n  function clearFileInput() {\r\n    $('input[type=file]')\r\n      .val(null)\r\n      .closest('div')\r\n      .children('input[type=text]')\r\n      .val('');\r\n  }\r\n\r\n  function stringToArray(data) {\r\n    // Convert the dataset from a string\r\n    // to an array of arrays of numbers\r\n\r\n    let array = data.split('\\n'),\r\n      skipRow,\r\n      dataArray = [];\r\n\r\n    for (let stringRow of array) {\r\n      skipRow = false;\r\n      const row = stringRow.split('\\t');\r\n\r\n      // Make sure each of the first two\r\n      // elements in the row is a number\r\n      for (let j = 0; j < 2; j++) {\r\n        row[j] = Number(row[j]);\r\n        skipRow += isNaN(row[j]);\r\n      }\r\n\r\n      if (!skipRow) {\r\n        dataArray.push(row);\r\n      }\r\n    }\r\n\r\n    // Removes the semi-transparent\r\n    // overlay div\r\n    $('.panel')\r\n      .removeClass('nofile');\r\n\r\n    fileOpened = true;\r\n\r\n    // Enable checkboxes for the already\r\n    // enabled parameter inputs\r\n    $('[type=range]:enabled')\r\n      .each(enableCheckboxInput);\r\n\r\n    document.getElementById('minVolt').value = dataArray[0][0];\r\n    document.getElementById('maxVolt').value = dataArray[dataArray.length - 1][0] + document.getElementById('stepVolt').value / 1000;\r\n\r\n    dataArray = [dataArray];\r\n\r\n    userData.dataArray = dataArray;\r\n    userData.modifDataArray = dataArray;\r\n\r\n    const ivResult = calcIV(parameters, getModel());\r\n\r\n    /**** Estimate parameters ****/\r\n\r\n    // Parallel resistance Rp\r\n    const Rp = estimRp(dataArray);\r\n    userData.estimatedParameters.Rp = Rp;\r\n\r\n    // Calculate Parallel current and non linear reverse current\r\n    const current = calcIrpAndNonLinRevCurr(dataArray, Rp);\r\n    userData.current.nonLinear = current.nonLinear;\r\n    userData.current.shunt = current.shunt;\r\n\r\n    findAndEstimateDiodes();\r\n\r\n    calcSqResSum(parameters, dataArray, arrayCalc);\r\n\r\n    combDataAndCalc(ivResult);\r\n  }\r\n\r\n  function enableCheckboxInput(index, element) {\r\n    getRowDiv($(element))\r\n      .find('[type=checkbox]')\r\n      .prop('disabled', false);\r\n  }\r\n\r\n  function IprShowed() {\r\n    return $('#hideIrp').hasClass('fa-toggle-off');\r\n  }\r\n\r\n  function nonLinearCurrentShowed() {\r\n    return $('#hideNonLinCurr').hasClass('fa-toggle-off');\r\n  }\r\n\r\n  function combDataAndCalc() {\r\n    // Combine uploaded data and calculated IV into one graph\r\n    const canvasID = 'graph',\r\n      data = userData.modifDataArray.concat(arrayCalc),\r\n      primaryPlotIndex = 0,\r\n      xTitle = 'V (V)',\r\n      yTitle = 'I (A)';\r\n    let style;\r\n\r\n    if (fileOpened) {\r\n      const dataStyle = [['verticalCross', 'purple', 'Data']];\r\n      style = dataStyle.concat(plotStyle);\r\n    } else {\r\n      style = plotStyle;\r\n    }\r\n\r\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_bobGraph__[\"a\" /* default */])(canvasID, data, primaryPlotIndex, style, scaleType(), xTitle, yTitle);\r\n  }\r\n\r\n  function tableSuccessContext(add) {\r\n    // Add or remove \"success\" color on\r\n    // parameter's table's 3rd column\r\n\r\n    const $td = $('td.final');\r\n\r\n    if (add) {\r\n      $td.addClass('success');\r\n    } else {\r\n      $td.removeClass('success');\r\n    }\r\n  }\r\n\r\n  /*\r\n   *  Fit \r\n   */\r\n\r\n\r\n  let interval;\r\n\r\n  function estimRp(dataArray) {\r\n    // Estimate parallel resistance Rp\r\n    let min = +Infinity,\r\n      array = dataArray[0];\r\n\r\n    for (let xy of array) {\r\n      let x = xy[0],\r\n        slope = xy[1] / x;\r\n      if (slope < min && Math.abs(x) > 0.001) {\r\n        min = slope;\r\n      }\r\n    }\r\n\r\n    let Rp = 1 / min;\r\n    // var oOM = orderOfMagn(Rp);\r\n    //var roundedRp = Math.round(Rp * 1000 / oOM) * oOM / 1000;\r\n\r\n    return Rp;\r\n  }\r\n\r\n  function calcIrpAndNonLinRevCurr(dataArray, Rp) {\r\n    let array = dataArray[0],\r\n      nonLinDirCurr = [],\r\n      shuntCurrent = [],\r\n      nonLinCurr = [];\r\n\r\n    for (let VI of array) {\r\n      let V = VI[0],\r\n        Irp = V / Rp;\r\n      shuntCurrent.push([V, Irp]);\r\n\r\n      if (V < -0.0001) {\r\n        // Only looking at reverse polarization:\r\n        // Non-linear reverse current is total current minus parallel current (which is linear)\r\n        let Inl = VI[1] - Irp; // Inl -> 'nl' = 'Non-Linear'\r\n\r\n        // Deduce direct non linear current\r\n        nonLinDirCurr.unshift([-V, -Inl]);\r\n\r\n        // Reverse\r\n        nonLinCurr.push([V, Inl]);\r\n      }\r\n    }\r\n\r\n    // Combine reverse and direct\r\n    nonLinCurr = nonLinCurr.concat([[0, 0]], nonLinDirCurr);\r\n\r\n    return {\r\n      shunt: shuntCurrent,\r\n      nonLinear: nonLinCurr\r\n    };\r\n  }\r\n\r\n  function toggleIrp(modifDataArray, shuntCurrent, show) {\r\n    // Show or hide Irp on graph\r\n\r\n    let array = modifDataArray[0],\r\n      newArray = [],\r\n      i = 0,\r\n      sign = (show) ? 1 : -1;\r\n\r\n    for (let IV of array) {\r\n      newArray.push([IV[0], IV[1] + sign * shuntCurrent[i][1]]);\r\n      i++;\r\n    }\r\n\r\n    modifDataArray = [newArray];\r\n\r\n    return modifDataArray;\r\n  }\r\n\r\n  function toggleNonLinCurr(userData, modifDataArray, show) {\r\n\r\n    const nonLinearCurrent = userData.current.nonLinear;\r\n\r\n    let array1 = userData.dataArray[0],\r\n      array2 = userData.modifDataArray[0],\r\n      IV2,\r\n      newArray1 = [],\r\n      newArray2 = [],\r\n      sign = (show) ? 1 : -1,\r\n      i = 0;\r\n\r\n    for (let IV1 of array1) {\r\n      newArray1.push([IV1[0], IV1[1] + sign * nonLinearCurrent[i][1]]);\r\n      IV2 = array2[i];\r\n      newArray2.push([IV2[0], IV2[1] + sign * nonLinearCurrent[i][1]]);\r\n      i++;\r\n    }\r\n\r\n    return {\r\n      dataArray: [newArray1],\r\n      modifDataArray: [newArray2]\r\n    };\r\n  }\r\n\r\n  let SqResSum,\r\n    delS = [];\r\n\r\n  function calcSqResSum(params, dataArray, arrayCalc) {\r\n    // Calculates the sum of squared residuals\r\n\r\n    let n1 = params.n1.value,\r\n      Is1 = params.is1.value,\r\n      Rp = params.rp1.value,\r\n      Rs = params.rs.value,\r\n      T = params.t.value,\r\n      single = document.getElementById('singleDiode').checked,\r\n      n2, Is2;\r\n\r\n    SqResSum = 0;\r\n\r\n    if (single) {\r\n      // Single diode model\r\n      Is2 = 0;\r\n      n2 = 1;\r\n    } else {\r\n      // Dual diode model\r\n      Is2 = params.is2.value;\r\n      n2 = params.n2.value;\r\n    }\r\n\r\n    if (document.getElementById('series').checked) {\r\n      // Dual, series diode model\r\n      n1 = params.n1.value;\r\n    }\r\n\r\n    let r, calcI, j = 1, x1, x2, xy1, xy2, y1, y2, slope, x,\r\n      calcIV = arrayCalc[0],\r\n      array = dataArray[0],\r\n      data,\r\n      dSdn1 = 0,\r\n      dSdn2 = 0,\r\n      dSdIs1 = 0,\r\n      dSdIs2 = 0,\r\n      dSdRp = 0,\r\n      dSdRs = 0;\r\n\r\n    let dIdn1, dIdn2, dIdIs1, dIdIs2, dIdRp, dIdRs, exp1, exp2;\r\n\r\n    for (let row of array) {\r\n      // For each data point\r\n      x = row[0];\r\n\r\n      while (x > calcIV[j][0]) { j++; }\r\n      xy1 = calcIV[j - 1];\r\n      xy2 = calcIV[j];\r\n      x1 = xy1[0];\r\n      x2 = xy2[0];\r\n      y1 = xy1[1];\r\n      y2 = xy2[1];\r\n      data = row[1];\r\n\r\n      // Linear interpolation\r\n      slope = (y2 - y1) / (x2 - x1);\r\n      calcI = y1 + slope * (x - x1);\r\n\r\n      r = (calcI - data) / Math.abs(data);\r\n\r\n      if (isFinite(r)) {\r\n        exp1 = Math.exp(q * (x - Rs * calcI) / (n1 * k * T));\r\n        exp2 = Math.exp(q * (x - Rs * calcI) / (n2 * k * T));\r\n\r\n        dIdn1 = q * (Rs * calcI - x) / (Math.pow(n1, 2) * k * T * (1 + Rs / Rp + q * Is2 * Rs * exp2 / (n2 * k * T)) / (Is1 * exp1) + n1 * Rs * q);\r\n        dSdn1 += 2 * r * dIdn1 / Math.abs(data);\r\n\r\n        dIdn2 = q * (Rs * calcI - x) / (Math.pow(n2, 2) * k * T * (1 + Rs / Rp + q * Is1 * Rs * exp1 / (n1 * k * T)) / (Is2 * exp2) + n2 * Rs * q);\r\n        dSdn2 += 2 * r * dIdn2 / Math.abs(data);\r\n\r\n        dIdIs1 = (exp1 - 1) / (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + q * Is2 * Rs * exp2 / (n2 * k * T) + Rs / Rp);\r\n        //dIdIs1 = (exp1 - 1) / (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + Rs / Rp);\r\n        dSdIs1 += 2 * r * dIdIs1 / Math.abs(data);\r\n\r\n        dIdIs2 = (exp2 - 1) / (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + q * Is2 * Rs * exp2 / (n2 * k * T) + Rs / Rp);\r\n        dSdIs2 += 2 * r * dIdIs2 / Math.abs(data);\r\n\r\n        dIdRp = (calcI * Rs - x) / (Math.pow(Rp, 2) * (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + q * Is2 * Rs * exp2 / (n2 * k * T) + Rs / Rp));\r\n        dSdRp += 2 * r * dIdRp / Math.abs(data);\r\n\r\n        dIdRs = - calcI * (q * Is1 * exp1 / (n1 * k * T) + q * Is2 * exp2 / (n2 * k * T) + 1 / Rp) / (1 + Rs * (q * Is1 * exp1 / (n1 * k * T) + q * Is2 * exp2 / (n2 * k * T) + 1 / Rp));\r\n        //dIdRs = - calcI * (q * Is1 * exp1 / (n1 * k * T) + 1 / Rp) / (1 + Rs * (q * Is1 * exp1 / (n1 * k * T) + 1 / Rp));\r\n        dSdRs += 2 * r * dIdRs / Math.abs(data);\r\n\r\n        SqResSum += Math.pow(r, 2);\r\n      }\r\n      delS = [dSdn1, dSdIs1, dSdRp, dSdRs];\r\n      if (!single) {\r\n        delS.splice(1, 0, dSdn2);\r\n        delS.splice(3, 0, dSdIs2);\r\n      }\r\n    }\r\n\r\n    // Display residue\r\n    $('#s').text(SqResSum.toExponential(2));\r\n\r\n    return SqResSum;\r\n  }\r\n\r\n  function deriv(array) {\r\n    var der, prev, next, derArray = [], stringArray = 'V\\tln(I)\\td[ln(I)]/dV';\r\n    for (var i = 1; i < array.length - 1; i++) {//Derivative not calculated for 1st and last point\r\n      prev = array[i - 1];\r\n      next = array[i + 1];\r\n      der = (next[1] - prev[1]) / (next[0] - prev[0]);\r\n      derArray.push([array[i][0], der]);\r\n      stringArray = stringArray.concat('\\n' + array[i][0] + '\\t' + array[i][1] + '\\t' + der);\r\n    }\r\n    return derArray;\r\n  }\r\n\r\n  function lnOfArray(array) {\r\n    var xy, y, newArray = [];\r\n    for (var i = 0; i < array.length; i++) {\r\n      xy = array[i];\r\n      y = xy[1];\r\n      if (y != 0) {\r\n        newArray.push([xy[0], Math.log(Math.abs(y))]);\r\n      }\r\n    }\r\n\r\n    return newArray;\r\n  }\r\n\r\n  function findDiodes(userData, IprShowed, nonLinearCurrentShowed) {\r\n    let modifDataArray = userData.modifDataArray,\r\n      shuntCurrent = userData.current.shunt;\r\n\r\n    if (IprShowed) {\r\n      modifDataArray = toggleIrp(modifDataArray, shuntCurrent, false);\r\n    } // diode parameters better evaluated when Rp = infinity\r\n\r\n    if (nonLinearCurrentShowed) {\r\n      let result = toggleNonLinCurr(userData, modifDataArray, false);\r\n      modifDataArray = result.modifDataArray;\r\n    }\r\n\r\n    let noIrpNoSCLCarray = modifDataArray[0],\r\n      array = modifDataArray[0];\r\n\r\n    // 1st order derivative\r\n    let array1 = deriv(lnOfArray(array));\r\n\r\n    // 2nd order derivative\r\n    array = deriv(array1);\r\n\r\n    let i = array.length - 2,\r\n      prev,\r\n      dLn = array[i][1],\r\n      dLnMin = 0,\r\n      deltaLnMax = 0,\r\n      j = 0;\r\n\r\n    let avDelta = function (array) {\r\n      var sum = 0,\r\n        length = array.length;\r\n      for (var i = 1; i < length; i++) {\r\n        sum += Math.abs(array[i][1] - array[i - 1][1]);\r\n      }\r\n      return sum / (length - 1);\r\n    };\r\n\r\n    const avD = avDelta(array);\r\n\r\n    var iMin = i,\r\n      fluctIn2ndHalf = false;\r\n    do {\r\n      i = iMin;\r\n      dLn = array[i][1];\r\n      var maxPassed = false;\r\n      do {\r\n        // Looking for minima between 0.04 V and Vmax\r\n        i--;\r\n        prev = dLn;\r\n        dLn = array[i][1];\r\n\r\n        fluctIn2ndHalf += Math.abs(dLn - prev) > avD && i < array.length / 2;\r\n        maxPassed += prev > dLn && Math.abs(dLn - prev) < avD;\r\n        var carryOn = !maxPassed || dLn < prev;\r\n      } while (i >= 0 && array[i][0] > 0.04 && carryOn && !fluctIn2ndHalf);\r\n\r\n      iMin = i + 1;\r\n      dLnMin = prev;\r\n\r\n      let dLnMax = dLnMin;\r\n\r\n      prev = -Infinity;\r\n      i = iMin - 1;\r\n      var iMax = iMin;\r\n\r\n      while (i >= 0 && array[i][0] > 0.04) {\r\n        // Looking for a maxima between 0.04 V and Vmax\r\n        dLn = array[i][1];\r\n\r\n        if (dLn < prev && prev > dLnMax && Math.abs(dLn - prev) < avD) {\r\n          iMax = i;\r\n          dLnMax = prev;\r\n        }\r\n        prev = dLn;\r\n        i--;\r\n      }\r\n\r\n      if (dLnMax - dLnMin > deltaLnMax) {\r\n        deltaLnMax = dLnMax - dLnMin;\r\n        var iMaxMax = iMax;\r\n      }\r\n      j++;\r\n    } while (iMax != iMin && j < 10 && !fluctIn2ndHalf);\r\n\r\n    if (!iMaxMax) {\r\n      return 'noDiode';\r\n    }\r\n\r\n    i = iMax = iMaxMax;\r\n    dLn = array[i][1];\r\n    do {\r\n      prev = dLn;\r\n      i--;\r\n      dLn = array[i][1];\r\n    } while (Math.abs(dLn) < Math.abs(prev) || dLn >= 0);\r\n\r\n    let iD1 = i + 2,\r\n      D1dLn = array1[iD1 + 1][1];\r\n\r\n    i = iMax;\r\n\r\n    do {\r\n      prev = dLn;\r\n      i++;\r\n      dLn = array[i][1];\r\n    } while (Math.abs(dLn) < Math.abs(prev) || dLn >= 0);\r\n\r\n    let iD2 = i - 1,\r\n      D2dLn = array1[iD2 + 1][1];\r\n\r\n    const length = array.length - 2;\r\n\r\n    iD2 = length - iD2;\r\n    iD1 = length - iD1;\r\n\r\n    /* iD2 (and iD1) are the indexes of the maxima (and minima), starting from the *end* of the original array,\r\n    in case points in reverse are missing after removal of Irp and SCLC */\r\n\r\n    return {\r\n      noIrpNoSCLCarray: noIrpNoSCLCarray,\r\n      diodes: [D2dLn, D1dLn, iD2, iD1]\r\n    };\r\n  }\r\n\r\n  function estimD1D2Rs(params, userData, findDiodesResult) {\r\n    if (document.getElementById('series').checked) {\r\n      // For now, no estimation for series model\r\n      return;\r\n    }\r\n\r\n    const paramValues = params.value,\r\n      paramChecked = params.checked;\r\n\r\n    let maxmin = findDiodesResult.diodes;\r\n\r\n    if (maxmin === 'noDiode') {\r\n      // TODO: Display message\r\n      return;\r\n    }\r\n\r\n    let dualDiode = !document.getElementById('singleDiode').checked,\r\n      array = findDiodesResult.noIrpNoSCLCarray,\r\n\r\n      D1dLn = maxmin[1],\r\n      D2dLn = maxmin[0],\r\n      VIAtd1 = array[array.length - 4 - maxmin[3]],\r\n      VIAtd2 = array[array.length - 4 - maxmin[2]],\r\n      T = paramValues.t,\r\n      A = q / (k * T),\r\n      n2 = A / D2dLn,\r\n      n, n1, Is1, Rs, Is2;\r\n\r\n    if (dualDiode) {\r\n      if (paramChecked.n2) {\r\n        n = n2;\r\n      } else {\r\n        n = n2 = paramValues.n2;\r\n      }\r\n      if (paramChecked.n1) {\r\n        n1 = A / D1dLn;\r\n      } else {\r\n        n1 = paramValues.n1;\r\n      }\r\n      if (paramChecked.is1) {\r\n        Is1 = VIAtd1[1] / (Math.exp((VIAtd1[0] * A / n1) - 1));\r\n      } else {\r\n        Is1 = paramValues.is1;\r\n      }\r\n    } else {\r\n      // Single diode\r\n      n = n2;\r\n    }\r\n\r\n    if (paramChecked.rs) {\r\n      Rs = estimRs(array, T, n);\r\n    } else {\r\n      Rs = paramValues.rs;\r\n    }\r\n\r\n    if (paramChecked.is2) {\r\n      Is2 = VIAtd2[1] / (Math.exp((VIAtd2[0] - VIAtd2[1] * Rs) * A / n2) - 1);\r\n    } else {\r\n      Is2 = paramValues.is2;\r\n    }\r\n\r\n    let newRp;\r\n\r\n    if (paramChecked.rp1) {\r\n      newRp = userData.estimatedParameters.Rp;\r\n    } else {\r\n      newRp = paramValues.rp1;\r\n    }\r\n\r\n    $('td.estimation#rp1').text(newRp.toPrecision(3));\r\n    $('td.estimation#rs').text(Rs.toPrecision(2));\r\n\r\n    if (dualDiode) {\r\n      return {\r\n        n1: n1,\r\n        n2: n2,\r\n        Is1: Is1,\r\n        Is2: Is2,\r\n        Rp1: newRp,\r\n        Rs: Rs\r\n      };\r\n    } else {\r\n      return {\r\n        n1: n2,\r\n        Is1: Is2,\r\n        Rp1: newRp,\r\n        Rs: Rs\r\n      };\r\n    }\r\n  }\r\n\r\n  function estimRs(array, T, n) {\r\n    var dIdV = deriv(array),\r\n      i = array.length - 2,\r\n      dIdVati = dIdV[i - 1][1],\r\n      exp,\r\n      A = q / (n * k * T),\r\n      B, C,\r\n      IVati = array[i],\r\n      I = IVati[1],\r\n      V = IVati[0],\r\n      Rs = 0;\r\n\r\n    do {\r\n      exp = Math.exp(A * (V - I * Rs));\r\n      B = A * exp / (exp - 1);\r\n      C = B / (1 / I + Rs * B);\r\n      Rs += 0.01;\r\n    } while (C > dIdVati);\r\n\r\n    return Rs;\r\n  }\r\n\r\n  function updateParams(params, plot, updateRangeInput) {\r\n    // Update number input and result table\r\n\r\n    if (updateRangeInput) {\r\n      var evt = document.createEvent('HTMLEvents');\r\n      evt.initEvent('change', false, false);\r\n    }\r\n\r\n    for (let param of params) {\r\n      const id = param[0],\r\n        value = param[1];\r\n\r\n      let element = $('[type=number].' + id).get(0);\r\n\r\n      if (updateRangeInput) {\r\n        element.dispatchEvent(evt);\r\n      }\r\n\r\n      const $td = $('td#final-' + id),\r\n        isScaleLog = $(element).hasClass('logscale'),\r\n        formattedValue = (isScaleLog) ? value.toExponential(2) : value.toPrecision(2);\r\n\r\n      element.value = value;\r\n      $td\r\n        .text(formattedValue);\r\n\r\n      parameters.update($(element));\r\n    }\r\n\r\n    const ivResult = calcIV(parameters, getModel());\r\n\r\n    arrayCalc = ivResult.arrayCalc;\r\n    plotStyle = ivResult.plotStyle;\r\n\r\n    calcSqResSum(parameters, userData.dataArray, arrayCalc);\r\n  }\r\n\r\n  function vary() {\r\n    // Varies checked diode parameters until\r\n    // sum of square residuals is minimized\r\n\r\n    const eps = mchEps;\r\n\r\n    var n1 = parameters.n1.value,\r\n      n1vary = parameters.n1.checked,\r\n      Is1 = parameters.is1.value,\r\n      Is1vary = parameters.is1.checked,\r\n      Rp = parameters.rp1.value,\r\n      Rpvary = parameters.rp1.checked,\r\n      Rs = parameters.rs.value,\r\n      Rsvary = parameters.rs.checked;\r\n\r\n    // Single diode model\r\n    let params = [\r\n      ['n1', n1, eps, n1vary],\r\n      ['is1', Is1, eps, Is1vary],\r\n      ['rp1', Rp, eps, Rpvary],\r\n      ['rs', Rs, eps, Rsvary]\r\n    ];\r\n\r\n    if (document.getElementById('doubleDiode').checked) {\r\n      // Dual diode model\r\n      var Is2 = parameters.is2.value,\r\n        Is2vary = parameters.is2.checked,\r\n        n2 = parameters.n2.value,\r\n        n2vary = parameters.n2.checked;\r\n      params = [['n1', n1, eps, n1vary], ['n2', n2, eps, n2vary], ['is1', Is1, eps, Is1vary], ['is2', Is2, eps, Is2vary], ['rp1', Rp, eps, Rpvary], ['rs', Rs, eps, Rsvary]];\r\n    }\r\n\r\n    var del,\r\n      S,\r\n      newPar,\r\n      j = 0,\r\n      ii = 0,\r\n      sign,\r\n      stop = false;\r\n\r\n    interval = setInterval(\r\n      function () {\r\n        S = SqResSum;\r\n        var newPars = [];\r\n        //del = delS;\r\n        for (var i = 0; i < params.length; i++) {\r\n          if (params[i][3]) {\r\n            // This parameter is allowed to vary\r\n            del = delS[i];\r\n            sign = del / Math.abs(del);\r\n\r\n            newPar = params[i][1] * Math.pow((1 + params[i][2]), -sign); //update parameter\r\n\r\n            updateParams([[params[i][0], newPar]], false, false);\r\n\r\n            j = 0;\r\n            while (del / Math.abs(del) != delS[i] / Math.abs(delS[i]) && j < 100 && newPar !== 0) {\r\n              params[i][2] /= 2;\r\n              newPar = params[i][1] * Math.pow((1 + params[i][2]), -sign); //update parameter\r\n              updateParams([[params[i][0], newPar]], false, false);\r\n              j++;\r\n            }\r\n\r\n            var jj = 0;\r\n            while (del / Math.abs(del) == delS[i] / Math.abs(delS[i]) && jj < 100 && newPar !== 0) {\r\n              params[i][2] *= 2;\r\n              newPar = params[i][1] * Math.pow((1 + params[i][2]), -sign); //update parameter\r\n              updateParams([[params[i][0], newPar]], false, false);\r\n\r\n              jj++;\r\n            }\r\n            params[i][1] = newPar;\r\n            newPars.push(newPar);\r\n\r\n            if (isNaN(newPar)) {\r\n              stop += true;\r\n            }\r\n          }\r\n        }\r\n\r\n        ii++;\r\n\r\n        const dS = SqResSum - S;\r\n\r\n        if (typeof S === 'number') {\r\n          $('#ds').text(dS.toExponential(2));\r\n        } else {\r\n          $('#ds').empty();\r\n        }\r\n\r\n        const threshold = document.getElementById('threshold').value,\r\n          fitSuccessful = Math.abs(dS) < threshold;\r\n\r\n        if (fitSuccessful || ii > 1000 || stop) {\r\n          if (fitSuccessful) {\r\n            const addContext = true;\r\n            tableSuccessContext(addContext);\r\n          }\r\n          togglePlayButton();\r\n          const start = false;\r\n          startPauseVary(start);\r\n\r\n          // Sync number and range inputs\r\n          syncAllInputs();\r\n        }\r\n        if (document.webkitHidden) {\r\n          // No use to plot: the page is not visible (Webkit only)\r\n        } else {\r\n          combDataAndCalc(/*arrayCalc, plotStyle, scale*/);\r\n        }\r\n      }\r\n      , 1);\r\n  }\r\n\r\n  function startPauseVary(start) {\r\n    // start parameter is a boolean\r\n\r\n    if (start === true) {\r\n      const addContext = false;\r\n      tableSuccessContext(addContext);\r\n      vary();\r\n    } else {\r\n      clearInterval(interval);\r\n    }\r\n  }\r\n\r\n  return {};\r\n})();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz85NTUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkcmF3R3JhcGggZnJvbSAnYm9iR3JhcGgnO1xyXG5cclxucmVxdWlyZSgnaW5kZXguaHRtbCcpO1xyXG5yZXF1aXJlKCdpbmRleC5jc3MnKTtcclxucmVxdWlyZSgnYXNzZXRzL3NhbXBsZWZpbGVzL1QyNzlLLnR4dCcpO1xyXG5cclxuLy8gSW1tZWRpYXRlbHkgSW52b2tlZCBGdW5jdGlvbiBFeHByZXNzaW9uXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBjb25zdCBtY2hFcHMgPSBtYWNoaW5lRXBzaWxvbigpO1xyXG5cclxuICAvLyBFbGVtZW50YXJ5IGNoYXJnZSBhbmQgQm9sdHptYW5uIGNvbnN0YW50XHJcbiAgY29uc3QgcSA9IDEuNjAyMTc2NTNFLTE5LFxyXG4gICAgayA9IDEuMzgwNjQ4OEUtMjM7XHJcblxyXG4gIGxldCBhcnJheUNhbGMsXHJcbiAgICBmaWxlT3BlbmVkID0gZmFsc2UsXHJcbiAgICBwbG90U3R5bGUgPSBbXSxcclxuICAgIHVzZXJEYXRhID0ge1xyXG4gICAgICBlc3RpbWF0ZWRQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgUnA6IHVuZGVmaW5lZFxyXG4gICAgICB9LFxyXG4gICAgICBjdXJyZW50OiB7XHJcbiAgICAgICAgc2h1bnQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBub25MaW5lYXI6IHVuZGVmaW5lZCxcclxuICAgICAgICBub0lycE5vU0NMQ2FycmF5OiB1bmRlZmluZWRcclxuICAgICAgfSxcclxuICAgICAgZGF0YUFycmF5OiBbXSxcclxuICAgICAgbW9kaWZEYXRhQXJyYXk6IFtdXHJcbiAgICB9LFxyXG4gICAgcGFyYW1ldGVycyA9IHtcclxuICAgICAgbWluVm9sdDogdW5kZWZpbmVkLFxyXG4gICAgICBtYXhWb2x0OiB1bmRlZmluZWQsXHJcbiAgICAgIHN0ZXBWb2x0OiB1bmRlZmluZWQsXHJcbiAgICAgIGlwaDogdW5kZWZpbmVkLFxyXG4gICAgICB0OiB1bmRlZmluZWQsXHJcbiAgICAgIG4xOiB1bmRlZmluZWQsXHJcbiAgICAgIG4yOiB1bmRlZmluZWQsXHJcbiAgICAgIGlzMTogdW5kZWZpbmVkLFxyXG4gICAgICBpczI6IHVuZGVmaW5lZCxcclxuICAgICAgcnAxOiB1bmRlZmluZWQsXHJcbiAgICAgIHJwMjogdW5kZWZpbmVkLFxyXG4gICAgICByczogdW5kZWZpbmVkLFxyXG4gICAgICAvLyBNZXRob2RzOlxyXG4gICAgICBpbml0OiBpbml0UGFyYW1ldGVycyxcclxuICAgICAgdXBkYXRlOiB1cGRhdGVQYXJhbWV0ZXJcclxuICAgIH0sXHJcbiAgICBtb2RlbCA9IHt9O1xyXG5cclxuICBmdW5jdGlvbiBpbml0UGFyYW1ldGVycygpIHtcclxuICAgIC8vIFVzZWQgYXMgYSBtZXRob2QgYnkgcGFyYW1ldGVyIG9iamVjdFxyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykge1xyXG4gICAgICBjb25zdCBpc0RhdGFQcm9wZXJ0eSA9IHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPT0gJ2Z1bmN0aW9uJztcclxuICAgICAgaWYgKGlzRGF0YVByb3BlcnR5KSB7XHJcbiAgICAgICAgY29uc3QgJGlucHV0TnVtYmVyID0gJCgnW3R5cGU9bnVtYmVyXS4nICsgcHJvcGVydHkpLFxyXG4gICAgICAgICAgJGlucHV0Q2hlY2tCb3ggPSAkKCdbdHlwZT1jaGVja2JveF0uJyArIHByb3BlcnR5KTtcclxuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHtcclxuICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KCRpbnB1dE51bWJlci52YWwoKSksXHJcbiAgICAgICAgICBjaGVja2VkOiAkaW5wdXRDaGVja0JveC5pcygnOmNoZWNrZWQnKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVBhcmFtZXRlcigkZWxlbWVudCkge1xyXG4gICAgLy8gVXNlZCBhcyBhIG1ldGhvZCBieSBwYXJhbWV0ZXIgb2JqZWN0XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSB7XHJcbiAgICAgIGlmICgkZWxlbWVudC5oYXNDbGFzcyhwcm9wZXJ0eSkpIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBwYXJzZUZsb2F0KCRlbGVtZW50LnZhbCgpKSxcclxuICAgICAgICAgIGlucHV0SXNMb2dSYW5nZSA9ICRlbGVtZW50Lmhhc0NsYXNzKCdsb2dzY2FsZScpICYmICRlbGVtZW50LmF0dHIoJ3R5cGUnKSA9PT0gJ3JhbmdlJyxcclxuICAgICAgICAgIG5ld1ZhbHVlID0gKGlucHV0SXNMb2dSYW5nZSkgPyBNYXRoLnBvdygxMCwgZWxlbWVudFZhbHVlKSA6IGVsZW1lbnRWYWx1ZTtcclxuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHtcclxuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcclxuICAgICAgICAgIGNoZWNrZWQ6ICRlbGVtZW50LmlzKCc6Y2hlY2tlZCcpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWFjaGluZUVwc2lsb24oKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgTWFjaGluZSBFcHNpbG9uXHJcbiAgICBsZXQgdGVtcDEsIHRlbXAyO1xyXG4gICAgdGVtcDEgPSAxLjA7XHJcbiAgICBkbyB7XHJcbiAgICAgIHRlbXAxIC89IDI7XHJcbiAgICAgIHRlbXAyID0gMS4wICsgdGVtcDE7XHJcbiAgICB9IHdoaWxlICh0ZW1wMiA+IDEuMCk7XHJcbiAgICByZXR1cm4gdGVtcDE7XHJcbiAgfVxyXG5cclxuICAkKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFdoZW4gcGFnZSBpcyBsb2FkZWRcclxuXHJcbiAgICAkKCdpbnB1dFt0eXBlPXJhZGlvXS5kZWZhdWx0JylcclxuICAgICAgLmF0dHIoJ2NoZWNrZWQnLCB0cnVlKTtcclxuXHJcbiAgICBjbGVhckZpbGVJbnB1dCgpO1xyXG5cclxuICAgIHBhcmFtZXRlcnMuaW5pdCgpO1xyXG5cclxuICAgIG1vZGVsID0gZ2V0TW9kZWwoKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYSBmaXJzdCB0aW1lXHJcbiAgICAvLyBJViB1c2luZyB0aGUgaW5pdGlhbCBwYXJhbWV0ZXJzXHJcbiAgICBjYWxjSVZhbmRQbG90KCk7XHJcblxyXG4gICAgYmluZEV2ZW50cygpO1xyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xyXG4gICAgJCgnaW5wdXRbdHlwZT1yYW5nZV0uc3luY21lJylcclxuICAgICAgLm9uKCdpbnB1dCcsIGlucHV0RXZlbnQpXHJcbiAgICAgIC5tb3VzZXVwKHJhbmdlSW5wdXRNb3VzZVVwKTtcclxuXHJcbiAgICAkKCdpbnB1dFt0eXBlPW51bWJlcl0uc3luY21lJylcclxuICAgICAgLmNoYW5nZShpbnB1dEV2ZW50KVxyXG4gICAgICAua2V5ZG93bihudW1iZXJJbnB1dEtleURvd24pXHJcbiAgICAgIC5ibHVyKGNoYW5nZVN0ZXApO1xyXG5cclxuICAgICQoJ2lucHV0W3R5cGU9bnVtYmVyXS52b2x0YWdlJylcclxuICAgICAgLmNoYW5nZSh2b2x0YWdlSW5wdXRDaGFuZ2VkKTtcclxuXHJcbiAgICAkKCdpbnB1dFt0eXBlPXJhZGlvXS5tb2RlbCcpXHJcbiAgICAgIC5jaGFuZ2UobW9kZWxDaGFuZ2VkKTtcclxuXHJcbiAgICAkKCdpbnB1dFt0eXBlPXJhZGlvXS5zY2FsZScpXHJcbiAgICAgIC5jaGFuZ2UoY2hhbmdlU2NhbGVUeXBlKTtcclxuXHJcbiAgICAkKCc6ZmlsZScpXHJcbiAgICAgIC5jaGFuZ2UoZmlsZUlucHV0Q2hhbmdlZCk7XHJcblxyXG4gICAgJCgnLmZhLXRvZ2dsZS1vbiwgLmZhLXRvZ2dsZS1vZmYnKVxyXG4gICAgICAuY2xpY2soZmFUb2dnbGVDbGlja2VkKTtcclxuXHJcbiAgICAkKCcjdXNlZXN0aW1hdGVkcGFyYW1zJylcclxuICAgICAgLmNsaWNrKHVzZUVzdGltYXRlZFBhcmFtcyk7XHJcblxyXG4gICAgJCgnYnV0dG9uI3N0YXJ0JylcclxuICAgICAgLmNsaWNrKHN0YXJ0QnV0dG9uQ2xpY2tlZCk7XHJcblxyXG4gICAgJCgnaW5wdXQjY2xlYXInKVxyXG4gICAgICAuY2xpY2soY2xlYXJEYXRhKTtcclxuXHJcbiAgICAkKCdbdHlwZT1jaGVja2JveF0nKVxyXG4gICAgICAuY2hhbmdlKHBhcmFtZXRlckNoZWNrQm94Q2hhbmdlZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGFuZ2VTY2FsZVR5cGUoKSB7XHJcbiAgICAvLyBFdmVudCBoYW5kbGVyXHJcbiAgICAvLyBmaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIGEgc2NhbGUgdHlwZSByYWRpbyBidXR0b25cclxuICAgIGNhbGNJVmFuZFBsb3QoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJhbmdlSW5wdXRNb3VzZVVwKCkge1xyXG4gICAgLy8gRXZlbnQgaGFuZGxlclxyXG4gICAgYWRqdXN0UmFuZ2UodGhpcyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBudW1iZXJJbnB1dEtleURvd24oZXZlbnQpIHtcclxuICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC53aGljaCxcclxuICAgICAgdXBPckRvd25BcnJvd0tleURvd24gPSBrZXlDb2RlID09IDM4IHx8IGtleUNvZGUgPT0gNDA7XHJcblxyXG4gICAgaWYgKHVwT3JEb3duQXJyb3dLZXlEb3duKSB7XHJcbiAgICAgIHN5bmNJbnB1dHModGhpcyk7XHJcbiAgICAgIGFkanVzdFJhbmdlKHRoaXMpO1xyXG4gICAgICBjYWxjSVZhbmRQbG90KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYWxjSVZhbmRQbG90KCkge1xyXG4gICAgY29uc3QgaXZSZXN1bHQgPSBjYWxjSVYocGFyYW1ldGVycywgZ2V0TW9kZWwoKSk7XHJcblxyXG4gICAgYXJyYXlDYWxjID0gaXZSZXN1bHQuYXJyYXlDYWxjO1xyXG4gICAgcGxvdFN0eWxlID0gaXZSZXN1bHQucGxvdFN0eWxlO1xyXG5cclxuICAgIC8vIGFuZCBwbG90IHRoZSByZXN1bHRcclxuICAgIGNvbWJEYXRhQW5kQ2FsYygpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmlsZUlucHV0Q2hhbmdlZCgpIHtcclxuICAgIC8vIEZpcmVkIHdoZW4gdXNlciBzZWxlY3RzIGEgbmV3IGZpbGVcclxuICAgIC8vIHRvIGltcG9ydFxyXG4gICAgY29uc3QgZmlsZSA9IHRoaXMuZmlsZXNbMF07XHJcbiAgICAkKHRoaXMpXHJcbiAgICAgIC5jbG9zZXN0KCcuaW5wdXQtZ3JvdXAnKVxyXG4gICAgICAuY2hpbGRyZW4oJ2lucHV0OnRleHQnKVxyXG4gICAgICAudmFsKGZpbGUubmFtZSk7XHJcbiAgICBwcm9jZXNzRmlsZXMoZmlsZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmYVRvZ2dsZUNsaWNrZWQoKSB7XHJcbiAgICAvLyBGaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIGFueSBvZiB0aGUgZm9udC1hd2Vzb21lIHRvZ2dsZSBpY29uc1xyXG4gICAgLy8gQXMgb2Ygbm93IHRoZXJlIGFyZSAyIG9mIHRoZXNlIGljb25zIG9uIHRoZSBwYWdlXHJcbiAgICBjb25zdCBpRWxlbSA9IHRoaXM7IC8vIDxpPiBlbGVtZW50XHJcblxyXG4gICAgJChpRWxlbSlcclxuICAgICAgLnRvZ2dsZUNsYXNzKCdmYS10b2dnbGUtb24gZmEtdG9nZ2xlLW9mZicpO1xyXG5cclxuICAgIGlmIChpRWxlbS5pZCA9PT0gJ2hpZGVJcnAnKSB7XHJcbiAgICAgIHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5ID0gdG9nZ2xlSXJwKHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5LCB1c2VyRGF0YS5jdXJyZW50LnNodW50LCBJcHJTaG93ZWQoKSk7XHJcbiAgICAgIGNvbWJEYXRhQW5kQ2FsYygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpRWxlbS5pZCA9PT0gJ2hpZGVOb25MaW5DdXJyJykge1xyXG4gICAgICBjb25zdCB0b2dnbGVSZXN1bHQgPSB0b2dnbGVOb25MaW5DdXJyKHVzZXJEYXRhLCB1c2VyRGF0YS5tb2RpZkRhdGFBcnJheSwgbm9uTGluZWFyQ3VycmVudFNob3dlZCgpKTtcclxuICAgICAgdXNlckRhdGEuZGF0YUFycmF5ID0gdG9nZ2xlUmVzdWx0LmRhdGFBcnJheTtcclxuICAgICAgdXNlckRhdGEubW9kaWZEYXRhQXJyYXkgPSB0b2dnbGVSZXN1bHQubW9kaWZEYXRhQXJyYXk7XHJcbiAgICAgIGNvbWJEYXRhQW5kQ2FsYygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyYW1ldGVyQ2hlY2tCb3hDaGFuZ2VkKCkge1xyXG4gICAgLyogRmlyZWQgd2hlbiB1c2VyIGNsaWNrcyBvbiBhbnkgb2YgdGhlIGNoZWNrYm94IGlucHV0c1xyXG4gICAgVGhlc2UgY2hlY2tib3hlcyBkZWZpbmUgd2hldGhlciB0aGUgY29ycmVzcG9uZGluZyBkaW9kZVxyXG4gICAgcGFyYW1ldGVyIHZhcmllcyBvciBub3QgZHVyaW5nIG9wdGltaXphdGlvblxyXG4gICAgVGhlcmVmb3JlLCBpZiB1bmNoZWNrZWQsIHRoZSBwYXJhbWV0ZXIgd2lsbCBub3QgYmUgZXN0aW1hdGVkLiAqL1xyXG4gICAgZmluZEFuZEVzdGltYXRlRGlvZGVzKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzeW5jSW5wdXRzKHNvdXJjZUVsZW0pIHtcclxuICAgIC8vIFN5bmMgcmFuZ2UgYW5kIG51bWJlciBpbnB1dHNcclxuXHJcbiAgICBjb25zdCAkc291cmNlSW5wdXQgPSAkKHNvdXJjZUVsZW0pLFxyXG4gICAgICBpc1NvdXJjZVJhbmdlID0gJHNvdXJjZUlucHV0LmF0dHIoJ3R5cGUnKSA9PT0gJ3JhbmdlJyxcclxuICAgICAgdGFyZ2V0VHlwZSA9IChpc1NvdXJjZVJhbmdlKSA/ICdudW1iZXInIDogJ3JhbmdlJyxcclxuICAgICAgc291cmNlVmFsdWUgPSAkc291cmNlSW5wdXQudmFsKCk7XHJcblxyXG4gICAgLy8gU3luYyBjb21wYW5pb24gaW5wdXRcclxuICAgIGNvbnN0ICR0YXJnZXRJbnB1dCA9ICRzb3VyY2VJbnB1dFxyXG4gICAgICAuY2xvc2VzdCgnLnJvdycpXHJcbiAgICAgIC5maW5kKCdpbnB1dC5zeW5jbWVbdHlwZT0nICsgdGFyZ2V0VHlwZSArICddJyksXHJcbiAgICAgIGlzU2NhbGVMb2cgPSAkdGFyZ2V0SW5wdXQuaGFzQ2xhc3MoJ2xvZ3NjYWxlJyk7XHJcblxyXG4gICAgaWYgKGlzU2NhbGVMb2cpIHtcclxuICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSAoaXNTb3VyY2VSYW5nZSkgPyBNYXRoLnBvdygxMCwgc291cmNlVmFsdWUpLnRvRXhwb25lbnRpYWwoMikgOiBsb2cxMChzb3VyY2VWYWx1ZSk7XHJcbiAgICAgICR0YXJnZXRJbnB1dC52YWwodGFyZ2V0VmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTGluZWFyIHNjYWxlXHJcbiAgICAgICR0YXJnZXRJbnB1dC52YWwoc291cmNlVmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3luY0FsbElucHV0cygpIHtcclxuICAgICQoJ2lucHV0W3R5cGU9bnVtYmVyXS5zeW5jbWUnKVxyXG4gICAgICAuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcclxuICAgICAgICBzeW5jSW5wdXRzKGVsZW1lbnQpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlucHV0RXZlbnQoKSB7XHJcbiAgICAvLyBFdmVudCBoYW5kbGVyXHJcbiAgICAvLyBmaXJlZCB3aGVuIHVzZXIgbW92ZXMgcmFuZ2UgaW5wdXQgb3IgY2hhbmdlIG51bWJlciBpbnB1dC5cclxuICAgIC8vIFNvIFwidGhpc1wiIGlzIGEgbnVtYmVyIG9yIHJhbmdlIGlucHV0IGVsZW1lbnRcclxuXHJcbiAgICBjb25zdCBpc051bWJlcklucHV0ID0gJCh0aGlzKS5hdHRyKCd0eXBlJykgPT09ICdudW1iZXInO1xyXG5cclxuICAgIGlmIChpc051bWJlcklucHV0KSB7XHJcbiAgICAgIGFkanVzdFJhbmdlKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN5bmNJbnB1dHModGhpcyk7XHJcblxyXG4gICAgcGFyYW1ldGVycy51cGRhdGUoJCh0aGlzKSk7XHJcblxyXG4gICAgY2FsY0lWYW5kUGxvdCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdm9sdGFnZUlucHV0Q2hhbmdlZCgpIHtcclxuICAgIC8vIEZpcmVkIHdoZW4gb25lIG9mIHRoZSAzIC52b2x0YWdlIGlucHV0cyBpcyBjaGFuZ2VkIGJ5IHVzZXJcclxuXHJcbiAgICBwYXJhbWV0ZXJzXHJcbiAgICAgIC51cGRhdGUoJCh0aGlzKSk7XHJcblxyXG4gICAgY2hlY2tWb2x0YWdlSW5wdXRzKCk7XHJcblxyXG4gICAgY2FsY0lWYW5kUGxvdCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tWb2x0YWdlSW5wdXRzKCkge1xyXG4gICAgY29uc3QgbWluVm9sdCA9IHBhcmFtZXRlcnMubWluVm9sdC52YWx1ZSxcclxuICAgICAgbWF4Vm9sdCA9IHBhcmFtZXRlcnMubWF4Vm9sdC52YWx1ZSxcclxuICAgICAgc3RlcFZvbHQgPSBwYXJhbWV0ZXJzLnN0ZXBWb2x0LnZhbHVlO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBtYXhWb2x0ID4gbWluVm9sdFxyXG4gICAgaWYgKG1heFZvbHQgPCBtaW5Wb2x0KSB7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaW5Wb2x0JykudmFsdWUgPSBtYXhWb2x0O1xyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWF4Vm9sdCcpLnZhbHVlID0gbWluVm9sdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgc3RlcFZvbHQgIT0gMFxyXG4gICAgaWYgKHN0ZXBWb2x0ID09IDApIHtcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0ZXBWb2x0JykudmFsdWUgPSAyNTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgc3RlcFZvbHQgPiAwXHJcbiAgICBpZiAoc3RlcFZvbHQgPCAwKSB7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGVwVm9sdCcpLnZhbHVlID0gTWF0aC5hYnMoc3RlcFZvbHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9nMTAodmFsKSB7XHJcbiAgICAvLyBSZXR1cm5zIGJhc2UgMTAgbG9nYXJpdGhtaWNcclxuICAgIC8vIChNYXRoLmxvZzEwKCkgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUxMSlcclxuICAgIC8vIENhbiBzdG9wIHVzaW5nIHRoaXMgZnVuY3Rpb24gd2l0aCBhIHRyYW5zcGlsZXJcclxuICAgIHJldHVybiBNYXRoLmxvZyh2YWwpIC8gTWF0aC5sb2coMTApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtRGVjaW1hbHMobW9kZWwsIG51bWJlcikge1xyXG4gICAgLy8gQ2hhbmdlIGEgbnVtYmVyJ3MgcHJlY2lzaW9uXHJcbiAgICBjb25zdCBuYkRlY2ltYWxzID0gbmJBZnRlckRvdChtb2RlbCk7XHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgbmJEZWNpbWFscykpICogTWF0aC5wb3coMTAsIC1uYkRlY2ltYWxzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5iQWZ0ZXJEb3QobnVtYmVyKSB7XHJcbiAgICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgIC8vIGFmdGVyIGRlY2ltYWwgc2VwYXJhdG9yXHJcbiAgICBjb25zdCBuID0gbnVtYmVyLnRvU3RyaW5nKCkuaW5kZXhPZignLicpO1xyXG4gICAgaWYgKG4gPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICB3aGlsZSAobnVtYmVyLmNoYXJBdChuICsgMSArIGkpICE9ICcnICYmIGlzRmluaXRlKG51bWJlci5jaGFyQXQobiArIDEgKyBpKSkpIHtcclxuICAgICAgICBpKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRSb3dEaXYoJGlucHV0KSB7XHJcbiAgICAvLyBHZXQgcGFyYW1ldGVyIGlucHV0cydcclxuICAgIC8vIGNsb3Nlc3QgY29tbW9uIGFuY2VzdG9yXHJcbiAgICByZXR1cm4gJGlucHV0XHJcbiAgICAgIC5jbG9zZXN0KCcucm93Jyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGp1c3RSYW5nZShlbGVtZW50KSB7XHJcbiAgICAvLyBXaGVuIHZhbHVlIHJlYWNoZXMgaW5wdXQncyByYW5nZSBsaW1pdCxcclxuICAgIC8vIG1vZGlmaWVzIHJhbmdlIHNvIHVzZXIgaXMgYWJsZSB0byB1c2UgaXQgYWdhaW5cclxuXHJcbiAgICBjb25zdCAkaW5wdXQgPSAkKGVsZW1lbnQpLFxyXG4gICAgICBpbnB1dFR5cGUgPSAkaW5wdXQuYXR0cigndHlwZScpLFxyXG4gICAgICAkcm93RGl2ID0gZ2V0Um93RGl2KCRpbnB1dCk7XHJcblxyXG4gICAgbGV0ICRyYW5nZUlucHV0ID0gJGlucHV0LFxyXG4gICAgICByYW5nZUlucHV0RWxlbSA9IGVsZW1lbnQsXHJcbiAgICAgICRudW1iZXJJbnB1dCA9ICRyb3dEaXZcclxuICAgICAgICAuZmluZCgnW3R5cGU9bnVtYmVyXScpLFxyXG4gICAgICBudW1iZXJJbnB1dEVsZW0gPSAkbnVtYmVySW5wdXQuZ2V0KDApO1xyXG5cclxuICAgIGlmIChpbnB1dFR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICRyYW5nZUlucHV0ID0gJHJvd0RpdlxyXG4gICAgICAgIC5maW5kKCdbdHlwZT1yYW5nZV0nKTtcclxuICAgICAgcmFuZ2VJbnB1dEVsZW0gPSAkcmFuZ2VJbnB1dC5nZXQoMCk7XHJcbiAgICAgICRudW1iZXJJbnB1dCA9ICRpbnB1dDtcclxuICAgICAgbnVtYmVySW5wdXRFbGVtID0gZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmFuZ2VDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgcmFuZ2VNYXggPSBwYXJzZUZsb2F0KHJhbmdlSW5wdXRFbGVtLm1heCksXHJcbiAgICAgIHJhbmdlTWluID0gcGFyc2VGbG9hdChyYW5nZUlucHV0RWxlbS5taW4pLFxyXG4gICAgICBudW1iZXJWYWx1ZSA9IHBhcnNlRmxvYXQobnVtYmVySW5wdXRFbGVtLnZhbHVlKTtcclxuXHJcbiAgICBpZiAoJHJhbmdlSW5wdXQuaGFzQ2xhc3MoJ2xpbmVhcnNjYWxlJykpIHtcclxuICAgICAgaWYgKG51bWJlclZhbHVlID49IHJhbmdlTWF4KSB7XHJcbiAgICAgICAgcmFuZ2VJbnB1dEVsZW0ubWF4ID0gcmVtRGVjaW1hbHMobnVtYmVyVmFsdWUsIDEuNiAqIG51bWJlclZhbHVlKTtcclxuICAgICAgICByYW5nZUlucHV0RWxlbS52YWx1ZSA9IG51bWJlclZhbHVlO1xyXG4gICAgICAgIHJhbmdlSW5wdXRFbGVtLm1pbiA9IHJlbURlY2ltYWxzKG51bWJlclZhbHVlLCAwLjQgKiBudW1iZXJWYWx1ZSk7XHJcbiAgICAgICAgcmFuZ2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobnVtYmVyVmFsdWUgPD0gcmFuZ2VNaW4pIHtcclxuICAgICAgICAgIHJhbmdlSW5wdXRFbGVtLm1pbiA9IHJlbURlY2ltYWxzKG51bWJlcklucHV0RWxlbS52YWx1ZSwgMC40ICogbnVtYmVySW5wdXRFbGVtLnZhbHVlKTtcclxuICAgICAgICAgIHJhbmdlSW5wdXRFbGVtLnZhbHVlID0gbnVtYmVySW5wdXRFbGVtLnZhbHVlO1xyXG4gICAgICAgICAgcmFuZ2VJbnB1dEVsZW0ubWF4ID0gcmVtRGVjaW1hbHMobnVtYmVySW5wdXRFbGVtLnZhbHVlLCAxLjYgKiBudW1iZXJJbnB1dEVsZW0udmFsdWUpO1xyXG4gICAgICAgICAgcmFuZ2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKDIgKiByYW5nZUlucHV0RWxlbS5zdGVwID49IChyYW5nZUlucHV0RWxlbS5tYXggLSByYW5nZUlucHV0RWxlbS5taW4pKSB7XHJcbiAgICAgICAgcmFuZ2VJbnB1dEVsZW0ubWF4ID0gMiAqIHJhbmdlSW5wdXRFbGVtLnN0ZXAgKyByYW5nZUlucHV0RWxlbS5tYXg7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFdoZW4gc2NhbGUgaXMgTG9nXHJcbiAgICAgIGlmIChudW1iZXJWYWx1ZSA+PSBNYXRoLnBvdygxMCwgcmFuZ2VNYXgpKSB7XHJcbiAgICAgICAgcmFuZ2VJbnB1dEVsZW0ubWF4ID0gTWF0aC5yb3VuZChsb2cxMChudW1iZXJWYWx1ZSkgKyAzKTtcclxuICAgICAgICByYW5nZUlucHV0RWxlbS52YWx1ZSA9IG51bWJlclZhbHVlO1xyXG4gICAgICAgIHJhbmdlSW5wdXRFbGVtLm1pbiA9IE1hdGgucm91bmQobG9nMTAobnVtYmVyVmFsdWUpIC0gMyk7XHJcbiAgICAgICAgcmFuZ2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobnVtYmVyVmFsdWUgPD0gTWF0aC5wb3coMTAsIHJhbmdlTWluKSkge1xyXG4gICAgICAgICAgcmFuZ2VJbnB1dEVsZW0ubWluID0gTWF0aC5yb3VuZChsb2cxMChudW1iZXJWYWx1ZSkgLSAzKTtcclxuICAgICAgICAgIHJhbmdlSW5wdXRFbGVtLnZhbHVlID0gbnVtYmVyVmFsdWU7XHJcbiAgICAgICAgICByYW5nZUlucHV0RWxlbS5tYXggPSBNYXRoLnJvdW5kKGxvZzEwKG51bWJlclZhbHVlKSArIDMpO1xyXG4gICAgICAgICAgcmFuZ2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByYW5nZUNoYW5nZWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGFuZ2VTdGVwKCkge1xyXG4gICAgLy8gRXZlbnQgaGFuZGxlIGZpcmVkIHdoZW5cclxuICAgIC8vIHVzZXIgYmx1cnMgbnVtYmVyIGlucHV0XHJcbiAgICBsZXQgbnVtYmVySW5wdXRFbGVtID0gdGhpcyxcclxuICAgICAgJHJhbmdlSW5wdXQgPSBnZXRSb3dEaXYoJChudW1iZXJJbnB1dEVsZW0pKVxyXG4gICAgICAgIC5maW5kKCdbdHlwZT1yYW5nZV0nKSxcclxuICAgICAgdmFsdWUgPSBudW1iZXJJbnB1dEVsZW0udmFsdWU7XHJcblxyXG4gICAgaWYgKCRyYW5nZUlucHV0Lmhhc0NsYXNzKCdsaW5lYXJzY2FsZScpKSB7XHJcbiAgICAgIG51bWJlcklucHV0RWxlbS52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpOyAvLyBGb3IgQ2hyb21lXHJcbiAgICAgIHZhciBuZXdTdGVwID0gTWF0aC5wb3coMTAsIC0xICogbmJBZnRlckRvdCh2YWx1ZSkpO1xyXG5cclxuICAgICAgbnVtYmVySW5wdXRFbGVtLnN0ZXAgPSBuZXdTdGVwO1xyXG4gICAgfVxyXG5cclxuICAgICRyYW5nZUlucHV0LmdldCgpLnN0ZXAgPSBuZXdTdGVwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbW9kZWxDaGFuZ2VkKCkge1xyXG4gICAgLy8gRmlyZWQgd2hlbiB1c2VyIGNoYW5nZXMgbnVtYmVyIG9mIGRpb2RlcyBvciB0aGUgZXF1aXZhbGVudCBjaXJjdWl0XHJcblxyXG4gICAgLy8gVXBkYXRlIG1vZGVsIHZhcmlhYmxlXHJcbiAgICBtb2RlbCA9IGdldE1vZGVsKCk7XHJcblxyXG4gICAgY2hhbmdlSW5wdXRTdGF0dXNCYXNlZE9uTW9kZWwoKTtcclxuXHJcbiAgICBjYWxjSVZhbmRQbG90KCk7XHJcblxyXG4gICAgaWYgKGZpbGVPcGVuZWQpIHtcclxuICAgICAgZmluZEFuZEVzdGltYXRlRGlvZGVzKCk7XHJcblxyXG4gICAgICBjYWxjU3FSZXNTdW0ocGFyYW1ldGVycywgdXNlckRhdGEuZGF0YUFycmF5LCBhcnJheUNhbGMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hhbmdlSW5wdXRTdGF0dXNCYXNlZE9uTW9kZWwoKSB7XHJcbiAgICBpZiAobW9kZWwuY2lyY3VpdCA9PT0gJ3BhcmFsbGVsJykge1xyXG4gICAgICAkKCdpbnB1dC5ycDInKVxyXG4gICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xyXG5cclxuICAgICAgY29uc3QgJGlucHV0cyA9ICQoJ2lucHV0Lm4yLCBpbnB1dC5pczIsICNzZXJpZXMsICNwYXJhbGxlbCcpO1xyXG5cclxuICAgICAgaWYgKCFmaWxlT3BlbmVkKSB7XHJcbiAgICAgICAgJGlucHV0c1xyXG4gICAgICAgICAgLm5vdCgnW3R5cGU9Y2hlY2tib3hdJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRpbnB1dHNcclxuICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XHJcblxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnQnKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtb2RlbC5kaW9kZUNvdW50ID09PSAxKSB7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXJpZXMnKS5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJhbGxlbCcpLmNoZWNrZWQgPSB0cnVlO1xyXG5cclxuICAgICAgbW9kZWwuY2lyY3VpdCA9ICdwYXJhbGxlbCc7XHJcblxyXG4gICAgICAkKCdpbnB1dC5uMiwgaW5wdXQuaXMyLCAjc2VyaWVzLCAjcGFyYWxsZWwsIGlucHV0LnJwMicpXHJcbiAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcblxyXG4gICAgICBpZiAoZmlsZU9wZW5lZCkge1xyXG4gICAgICAgIC8vIFdpbGwgYWxzbyBlbmFibGUgY2hlY2tib3hlc1xyXG4gICAgICAgICQoJ2lucHV0Lm4xLCBpbnB1dC5pczEsIGlucHV0LnJwMScpXHJcbiAgICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydCcpLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1vZGVsLmNpcmN1aXQgPT09ICdzZXJpZXMnKSB7XHJcbiAgICAgICQoJ2lucHV0Lm4yLCBpbnB1dC5pczIsIGlucHV0LnJwMicpXHJcbiAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG5cclxuICAgICAgLy8gRGlzYWJsZSBmaXR0aW5nIGlucHV0cyBiZWNhdXNlXHJcbiAgICAgIC8vIHNlcmllcyBtb2RlbCBub3Qgc3VwcG9ydGVkIGZvciBvcHRpbWl6YXRpb25cclxuICAgICAgZGlzYWJsZUNoZWNrYm94ZXMoKTtcclxuICAgICAgJCgnYnV0dG9uI3N0YXJ0JylcclxuICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRpc2FibGVDaGVja2JveGVzKCkge1xyXG4gICAgJCgnW3R5cGU9Y2hlY2tib3hdJylcclxuICAgICAgLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5kQW5kRXN0aW1hdGVEaW9kZXMoKSB7XHJcbiAgICBjb25zdCBmaW5kRGlvZGVzUmVzdWx0ID0gZmluZERpb2Rlcyh1c2VyRGF0YSwgSXByU2hvd2VkKCksIG5vbkxpbmVhckN1cnJlbnRTaG93ZWQoKSksXHJcbiAgICAgIGVzdGltYXRlZFBhcmFtcyA9IGVzdGltRDFEMlJzKGdldEFsbFBhcmFtcygpLCB1c2VyRGF0YSwgZmluZERpb2Rlc1Jlc3VsdCk7XHJcblxyXG4gICAgZGlzcGxheUVzdGltYXRlZFBhcmFtcyhlc3RpbWF0ZWRQYXJhbXMpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGlzcGxheUVzdGltYXRlZFBhcmFtcyhlc3RpbWF0ZWRQYXJhbXMpIHtcclxuICAgIC8vIERpc3BsYXkgdGhlIHJlc3VsdCBvZiBlc3RpbUQxRDJScyBpbnRvXHJcbiAgICAvLyB0aGUgcmVzdWx0cyB0YWJsZVxyXG5cclxuICAgIGZvciAobGV0IHBhcmFtTmFtZSBpbiBlc3RpbWF0ZWRQYXJhbXMpIHtcclxuICAgICAgY29uc3QgaWQgPSBwYXJhbU5hbWUudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICB2YWx1ZSA9IGVzdGltYXRlZFBhcmFtc1twYXJhbU5hbWVdLFxyXG4gICAgICAgIHRleHQgPSAoaXNQYXJhbVNjYWxlTG9nKGlkKSkgPyB2YWx1ZS50b0V4cG9uZW50aWFsKDIpIDogdmFsdWUudG9QcmVjaXNpb24oMik7XHJcblxyXG4gICAgICAkKCd0ZC5lc3RpbWF0aW9uIycgKyBpZClcclxuICAgICAgICAudGV4dCh0ZXh0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzUGFyYW1TY2FsZUxvZyhlbGVtSUQpIHtcclxuICAgIC8vIFJldHVybnMgd2hldGhlciBzY2FsZSB0eXBlIHVzZWQgZm9yXHJcbiAgICAvLyBhIGdpdmVuIGRpb2RlIHBhcmFtZXRlciBpcyBhIGxvZ2FyaXRobWljIG9uZVxyXG4gICAgcmV0dXJuICQoJ1t0eXBlPW51bWJlcl0jJyArIGVsZW1JRClcclxuICAgICAgLmhhc0NsYXNzKCdsb2dzY2FsZScpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXNlRXN0aW1hdGVkUGFyYW1zKCkge1xyXG4gICAgLy8gRmlyZWQgd2hlbiB1c2VyIGNsaWNrcyBcIlVzZSBlc3RpbWF0ZWQgcGFyYW1ldGVyc1wiIGJ1dHRvblxyXG4gICAgJCgndGQuZXN0aW1hdGlvbicpXHJcbiAgICAgIC5lYWNoKHVwZGF0ZUlucHV0KTtcclxuXHJcbiAgICBzeW5jQWxsSW5wdXRzKCk7XHJcblxyXG4gICAgcGFyYW1ldGVycy5pbml0KCk7XHJcblxyXG4gICAgY2FsY0lWYW5kUGxvdCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlSW5wdXQoaW5kZXgsIGVsZW1lbnQpIHtcclxuICAgIC8vIFVwZGF0ZSBhIHBhcmFtZXRlciBpbnB1dCB3aXRoIGFuIGVzdGltYXRpb25cclxuXHJcbiAgICBjb25zdCAkdGQgPSAkKGVsZW1lbnQpLFxyXG4gICAgICBwYXJhbUNsYXNzID0gJHRkLmF0dHIoJ2lkJyksXHJcbiAgICAgICRpbnB1dCA9ICQoJ2lucHV0W3R5cGU9bnVtYmVyXS4nICsgcGFyYW1DbGFzcyk7XHJcblxyXG4gICAgaWYgKCRpbnB1dC5wcm9wKCdkaXNhYmxlZCcpID09PSBmYWxzZSkge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoJHRkLnRleHQoKSk7XHJcbiAgICAgICRpbnB1dC52YWwodmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RhcnRCdXR0b25DbGlja2VkKCkge1xyXG4gICAgLy8gRmlyZWQgd2hlbiB1c2VyIGNsaWNrcyBvbiB0aGUgcGxheS9wYXVzZSBidXR0b25cclxuICAgIC8vIHRvIHN0YXJ0IG9yIHBhdXNlIHRoZSBmaXR0aW5nXHJcblxyXG4gICAgY29uc3Qgc3RhcnQgPSAkKHRoaXMpXHJcbiAgICAgIC5oYXNDbGFzcygncGxheScpO1xyXG5cclxuICAgIHRvZ2dsZVBsYXlCdXR0b24oKTtcclxuXHJcbiAgICBzdGFydFBhdXNlVmFyeShzdGFydCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVQbGF5QnV0dG9uKCkge1xyXG4gICAgJCgnI3N0YXJ0JylcclxuICAgICAgLnRvZ2dsZUNsYXNzKCdwbGF5IHBhdXNlJyk7XHJcbiAgfVxyXG5cclxuICAvKiBUaGUgdHdvIGZvbGxvd2luZyBmdW5jdGlvbnMgY2FsY3VsYXRlXHJcbiAgICAgdGhlIGN1cnJlbnQgYXQgYSBnaXZlbiB2b2x0YWdlICovXHJcblxyXG4gIGZ1bmN0aW9uIElwYXJhbGxlbChWLCBJcGgsIHByZXZJLCBULCBuMSwgbjIsIElzMSwgSXMyLCBScCwgUnMpIHtcclxuICAgIC8vIERvdWJsZSBkaW9kZSAoaW4gcGFyYWxsZWwpIG1vZGVsXHJcbiAgICBsZXQgaSA9IDAsIEksIGYsIGRmLCByLCBJZDEsIElkMiwgSXJwO1xyXG5cclxuICAgIElwaCA9IElwaCAvIDEwMDA7IC8vIG1BIC0+IEFcclxuXHJcbiAgICBpZiAoIXByZXZJKSB7XHJcbiAgICAgIEkgPSBJcGg7XHJcbiAgICAgIHByZXZJID0gSTtcclxuICAgIH1cclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgIHByZXZJID0gSTtcclxuICAgICAgfVxyXG5cclxuICAgICAgSWQxID0gSXMxICogKE1hdGguZXhwKHEgKiAoViArIHByZXZJICogUnMpIC8gKG4xICogayAqIFQpKSAtIDEpO1xyXG4gICAgICBJZDIgPSBJczIgKiAoTWF0aC5leHAocSAqIChWICsgcHJldkkgKiBScykgLyAobjIgKiBrICogVCkpIC0gMSk7XHJcbiAgICAgIElycCA9IChWICsgcHJldkkgKiBScykgLyBScDtcclxuXHJcbiAgICAgIC8vIGYoVixwcmV2SSlcclxuICAgICAgZiA9IElwaCAtIElkMSAtIElkMiAtIElycCAtIHByZXZJO1xyXG5cclxuICAgICAgLy8gZGYoVixwcmV2SSkvZHByZXZJXHJcbiAgICAgIGRmID0gLSgoSXMxICogUnMpIC8gKG4xICogVCAqIGsgLyBxKSkgKiBNYXRoLmV4cCgoViArIHByZXZJICogUnMpIC8gKG4xICogVCAqIGsgLyBxKSlcclxuICAgICAgICAtICgoSXMyICogUnMpIC8gKG4yICogVCAqIGsgLyBxKSkgKiBNYXRoLmV4cCgoViArIHByZXZJICogUnMpIC8gKG4yICogVCAqIGsgLyBxKSlcclxuICAgICAgICAtIFJzIC8gUnAgLSAxO1xyXG5cclxuICAgICAgLy8gZi9kZlxyXG4gICAgICByID0gZiAvIGRmO1xyXG5cclxuICAgICAgSSA9IHByZXZJIC0gcjtcclxuXHJcbiAgICAgIGkrKztcclxuXHJcbiAgICB9IHdoaWxlIChNYXRoLmFicyhJIC0gcHJldkkpID4gbWNoRXBzICYmIGkgPCA1MDApO1xyXG5cclxuICAgIHJldHVybiBbSSwgSWQxLCBJZDIsIElycCwgSWQxICsgSWQyICsgSXJwXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIElzZXJpZXMoViwgVCwgSXBoLCBuMSwgbjIsIElzMSwgSXMyLCBScDEsIFJwMiwgUnMpIHtcclxuICAgIC8vIERvdWJsZSBkaW9kZSAoaW4gc2VyaWVzKSBtb2RlbFxyXG4gICAgbGV0IGkgPSAwLCBJYSwgSWIsIFYxLCBWMiwgSWQxLCBJZDIsIElycDEsIElycDIsIEggPSAxMCwgTCA9IC0xMDtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIFYxID0gKEggKyBMKSAvIDI7XHJcblxyXG4gICAgICBJZDEgPSBJczEgKiBNYXRoLmV4cChxICogVjEgLyAobjEgKiBrICogVCkgLSAxKTtcclxuICAgICAgSXJwMSA9IFYxIC8gUnAxO1xyXG5cclxuICAgICAgSWEgPSBJZDEgKyBJcnAxO1xyXG5cclxuICAgICAgVjIgPSBWIC0gVjEgLSBScyAqIElhO1xyXG5cclxuICAgICAgSWQyID0gSXMyICogTWF0aC5leHAocSAqIFYyIC8gKG4yICogayAqIFQpIC0gMSk7XHJcbiAgICAgIElycDIgPSBWMiAvIFJwMjtcclxuICAgICAgSWIgPSBJZDIgKyBJcnAyO1xyXG5cclxuICAgICAgdmFyIGRpZmZJID0gSWIgLSBJYTtcclxuXHJcbiAgICAgIGlmIChkaWZmSSA+IDApIHtcclxuICAgICAgICBMID0gVjE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgSCA9IFYxO1xyXG4gICAgICB9XHJcbiAgICAgIGkrKztcclxuXHJcbiAgICB9IHdoaWxlIChNYXRoLmFicyhkaWZmSSkgPiBtY2hFcHMgJiYgaSA8IDUwMCk7XHJcbiAgICByZXR1cm4gW0lhLCBJZDEsIElkMiwgSXJwMSwgSXJwMl07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQYXJhbSQocGFyYW1DbGFzcykge1xyXG4gICAgcmV0dXJuICQoJ2lucHV0W3R5cGU9bnVtYmVyXScpXHJcbiAgICAgIC5maWx0ZXIoJy4nICsgcGFyYW1DbGFzcyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQYXJhbVZhbHVlKHBhcmFtQ2xhc3MpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KFxyXG4gICAgICBnZXRQYXJhbSQocGFyYW1DbGFzcylcclxuICAgICAgICAudmFsKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQYXJhbUNoZWNrZWQocGFyYW1DbGFzcykge1xyXG4gICAgcmV0dXJuICQoJ2lucHV0W3R5cGU9Y2hlY2tib3hdJylcclxuICAgICAgLmZpbHRlcignLicgKyBwYXJhbUNsYXNzKVxyXG4gICAgICAuaXMoJzpjaGVja2VkJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRBbGxQYXJhbXMoKSB7XHJcbiAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICB2YWx1ZToge1xyXG4gICAgICAgIGlwaDogdW5kZWZpbmVkLFxyXG4gICAgICAgIHQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBuMTogdW5kZWZpbmVkLFxyXG4gICAgICAgIG4yOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaXMxOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaXMyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcnAxOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcnAyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcnM6IHVuZGVmaW5lZFxyXG4gICAgICB9LFxyXG4gICAgICBjaGVja2VkOiB7XHJcbiAgICAgICAgaXBoOiB1bmRlZmluZWQsXHJcbiAgICAgICAgdDogdW5kZWZpbmVkLFxyXG4gICAgICAgIG4xOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbjI6IHVuZGVmaW5lZCxcclxuICAgICAgICBpczE6IHVuZGVmaW5lZCxcclxuICAgICAgICBpczI6IHVuZGVmaW5lZCxcclxuICAgICAgICBycDE6IHVuZGVmaW5lZCxcclxuICAgICAgICBycDI6IHVuZGVmaW5lZCxcclxuICAgICAgICByczogdW5kZWZpbmVkXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZm9yIChsZXQgcGFyYW1DbGFzcyBpbiBwYXJhbXMudmFsdWUpIHtcclxuICAgICAgcGFyYW1zLnZhbHVlW3BhcmFtQ2xhc3NdID0gZ2V0UGFyYW1WYWx1ZShwYXJhbUNsYXNzKTtcclxuICAgICAgcGFyYW1zLmNoZWNrZWRbcGFyYW1DbGFzc10gPSBnZXRQYXJhbUNoZWNrZWQocGFyYW1DbGFzcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0UGFyYW1WYWx1ZShwYXJhbUNsYXNzLCB2YWx1ZSkge1xyXG4gICAgZ2V0UGFyYW0kKHBhcmFtQ2xhc3MpXHJcbiAgICAgIC52YWwodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TW9kZWwoKSB7XHJcbiAgICBjb25zdCBpc1NpbmdsZURpb2RlQ2hlY2tlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW5nbGVEaW9kZScpLmNoZWNrZWQsXHJcbiAgICAgIGlzUGFyYWxsZWxDaGVja2VkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmFsbGVsJykuY2hlY2tlZDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRpb2RlQ291bnQ6IChpc1NpbmdsZURpb2RlQ2hlY2tlZCkgPyAxIDogMixcclxuICAgICAgY2lyY3VpdDogKGlzUGFyYWxsZWxDaGVja2VkKSA/ICdwYXJhbGxlbCcgOiAnc2VyaWVzJ1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbGNJVihwYXJhbXMsIG1vZGVsKSB7XHJcbiAgICAvLyBDYWxjdWxhdGVzIGN1cnJlbnQgZm9yIGEgcmFuZ2Ugb2Ygdm9sdGFnZSB2YWx1ZXNcclxuXHJcbiAgICBjb25zdCBtaW5Wb2x0ID0gcGFyYW1zLm1pblZvbHQudmFsdWUsXHJcbiAgICAgIG1heFZvbHQgPSBwYXJhbXMubWF4Vm9sdC52YWx1ZSxcclxuICAgICAgc3RlcFZvbHQgPSBwYXJhbXMuc3RlcFZvbHQudmFsdWUsXHJcbiAgICAgIElwaCA9IHBhcmFtcy5pcGgudmFsdWUsXHJcbiAgICAgIFQgPSBwYXJhbXMudC52YWx1ZSxcclxuICAgICAgbjEgPSBwYXJhbXMubjEudmFsdWUsXHJcbiAgICAgIElzMSA9IHBhcmFtcy5pczEudmFsdWU7XHJcblxyXG4gICAgbGV0IG4yID0gcGFyYW1zLm4yLnZhbHVlLFxyXG4gICAgICBJczIgPSBwYXJhbXMuaXMyLnZhbHVlLFxyXG4gICAgICBScDIgPSBwYXJhbXMucnAyLnZhbHVlO1xyXG5cclxuICAgIGlmIChtb2RlbC5kaW9kZUNvdW50ID09PSAxKSB7XHJcbiAgICAgIG4yID0gMTtcclxuICAgICAgSXMyID0gMDtcclxuICAgICAgUnAyO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBScCA9IHBhcmFtcy5ycDEudmFsdWUsXHJcbiAgICAgIFJzID0gcGFyYW1zLnJzLnZhbHVlO1xyXG5cclxuICAgIGxldCBJcGFyLCBJc2VyLCBJLCBJZDEsIElkMixcclxuICAgICAgYXJyYXlWSSA9IFtdLFxyXG4gICAgICBhcnJheVZJZDEgPSBbXSxcclxuICAgICAgYXJyYXlWSWQyID0gW10sXHJcbiAgICAgIGFycmF5VklycDEgPSBbXSxcclxuICAgICAgYXJyYXlWSXJwMiA9IFtdLFxyXG4gICAgICBwYXJhbGxlbCwgbW9kZWxDYXNlO1xyXG5cclxuICAgIGlmIChtb2RlbC5jaXJjdWl0ID09PSAncGFyYWxsZWwnKSB7XHJcbiAgICAgIHBhcmFsbGVsID0gdHJ1ZSxcclxuICAgICAgICBtb2RlbENhc2UgPSAncGFyYWxsZWwnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtb2RlbC5kaW9kZUNvdW50ID09PSAxKSB7XHJcbiAgICAgIHBhcmFsbGVsID0gdHJ1ZSxcclxuICAgICAgICBtb2RlbENhc2UgPSAnc2luZ2xlJztcclxuICAgIH1cclxuICAgIGlmIChtb2RlbC5jaXJjdWl0ID09PSAnc2VyaWVzJykge1xyXG4gICAgICBtb2RlbENhc2UgPSAnc2VyaWVzJztcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBWID0gbWluVm9sdDsgViA8PSBtYXhWb2x0OyBWICs9IHN0ZXBWb2x0IC8gMTAwMCkge1xyXG4gICAgICBpZiAocGFyYWxsZWwpIHtcclxuICAgICAgICBJcGFyID0gSXBhcmFsbGVsKFYsIElwaCwgSSwgVCwgbjEsIG4yLCBJczEsIElzMiwgUnAsIFJzKTtcclxuICAgICAgICBJID0gLSBJcGFyWzBdO1xyXG4gICAgICAgIElkMSA9IElwYXJbMV07XHJcbiAgICAgICAgSWQyID0gSXBhclsyXTtcclxuICAgICAgICB2YXIgSXJwID0gSXBhclszXTtcclxuICAgICAgICBhcnJheVZJcnAxLnB1c2goW1YsIElycF0pO1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZWQgY3VycmVudCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsIGN1cnJlbnQgZm9yIG5leHQgdm9sdGFnZSxcclxuICAgICAgICAvLyBzcGVlZHMgdXAgZXF1YXRpb24gc29sdmluZywgaXMgaW1wb3J0YW50IGZvciBoaWdoIGRpcmVjdCBiaWFzXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgSXNlciA9IElzZXJpZXMoViwgVCwgSXBoLCBuMSwgbjIsIElzMSwgSXMyLCBScCwgUnAyLCBScyk7XHJcbiAgICAgICAgSSA9IElzZXJbMF07XHJcbiAgICAgICAgSWQxID0gSXNlclsxXTtcclxuICAgICAgICBJZDIgPSBJc2VyWzJdO1xyXG4gICAgICAgIHZhciBJcnAxID0gSXNlclszXSxcclxuICAgICAgICAgIElycDIgPSBJc2VyWzRdO1xyXG4gICAgICAgIGFycmF5VklycDEucHVzaChbViwgSXJwMV0pO1xyXG4gICAgICAgIGFycmF5VklycDIucHVzaChbViwgSXJwMl0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcnJheVZJLnB1c2goW1YsIEldKTtcclxuICAgICAgYXJyYXlWSWQxLnB1c2goW1YsIElkMV0pO1xyXG4gICAgICBhcnJheVZJZDIucHVzaChbViwgSWQyXSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbW9kZWxDYXNlcyA9IHtcclxuICAgICAgcGFyYWxsZWw6IHtcclxuICAgICAgICBhcnJheUNhbGM6IFthcnJheVZJLCBhcnJheVZJZDEsIGFycmF5VklkMiwgYXJyYXlWSXJwMV0sXHJcbiAgICAgICAgcGxvdFN0eWxlOiBbXHJcbiAgICAgICAgICBbJ2xpbmUnLCAnYmxhY2snLCAnSSddLFxyXG4gICAgICAgICAgWydsaW5lJywgJ29yYW5nZScsICdJZDEnXSxcclxuICAgICAgICAgIFsnbGluZScsICdvcmFuZ2UnLCAnSWQyJ10sXHJcbiAgICAgICAgICBbJ2xpbmUnLCAncHVycGxlJywgJ0lycCddXHJcbiAgICAgICAgXVxyXG4gICAgICB9LFxyXG4gICAgICBzaW5nbGU6IHtcclxuICAgICAgICBhcnJheUNhbGM6IFthcnJheVZJLCBhcnJheVZJZDEsIGFycmF5VklycDFdLFxyXG4gICAgICAgIHBsb3RTdHlsZTogW1xyXG4gICAgICAgICAgWydsaW5lJywgJ2JsYWNrJywgJ0knXSxcclxuICAgICAgICAgIFsnbGluZScsICdvcmFuZ2UnLCAnSWQxJ10sXHJcbiAgICAgICAgICBbJ2xpbmUnLCAncHVycGxlJywgJ0lycCddXHJcbiAgICAgICAgXVxyXG4gICAgICB9LFxyXG4gICAgICBzZXJpZXM6IHtcclxuICAgICAgICBhcnJheUNhbGM6IFthcnJheVZJLCBhcnJheVZJZDEsIGFycmF5VklkMiwgYXJyYXlWSXJwMSwgYXJyYXlWSXJwMV0sXHJcbiAgICAgICAgcGxvdFN0eWxlOiBbXHJcbiAgICAgICAgICBbJ2xpbmUnLCAnYmxhY2snLCAnSSddLFxyXG4gICAgICAgICAgWydsaW5lJywgJ29yYW5nZScsICdJZDEnXSxcclxuICAgICAgICAgIFsnbGluZScsICdvcmFuZ2UnLCAnSWQyJ10sXHJcbiAgICAgICAgICBbJ2xpbmUnLCAncHVycGxlJywgJ0lycDEnXSxcclxuICAgICAgICAgIFsnbGluZScsICdwdXJwbGUnLCAnSXJwMiddXHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBtb2RlbENhc2VzW21vZGVsQ2FzZV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY2FsZVR5cGUoKSB7XHJcbiAgICAvLyBSZXR1cm5zIHRoZSB0eXBlIG9mIHNjYWxlIGZvciB5IGF4aXNcclxuICAgIGNvbnN0IHNjYWxlSXNMaW5lYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluZWFyJykuY2hlY2tlZDtcclxuICAgIHJldHVybiAoc2NhbGVJc0xpbmVhcikgPyAnbGluZWFyU2NhbGUnIDogJ2xvZ1NjYWxlJztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWxlcyhmaWxlKSB7XHJcbiAgICAvLyBGaXJlZCB3aGVuIGZpbGUgaW5wdXQgY2hhbmdlZFxyXG5cclxuICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cclxuICAgIHJlYWRlci5vbmxvYWQgPSByZWFkZXJPbkxvYWQ7XHJcbiAgICByZWFkZXIuZmlsZW5hbWUgPSBmaWxlLm5hbWU7XHJcblxyXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWFkZXJPbkxvYWQoZXZlbnQpIHtcclxuICAgIC8vIEZpcmVkIHdoZW4gZGF0YSBpcyByZWFkeVxyXG5cclxuICAgIC8vIEd1ZXNzIFQgZnJvbSBmaWxlIG5hbWVcclxuICAgIGxldCBmaWxlTmFtZSA9IHRoaXMuZmlsZW5hbWU7XHJcblxyXG4gICAgd2hpbGUgKGlzTmFOKHBhcnNlRmxvYXQoZmlsZU5hbWUpKSAmJiBmaWxlTmFtZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbGVOYW1lID0gcGFyc2VGbG9hdChmaWxlTmFtZSk7XHJcblxyXG4gICAgY29uc3QgZGVmYXVsdFQgPSAoaXNOYU4oZmlsZU5hbWUpKSA/IDI5OCA6IGZpbGVOYW1lLFxyXG4gICAgICBUID0gcHJvbXB0KCdUZW1wZXJhdHVyZT8gKEspJywgZGVmYXVsdFQpO1xyXG5cclxuICAgIGlmIChpc0Zpbml0ZShUKSAmJiBUID4gMCkge1xyXG4gICAgICBzZXRQYXJhbVZhbHVlKCd0JywgVCk7XHJcbiAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzbGlkZXJUJykudmFsdWUgPSBUO1xyXG4gICAgICB1c2VyRGF0YS5kYXRhQXJyYXkgPSBbXTtcclxuICAgICAgdXNlckRhdGEubW9kaWZEYXRhQXJyYXkgPSBbXTtcclxuXHJcbiAgICAgIHN0cmluZ1RvQXJyYXkoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbGVhckRhdGEoKSB7XHJcbiAgICAvLyBGaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIHRoZSBDbGVhciBidXR0b25cclxuXHJcbiAgICB1c2VyRGF0YS5kYXRhQXJyYXkgPSBbXTtcclxuICAgIHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5ID0gW107XHJcbiAgICBmaWxlT3BlbmVkID0gZmFsc2U7XHJcbiAgICBjb21iRGF0YUFuZENhbGMoKTtcclxuXHJcbiAgICAkKCcucGFuZWwnKVxyXG4gICAgICAuYWRkQ2xhc3MoJ25vZmlsZScpO1xyXG5cclxuICAgICQoJy5mYS10b2dnbGUtb24nKVxyXG4gICAgICAudG9nZ2xlQ2xhc3MoJ2ZhLXRvZ2dsZS1vbiBmYS10b2dnbGUtb2ZmJyk7XHJcblxyXG4gICAgaWYgKHdpbmRvdy5sb2NhbEZpbGUgLyogRkYgaXMgcGlja3kgYWJvdXQgdGhhdDogbm90IGltcG9ydGluZyB0aGUgZmlsZSB0aHJvdWdoIGNsYXNzaWMgJ2Jyb3dzZScgYnV0dG9uIHJlc3VsdCBpbiBhbiBlcnJvciBoZXJlICovKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhbEZpbGUucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhckZpbGVJbnB1dCgpO1xyXG5cclxuICAgICQoJy5lc3RpbWF0aW9uJylcclxuICAgICAgLmFkZCgnLmZpbmFsJylcclxuICAgICAgLmFkZCgnI3MnKVxyXG4gICAgICAuYWRkKCcjZHMnKVxyXG4gICAgICAuZW1wdHkoKTtcclxuXHJcbiAgICBpZiAoJCgnI3N0YXJ0JykuaGFzQ2xhc3MoJ3BhdXNlJykpIHtcclxuICAgICAgdG9nZ2xlUGxheUJ1dHRvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIHVzZXJEYXRhLmVzdGltYXRlZFBhcmFtZXRlcnMuUnAgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgZGlzYWJsZUNoZWNrYm94ZXMoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyRmlsZUlucHV0KCkge1xyXG4gICAgJCgnaW5wdXRbdHlwZT1maWxlXScpXHJcbiAgICAgIC52YWwobnVsbClcclxuICAgICAgLmNsb3Nlc3QoJ2RpdicpXHJcbiAgICAgIC5jaGlsZHJlbignaW5wdXRbdHlwZT10ZXh0XScpXHJcbiAgICAgIC52YWwoJycpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShkYXRhKSB7XHJcbiAgICAvLyBDb252ZXJ0IHRoZSBkYXRhc2V0IGZyb20gYSBzdHJpbmdcclxuICAgIC8vIHRvIGFuIGFycmF5IG9mIGFycmF5cyBvZiBudW1iZXJzXHJcblxyXG4gICAgbGV0IGFycmF5ID0gZGF0YS5zcGxpdCgnXFxuJyksXHJcbiAgICAgIHNraXBSb3csXHJcbiAgICAgIGRhdGFBcnJheSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IHN0cmluZ1JvdyBvZiBhcnJheSkge1xyXG4gICAgICBza2lwUm93ID0gZmFsc2U7XHJcbiAgICAgIGNvbnN0IHJvdyA9IHN0cmluZ1Jvdy5zcGxpdCgnXFx0Jyk7XHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgZWFjaCBvZiB0aGUgZmlyc3QgdHdvXHJcbiAgICAgIC8vIGVsZW1lbnRzIGluIHRoZSByb3cgaXMgYSBudW1iZXJcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyOyBqKyspIHtcclxuICAgICAgICByb3dbal0gPSBOdW1iZXIocm93W2pdKTtcclxuICAgICAgICBza2lwUm93ICs9IGlzTmFOKHJvd1tqXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghc2tpcFJvdykge1xyXG4gICAgICAgIGRhdGFBcnJheS5wdXNoKHJvdyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmVzIHRoZSBzZW1pLXRyYW5zcGFyZW50XHJcbiAgICAvLyBvdmVybGF5IGRpdlxyXG4gICAgJCgnLnBhbmVsJylcclxuICAgICAgLnJlbW92ZUNsYXNzKCdub2ZpbGUnKTtcclxuXHJcbiAgICBmaWxlT3BlbmVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBFbmFibGUgY2hlY2tib3hlcyBmb3IgdGhlIGFscmVhZHlcclxuICAgIC8vIGVuYWJsZWQgcGFyYW1ldGVyIGlucHV0c1xyXG4gICAgJCgnW3R5cGU9cmFuZ2VdOmVuYWJsZWQnKVxyXG4gICAgICAuZWFjaChlbmFibGVDaGVja2JveElucHV0KTtcclxuXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWluVm9sdCcpLnZhbHVlID0gZGF0YUFycmF5WzBdWzBdO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heFZvbHQnKS52YWx1ZSA9IGRhdGFBcnJheVtkYXRhQXJyYXkubGVuZ3RoIC0gMV1bMF0gKyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RlcFZvbHQnKS52YWx1ZSAvIDEwMDA7XHJcblxyXG4gICAgZGF0YUFycmF5ID0gW2RhdGFBcnJheV07XHJcblxyXG4gICAgdXNlckRhdGEuZGF0YUFycmF5ID0gZGF0YUFycmF5O1xyXG4gICAgdXNlckRhdGEubW9kaWZEYXRhQXJyYXkgPSBkYXRhQXJyYXk7XHJcblxyXG4gICAgY29uc3QgaXZSZXN1bHQgPSBjYWxjSVYocGFyYW1ldGVycywgZ2V0TW9kZWwoKSk7XHJcblxyXG4gICAgLyoqKiogRXN0aW1hdGUgcGFyYW1ldGVycyAqKioqL1xyXG5cclxuICAgIC8vIFBhcmFsbGVsIHJlc2lzdGFuY2UgUnBcclxuICAgIGNvbnN0IFJwID0gZXN0aW1ScChkYXRhQXJyYXkpO1xyXG4gICAgdXNlckRhdGEuZXN0aW1hdGVkUGFyYW1ldGVycy5ScCA9IFJwO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBQYXJhbGxlbCBjdXJyZW50IGFuZCBub24gbGluZWFyIHJldmVyc2UgY3VycmVudFxyXG4gICAgY29uc3QgY3VycmVudCA9IGNhbGNJcnBBbmROb25MaW5SZXZDdXJyKGRhdGFBcnJheSwgUnApO1xyXG4gICAgdXNlckRhdGEuY3VycmVudC5ub25MaW5lYXIgPSBjdXJyZW50Lm5vbkxpbmVhcjtcclxuICAgIHVzZXJEYXRhLmN1cnJlbnQuc2h1bnQgPSBjdXJyZW50LnNodW50O1xyXG5cclxuICAgIGZpbmRBbmRFc3RpbWF0ZURpb2RlcygpO1xyXG5cclxuICAgIGNhbGNTcVJlc1N1bShwYXJhbWV0ZXJzLCBkYXRhQXJyYXksIGFycmF5Q2FsYyk7XHJcblxyXG4gICAgY29tYkRhdGFBbmRDYWxjKGl2UmVzdWx0KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVuYWJsZUNoZWNrYm94SW5wdXQoaW5kZXgsIGVsZW1lbnQpIHtcclxuICAgIGdldFJvd0RpdigkKGVsZW1lbnQpKVxyXG4gICAgICAuZmluZCgnW3R5cGU9Y2hlY2tib3hdJylcclxuICAgICAgLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gSXByU2hvd2VkKCkge1xyXG4gICAgcmV0dXJuICQoJyNoaWRlSXJwJykuaGFzQ2xhc3MoJ2ZhLXRvZ2dsZS1vZmYnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5vbkxpbmVhckN1cnJlbnRTaG93ZWQoKSB7XHJcbiAgICByZXR1cm4gJCgnI2hpZGVOb25MaW5DdXJyJykuaGFzQ2xhc3MoJ2ZhLXRvZ2dsZS1vZmYnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbWJEYXRhQW5kQ2FsYygpIHtcclxuICAgIC8vIENvbWJpbmUgdXBsb2FkZWQgZGF0YSBhbmQgY2FsY3VsYXRlZCBJViBpbnRvIG9uZSBncmFwaFxyXG4gICAgY29uc3QgY2FudmFzSUQgPSAnZ3JhcGgnLFxyXG4gICAgICBkYXRhID0gdXNlckRhdGEubW9kaWZEYXRhQXJyYXkuY29uY2F0KGFycmF5Q2FsYyksXHJcbiAgICAgIHByaW1hcnlQbG90SW5kZXggPSAwLFxyXG4gICAgICB4VGl0bGUgPSAnViAoViknLFxyXG4gICAgICB5VGl0bGUgPSAnSSAoQSknO1xyXG4gICAgbGV0IHN0eWxlO1xyXG5cclxuICAgIGlmIChmaWxlT3BlbmVkKSB7XHJcbiAgICAgIGNvbnN0IGRhdGFTdHlsZSA9IFtbJ3ZlcnRpY2FsQ3Jvc3MnLCAncHVycGxlJywgJ0RhdGEnXV07XHJcbiAgICAgIHN0eWxlID0gZGF0YVN0eWxlLmNvbmNhdChwbG90U3R5bGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3R5bGUgPSBwbG90U3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0dyYXBoKGNhbnZhc0lELCBkYXRhLCBwcmltYXJ5UGxvdEluZGV4LCBzdHlsZSwgc2NhbGVUeXBlKCksIHhUaXRsZSwgeVRpdGxlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRhYmxlU3VjY2Vzc0NvbnRleHQoYWRkKSB7XHJcbiAgICAvLyBBZGQgb3IgcmVtb3ZlIFwic3VjY2Vzc1wiIGNvbG9yIG9uXHJcbiAgICAvLyBwYXJhbWV0ZXIncyB0YWJsZSdzIDNyZCBjb2x1bW5cclxuXHJcbiAgICBjb25zdCAkdGQgPSAkKCd0ZC5maW5hbCcpO1xyXG5cclxuICAgIGlmIChhZGQpIHtcclxuICAgICAgJHRkLmFkZENsYXNzKCdzdWNjZXNzJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkdGQucmVtb3ZlQ2xhc3MoJ3N1Y2Nlc3MnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogIEZpdCBcclxuICAgKi9cclxuXHJcblxyXG4gIGxldCBpbnRlcnZhbDtcclxuXHJcbiAgZnVuY3Rpb24gZXN0aW1ScChkYXRhQXJyYXkpIHtcclxuICAgIC8vIEVzdGltYXRlIHBhcmFsbGVsIHJlc2lzdGFuY2UgUnBcclxuICAgIGxldCBtaW4gPSArSW5maW5pdHksXHJcbiAgICAgIGFycmF5ID0gZGF0YUFycmF5WzBdO1xyXG5cclxuICAgIGZvciAobGV0IHh5IG9mIGFycmF5KSB7XHJcbiAgICAgIGxldCB4ID0geHlbMF0sXHJcbiAgICAgICAgc2xvcGUgPSB4eVsxXSAvIHg7XHJcbiAgICAgIGlmIChzbG9wZSA8IG1pbiAmJiBNYXRoLmFicyh4KSA+IDAuMDAxKSB7XHJcbiAgICAgICAgbWluID0gc2xvcGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgUnAgPSAxIC8gbWluO1xyXG4gICAgLy8gdmFyIG9PTSA9IG9yZGVyT2ZNYWduKFJwKTtcclxuICAgIC8vdmFyIHJvdW5kZWRScCA9IE1hdGgucm91bmQoUnAgKiAxMDAwIC8gb09NKSAqIG9PTSAvIDEwMDA7XHJcblxyXG4gICAgcmV0dXJuIFJwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2FsY0lycEFuZE5vbkxpblJldkN1cnIoZGF0YUFycmF5LCBScCkge1xyXG4gICAgbGV0IGFycmF5ID0gZGF0YUFycmF5WzBdLFxyXG4gICAgICBub25MaW5EaXJDdXJyID0gW10sXHJcbiAgICAgIHNodW50Q3VycmVudCA9IFtdLFxyXG4gICAgICBub25MaW5DdXJyID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgVkkgb2YgYXJyYXkpIHtcclxuICAgICAgbGV0IFYgPSBWSVswXSxcclxuICAgICAgICBJcnAgPSBWIC8gUnA7XHJcbiAgICAgIHNodW50Q3VycmVudC5wdXNoKFtWLCBJcnBdKTtcclxuXHJcbiAgICAgIGlmIChWIDwgLTAuMDAwMSkge1xyXG4gICAgICAgIC8vIE9ubHkgbG9va2luZyBhdCByZXZlcnNlIHBvbGFyaXphdGlvbjpcclxuICAgICAgICAvLyBOb24tbGluZWFyIHJldmVyc2UgY3VycmVudCBpcyB0b3RhbCBjdXJyZW50IG1pbnVzIHBhcmFsbGVsIGN1cnJlbnQgKHdoaWNoIGlzIGxpbmVhcilcclxuICAgICAgICBsZXQgSW5sID0gVklbMV0gLSBJcnA7IC8vIElubCAtPiAnbmwnID0gJ05vbi1MaW5lYXInXHJcblxyXG4gICAgICAgIC8vIERlZHVjZSBkaXJlY3Qgbm9uIGxpbmVhciBjdXJyZW50XHJcbiAgICAgICAgbm9uTGluRGlyQ3Vyci51bnNoaWZ0KFstViwgLUlubF0pO1xyXG5cclxuICAgICAgICAvLyBSZXZlcnNlXHJcbiAgICAgICAgbm9uTGluQ3Vyci5wdXNoKFtWLCBJbmxdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbWJpbmUgcmV2ZXJzZSBhbmQgZGlyZWN0XHJcbiAgICBub25MaW5DdXJyID0gbm9uTGluQ3Vyci5jb25jYXQoW1swLCAwXV0sIG5vbkxpbkRpckN1cnIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNodW50OiBzaHVudEN1cnJlbnQsXHJcbiAgICAgIG5vbkxpbmVhcjogbm9uTGluQ3VyclxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvZ2dsZUlycChtb2RpZkRhdGFBcnJheSwgc2h1bnRDdXJyZW50LCBzaG93KSB7XHJcbiAgICAvLyBTaG93IG9yIGhpZGUgSXJwIG9uIGdyYXBoXHJcblxyXG4gICAgbGV0IGFycmF5ID0gbW9kaWZEYXRhQXJyYXlbMF0sXHJcbiAgICAgIG5ld0FycmF5ID0gW10sXHJcbiAgICAgIGkgPSAwLFxyXG4gICAgICBzaWduID0gKHNob3cpID8gMSA6IC0xO1xyXG5cclxuICAgIGZvciAobGV0IElWIG9mIGFycmF5KSB7XHJcbiAgICAgIG5ld0FycmF5LnB1c2goW0lWWzBdLCBJVlsxXSArIHNpZ24gKiBzaHVudEN1cnJlbnRbaV1bMV1dKTtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZGlmRGF0YUFycmF5ID0gW25ld0FycmF5XTtcclxuXHJcbiAgICByZXR1cm4gbW9kaWZEYXRhQXJyYXk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVOb25MaW5DdXJyKHVzZXJEYXRhLCBtb2RpZkRhdGFBcnJheSwgc2hvdykge1xyXG5cclxuICAgIGNvbnN0IG5vbkxpbmVhckN1cnJlbnQgPSB1c2VyRGF0YS5jdXJyZW50Lm5vbkxpbmVhcjtcclxuXHJcbiAgICBsZXQgYXJyYXkxID0gdXNlckRhdGEuZGF0YUFycmF5WzBdLFxyXG4gICAgICBhcnJheTIgPSB1c2VyRGF0YS5tb2RpZkRhdGFBcnJheVswXSxcclxuICAgICAgSVYyLFxyXG4gICAgICBuZXdBcnJheTEgPSBbXSxcclxuICAgICAgbmV3QXJyYXkyID0gW10sXHJcbiAgICAgIHNpZ24gPSAoc2hvdykgPyAxIDogLTEsXHJcbiAgICAgIGkgPSAwO1xyXG5cclxuICAgIGZvciAobGV0IElWMSBvZiBhcnJheTEpIHtcclxuICAgICAgbmV3QXJyYXkxLnB1c2goW0lWMVswXSwgSVYxWzFdICsgc2lnbiAqIG5vbkxpbmVhckN1cnJlbnRbaV1bMV1dKTtcclxuICAgICAgSVYyID0gYXJyYXkyW2ldO1xyXG4gICAgICBuZXdBcnJheTIucHVzaChbSVYyWzBdLCBJVjJbMV0gKyBzaWduICogbm9uTGluZWFyQ3VycmVudFtpXVsxXV0pO1xyXG4gICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YUFycmF5OiBbbmV3QXJyYXkxXSxcclxuICAgICAgbW9kaWZEYXRhQXJyYXk6IFtuZXdBcnJheTJdXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgbGV0IFNxUmVzU3VtLFxyXG4gICAgZGVsUyA9IFtdO1xyXG5cclxuICBmdW5jdGlvbiBjYWxjU3FSZXNTdW0ocGFyYW1zLCBkYXRhQXJyYXksIGFycmF5Q2FsYykge1xyXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgc3VtIG9mIHNxdWFyZWQgcmVzaWR1YWxzXHJcblxyXG4gICAgbGV0IG4xID0gcGFyYW1zLm4xLnZhbHVlLFxyXG4gICAgICBJczEgPSBwYXJhbXMuaXMxLnZhbHVlLFxyXG4gICAgICBScCA9IHBhcmFtcy5ycDEudmFsdWUsXHJcbiAgICAgIFJzID0gcGFyYW1zLnJzLnZhbHVlLFxyXG4gICAgICBUID0gcGFyYW1zLnQudmFsdWUsXHJcbiAgICAgIHNpbmdsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW5nbGVEaW9kZScpLmNoZWNrZWQsXHJcbiAgICAgIG4yLCBJczI7XHJcblxyXG4gICAgU3FSZXNTdW0gPSAwO1xyXG5cclxuICAgIGlmIChzaW5nbGUpIHtcclxuICAgICAgLy8gU2luZ2xlIGRpb2RlIG1vZGVsXHJcbiAgICAgIElzMiA9IDA7XHJcbiAgICAgIG4yID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIER1YWwgZGlvZGUgbW9kZWxcclxuICAgICAgSXMyID0gcGFyYW1zLmlzMi52YWx1ZTtcclxuICAgICAgbjIgPSBwYXJhbXMubjIudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXJpZXMnKS5jaGVja2VkKSB7XHJcbiAgICAgIC8vIER1YWwsIHNlcmllcyBkaW9kZSBtb2RlbFxyXG4gICAgICBuMSA9IHBhcmFtcy5uMS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgciwgY2FsY0ksIGogPSAxLCB4MSwgeDIsIHh5MSwgeHkyLCB5MSwgeTIsIHNsb3BlLCB4LFxyXG4gICAgICBjYWxjSVYgPSBhcnJheUNhbGNbMF0sXHJcbiAgICAgIGFycmF5ID0gZGF0YUFycmF5WzBdLFxyXG4gICAgICBkYXRhLFxyXG4gICAgICBkU2RuMSA9IDAsXHJcbiAgICAgIGRTZG4yID0gMCxcclxuICAgICAgZFNkSXMxID0gMCxcclxuICAgICAgZFNkSXMyID0gMCxcclxuICAgICAgZFNkUnAgPSAwLFxyXG4gICAgICBkU2RScyA9IDA7XHJcblxyXG4gICAgbGV0IGRJZG4xLCBkSWRuMiwgZElkSXMxLCBkSWRJczIsIGRJZFJwLCBkSWRScywgZXhwMSwgZXhwMjtcclxuXHJcbiAgICBmb3IgKGxldCByb3cgb2YgYXJyYXkpIHtcclxuICAgICAgLy8gRm9yIGVhY2ggZGF0YSBwb2ludFxyXG4gICAgICB4ID0gcm93WzBdO1xyXG5cclxuICAgICAgd2hpbGUgKHggPiBjYWxjSVZbal1bMF0pIHsgaisrOyB9XHJcbiAgICAgIHh5MSA9IGNhbGNJVltqIC0gMV07XHJcbiAgICAgIHh5MiA9IGNhbGNJVltqXTtcclxuICAgICAgeDEgPSB4eTFbMF07XHJcbiAgICAgIHgyID0geHkyWzBdO1xyXG4gICAgICB5MSA9IHh5MVsxXTtcclxuICAgICAgeTIgPSB4eTJbMV07XHJcbiAgICAgIGRhdGEgPSByb3dbMV07XHJcblxyXG4gICAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgICBzbG9wZSA9ICh5MiAtIHkxKSAvICh4MiAtIHgxKTtcclxuICAgICAgY2FsY0kgPSB5MSArIHNsb3BlICogKHggLSB4MSk7XHJcblxyXG4gICAgICByID0gKGNhbGNJIC0gZGF0YSkgLyBNYXRoLmFicyhkYXRhKTtcclxuXHJcbiAgICAgIGlmIChpc0Zpbml0ZShyKSkge1xyXG4gICAgICAgIGV4cDEgPSBNYXRoLmV4cChxICogKHggLSBScyAqIGNhbGNJKSAvIChuMSAqIGsgKiBUKSk7XHJcbiAgICAgICAgZXhwMiA9IE1hdGguZXhwKHEgKiAoeCAtIFJzICogY2FsY0kpIC8gKG4yICogayAqIFQpKTtcclxuXHJcbiAgICAgICAgZElkbjEgPSBxICogKFJzICogY2FsY0kgLSB4KSAvIChNYXRoLnBvdyhuMSwgMikgKiBrICogVCAqICgxICsgUnMgLyBScCArIHEgKiBJczIgKiBScyAqIGV4cDIgLyAobjIgKiBrICogVCkpIC8gKElzMSAqIGV4cDEpICsgbjEgKiBScyAqIHEpO1xyXG4gICAgICAgIGRTZG4xICs9IDIgKiByICogZElkbjEgLyBNYXRoLmFicyhkYXRhKTtcclxuXHJcbiAgICAgICAgZElkbjIgPSBxICogKFJzICogY2FsY0kgLSB4KSAvIChNYXRoLnBvdyhuMiwgMikgKiBrICogVCAqICgxICsgUnMgLyBScCArIHEgKiBJczEgKiBScyAqIGV4cDEgLyAobjEgKiBrICogVCkpIC8gKElzMiAqIGV4cDIpICsgbjIgKiBScyAqIHEpO1xyXG4gICAgICAgIGRTZG4yICs9IDIgKiByICogZElkbjIgLyBNYXRoLmFicyhkYXRhKTtcclxuXHJcbiAgICAgICAgZElkSXMxID0gKGV4cDEgLSAxKSAvICgxICsgcSAqIElzMSAqIFJzICogZXhwMSAvIChuMSAqIGsgKiBUKSArIHEgKiBJczIgKiBScyAqIGV4cDIgLyAobjIgKiBrICogVCkgKyBScyAvIFJwKTtcclxuICAgICAgICAvL2RJZElzMSA9IChleHAxIC0gMSkgLyAoMSArIHEgKiBJczEgKiBScyAqIGV4cDEgLyAobjEgKiBrICogVCkgKyBScyAvIFJwKTtcclxuICAgICAgICBkU2RJczEgKz0gMiAqIHIgKiBkSWRJczEgLyBNYXRoLmFicyhkYXRhKTtcclxuXHJcbiAgICAgICAgZElkSXMyID0gKGV4cDIgLSAxKSAvICgxICsgcSAqIElzMSAqIFJzICogZXhwMSAvIChuMSAqIGsgKiBUKSArIHEgKiBJczIgKiBScyAqIGV4cDIgLyAobjIgKiBrICogVCkgKyBScyAvIFJwKTtcclxuICAgICAgICBkU2RJczIgKz0gMiAqIHIgKiBkSWRJczIgLyBNYXRoLmFicyhkYXRhKTtcclxuXHJcbiAgICAgICAgZElkUnAgPSAoY2FsY0kgKiBScyAtIHgpIC8gKE1hdGgucG93KFJwLCAyKSAqICgxICsgcSAqIElzMSAqIFJzICogZXhwMSAvIChuMSAqIGsgKiBUKSArIHEgKiBJczIgKiBScyAqIGV4cDIgLyAobjIgKiBrICogVCkgKyBScyAvIFJwKSk7XHJcbiAgICAgICAgZFNkUnAgKz0gMiAqIHIgKiBkSWRScCAvIE1hdGguYWJzKGRhdGEpO1xyXG5cclxuICAgICAgICBkSWRScyA9IC0gY2FsY0kgKiAocSAqIElzMSAqIGV4cDEgLyAobjEgKiBrICogVCkgKyBxICogSXMyICogZXhwMiAvIChuMiAqIGsgKiBUKSArIDEgLyBScCkgLyAoMSArIFJzICogKHEgKiBJczEgKiBleHAxIC8gKG4xICogayAqIFQpICsgcSAqIElzMiAqIGV4cDIgLyAobjIgKiBrICogVCkgKyAxIC8gUnApKTtcclxuICAgICAgICAvL2RJZFJzID0gLSBjYWxjSSAqIChxICogSXMxICogZXhwMSAvIChuMSAqIGsgKiBUKSArIDEgLyBScCkgLyAoMSArIFJzICogKHEgKiBJczEgKiBleHAxIC8gKG4xICogayAqIFQpICsgMSAvIFJwKSk7XHJcbiAgICAgICAgZFNkUnMgKz0gMiAqIHIgKiBkSWRScyAvIE1hdGguYWJzKGRhdGEpO1xyXG5cclxuICAgICAgICBTcVJlc1N1bSArPSBNYXRoLnBvdyhyLCAyKTtcclxuICAgICAgfVxyXG4gICAgICBkZWxTID0gW2RTZG4xLCBkU2RJczEsIGRTZFJwLCBkU2RSc107XHJcbiAgICAgIGlmICghc2luZ2xlKSB7XHJcbiAgICAgICAgZGVsUy5zcGxpY2UoMSwgMCwgZFNkbjIpO1xyXG4gICAgICAgIGRlbFMuc3BsaWNlKDMsIDAsIGRTZElzMik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwbGF5IHJlc2lkdWVcclxuICAgICQoJyNzJykudGV4dChTcVJlc1N1bS50b0V4cG9uZW50aWFsKDIpKTtcclxuXHJcbiAgICByZXR1cm4gU3FSZXNTdW07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXJpdihhcnJheSkge1xyXG4gICAgdmFyIGRlciwgcHJldiwgbmV4dCwgZGVyQXJyYXkgPSBbXSwgc3RyaW5nQXJyYXkgPSAnVlxcdGxuKEkpXFx0ZFtsbihJKV0vZFYnO1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGggLSAxOyBpKyspIHsvL0Rlcml2YXRpdmUgbm90IGNhbGN1bGF0ZWQgZm9yIDFzdCBhbmQgbGFzdCBwb2ludFxyXG4gICAgICBwcmV2ID0gYXJyYXlbaSAtIDFdO1xyXG4gICAgICBuZXh0ID0gYXJyYXlbaSArIDFdO1xyXG4gICAgICBkZXIgPSAobmV4dFsxXSAtIHByZXZbMV0pIC8gKG5leHRbMF0gLSBwcmV2WzBdKTtcclxuICAgICAgZGVyQXJyYXkucHVzaChbYXJyYXlbaV1bMF0sIGRlcl0pO1xyXG4gICAgICBzdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5LmNvbmNhdCgnXFxuJyArIGFycmF5W2ldWzBdICsgJ1xcdCcgKyBhcnJheVtpXVsxXSArICdcXHQnICsgZGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZXJBcnJheTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxuT2ZBcnJheShhcnJheSkge1xyXG4gICAgdmFyIHh5LCB5LCBuZXdBcnJheSA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICB4eSA9IGFycmF5W2ldO1xyXG4gICAgICB5ID0geHlbMV07XHJcbiAgICAgIGlmICh5ICE9IDApIHtcclxuICAgICAgICBuZXdBcnJheS5wdXNoKFt4eVswXSwgTWF0aC5sb2coTWF0aC5hYnMoeSkpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3QXJyYXk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5kRGlvZGVzKHVzZXJEYXRhLCBJcHJTaG93ZWQsIG5vbkxpbmVhckN1cnJlbnRTaG93ZWQpIHtcclxuICAgIGxldCBtb2RpZkRhdGFBcnJheSA9IHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5LFxyXG4gICAgICBzaHVudEN1cnJlbnQgPSB1c2VyRGF0YS5jdXJyZW50LnNodW50O1xyXG5cclxuICAgIGlmIChJcHJTaG93ZWQpIHtcclxuICAgICAgbW9kaWZEYXRhQXJyYXkgPSB0b2dnbGVJcnAobW9kaWZEYXRhQXJyYXksIHNodW50Q3VycmVudCwgZmFsc2UpO1xyXG4gICAgfSAvLyBkaW9kZSBwYXJhbWV0ZXJzIGJldHRlciBldmFsdWF0ZWQgd2hlbiBScCA9IGluZmluaXR5XHJcblxyXG4gICAgaWYgKG5vbkxpbmVhckN1cnJlbnRTaG93ZWQpIHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHRvZ2dsZU5vbkxpbkN1cnIodXNlckRhdGEsIG1vZGlmRGF0YUFycmF5LCBmYWxzZSk7XHJcbiAgICAgIG1vZGlmRGF0YUFycmF5ID0gcmVzdWx0Lm1vZGlmRGF0YUFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBub0lycE5vU0NMQ2FycmF5ID0gbW9kaWZEYXRhQXJyYXlbMF0sXHJcbiAgICAgIGFycmF5ID0gbW9kaWZEYXRhQXJyYXlbMF07XHJcblxyXG4gICAgLy8gMXN0IG9yZGVyIGRlcml2YXRpdmVcclxuICAgIGxldCBhcnJheTEgPSBkZXJpdihsbk9mQXJyYXkoYXJyYXkpKTtcclxuXHJcbiAgICAvLyAybmQgb3JkZXIgZGVyaXZhdGl2ZVxyXG4gICAgYXJyYXkgPSBkZXJpdihhcnJheTEpO1xyXG5cclxuICAgIGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMixcclxuICAgICAgcHJldixcclxuICAgICAgZExuID0gYXJyYXlbaV1bMV0sXHJcbiAgICAgIGRMbk1pbiA9IDAsXHJcbiAgICAgIGRlbHRhTG5NYXggPSAwLFxyXG4gICAgICBqID0gMDtcclxuXHJcbiAgICBsZXQgYXZEZWx0YSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICB2YXIgc3VtID0gMCxcclxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzdW0gKz0gTWF0aC5hYnMoYXJyYXlbaV1bMV0gLSBhcnJheVtpIC0gMV1bMV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzdW0gLyAobGVuZ3RoIC0gMSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGF2RCA9IGF2RGVsdGEoYXJyYXkpO1xyXG5cclxuICAgIHZhciBpTWluID0gaSxcclxuICAgICAgZmx1Y3RJbjJuZEhhbGYgPSBmYWxzZTtcclxuICAgIGRvIHtcclxuICAgICAgaSA9IGlNaW47XHJcbiAgICAgIGRMbiA9IGFycmF5W2ldWzFdO1xyXG4gICAgICB2YXIgbWF4UGFzc2VkID0gZmFsc2U7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICAvLyBMb29raW5nIGZvciBtaW5pbWEgYmV0d2VlbiAwLjA0IFYgYW5kIFZtYXhcclxuICAgICAgICBpLS07XHJcbiAgICAgICAgcHJldiA9IGRMbjtcclxuICAgICAgICBkTG4gPSBhcnJheVtpXVsxXTtcclxuXHJcbiAgICAgICAgZmx1Y3RJbjJuZEhhbGYgKz0gTWF0aC5hYnMoZExuIC0gcHJldikgPiBhdkQgJiYgaSA8IGFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgbWF4UGFzc2VkICs9IHByZXYgPiBkTG4gJiYgTWF0aC5hYnMoZExuIC0gcHJldikgPCBhdkQ7XHJcbiAgICAgICAgdmFyIGNhcnJ5T24gPSAhbWF4UGFzc2VkIHx8IGRMbiA8IHByZXY7XHJcbiAgICAgIH0gd2hpbGUgKGkgPj0gMCAmJiBhcnJheVtpXVswXSA+IDAuMDQgJiYgY2FycnlPbiAmJiAhZmx1Y3RJbjJuZEhhbGYpO1xyXG5cclxuICAgICAgaU1pbiA9IGkgKyAxO1xyXG4gICAgICBkTG5NaW4gPSBwcmV2O1xyXG5cclxuICAgICAgbGV0IGRMbk1heCA9IGRMbk1pbjtcclxuXHJcbiAgICAgIHByZXYgPSAtSW5maW5pdHk7XHJcbiAgICAgIGkgPSBpTWluIC0gMTtcclxuICAgICAgdmFyIGlNYXggPSBpTWluO1xyXG5cclxuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBhcnJheVtpXVswXSA+IDAuMDQpIHtcclxuICAgICAgICAvLyBMb29raW5nIGZvciBhIG1heGltYSBiZXR3ZWVuIDAuMDQgViBhbmQgVm1heFxyXG4gICAgICAgIGRMbiA9IGFycmF5W2ldWzFdO1xyXG5cclxuICAgICAgICBpZiAoZExuIDwgcHJldiAmJiBwcmV2ID4gZExuTWF4ICYmIE1hdGguYWJzKGRMbiAtIHByZXYpIDwgYXZEKSB7XHJcbiAgICAgICAgICBpTWF4ID0gaTtcclxuICAgICAgICAgIGRMbk1heCA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXYgPSBkTG47XHJcbiAgICAgICAgaS0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZExuTWF4IC0gZExuTWluID4gZGVsdGFMbk1heCkge1xyXG4gICAgICAgIGRlbHRhTG5NYXggPSBkTG5NYXggLSBkTG5NaW47XHJcbiAgICAgICAgdmFyIGlNYXhNYXggPSBpTWF4O1xyXG4gICAgICB9XHJcbiAgICAgIGorKztcclxuICAgIH0gd2hpbGUgKGlNYXggIT0gaU1pbiAmJiBqIDwgMTAgJiYgIWZsdWN0SW4ybmRIYWxmKTtcclxuXHJcbiAgICBpZiAoIWlNYXhNYXgpIHtcclxuICAgICAgcmV0dXJuICdub0Rpb2RlJztcclxuICAgIH1cclxuXHJcbiAgICBpID0gaU1heCA9IGlNYXhNYXg7XHJcbiAgICBkTG4gPSBhcnJheVtpXVsxXTtcclxuICAgIGRvIHtcclxuICAgICAgcHJldiA9IGRMbjtcclxuICAgICAgaS0tO1xyXG4gICAgICBkTG4gPSBhcnJheVtpXVsxXTtcclxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGRMbikgPCBNYXRoLmFicyhwcmV2KSB8fCBkTG4gPj0gMCk7XHJcblxyXG4gICAgbGV0IGlEMSA9IGkgKyAyLFxyXG4gICAgICBEMWRMbiA9IGFycmF5MVtpRDEgKyAxXVsxXTtcclxuXHJcbiAgICBpID0gaU1heDtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIHByZXYgPSBkTG47XHJcbiAgICAgIGkrKztcclxuICAgICAgZExuID0gYXJyYXlbaV1bMV07XHJcbiAgICB9IHdoaWxlIChNYXRoLmFicyhkTG4pIDwgTWF0aC5hYnMocHJldikgfHwgZExuID49IDApO1xyXG5cclxuICAgIGxldCBpRDIgPSBpIC0gMSxcclxuICAgICAgRDJkTG4gPSBhcnJheTFbaUQyICsgMV1bMV07XHJcblxyXG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIC0gMjtcclxuXHJcbiAgICBpRDIgPSBsZW5ndGggLSBpRDI7XHJcbiAgICBpRDEgPSBsZW5ndGggLSBpRDE7XHJcblxyXG4gICAgLyogaUQyIChhbmQgaUQxKSBhcmUgdGhlIGluZGV4ZXMgb2YgdGhlIG1heGltYSAoYW5kIG1pbmltYSksIHN0YXJ0aW5nIGZyb20gdGhlICplbmQqIG9mIHRoZSBvcmlnaW5hbCBhcnJheSxcclxuICAgIGluIGNhc2UgcG9pbnRzIGluIHJldmVyc2UgYXJlIG1pc3NpbmcgYWZ0ZXIgcmVtb3ZhbCBvZiBJcnAgYW5kIFNDTEMgKi9cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBub0lycE5vU0NMQ2FycmF5OiBub0lycE5vU0NMQ2FycmF5LFxyXG4gICAgICBkaW9kZXM6IFtEMmRMbiwgRDFkTG4sIGlEMiwgaUQxXVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVzdGltRDFEMlJzKHBhcmFtcywgdXNlckRhdGEsIGZpbmREaW9kZXNSZXN1bHQpIHtcclxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VyaWVzJykuY2hlY2tlZCkge1xyXG4gICAgICAvLyBGb3Igbm93LCBubyBlc3RpbWF0aW9uIGZvciBzZXJpZXMgbW9kZWxcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhcmFtVmFsdWVzID0gcGFyYW1zLnZhbHVlLFxyXG4gICAgICBwYXJhbUNoZWNrZWQgPSBwYXJhbXMuY2hlY2tlZDtcclxuXHJcbiAgICBsZXQgbWF4bWluID0gZmluZERpb2Rlc1Jlc3VsdC5kaW9kZXM7XHJcblxyXG4gICAgaWYgKG1heG1pbiA9PT0gJ25vRGlvZGUnKSB7XHJcbiAgICAgIC8vIFRPRE86IERpc3BsYXkgbWVzc2FnZVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGR1YWxEaW9kZSA9ICFkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2luZ2xlRGlvZGUnKS5jaGVja2VkLFxyXG4gICAgICBhcnJheSA9IGZpbmREaW9kZXNSZXN1bHQubm9JcnBOb1NDTENhcnJheSxcclxuXHJcbiAgICAgIEQxZExuID0gbWF4bWluWzFdLFxyXG4gICAgICBEMmRMbiA9IG1heG1pblswXSxcclxuICAgICAgVklBdGQxID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gNCAtIG1heG1pblszXV0sXHJcbiAgICAgIFZJQXRkMiA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDQgLSBtYXhtaW5bMl1dLFxyXG4gICAgICBUID0gcGFyYW1WYWx1ZXMudCxcclxuICAgICAgQSA9IHEgLyAoayAqIFQpLFxyXG4gICAgICBuMiA9IEEgLyBEMmRMbixcclxuICAgICAgbiwgbjEsIElzMSwgUnMsIElzMjtcclxuXHJcbiAgICBpZiAoZHVhbERpb2RlKSB7XHJcbiAgICAgIGlmIChwYXJhbUNoZWNrZWQubjIpIHtcclxuICAgICAgICBuID0gbjI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IG4yID0gcGFyYW1WYWx1ZXMubjI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcmFtQ2hlY2tlZC5uMSkge1xyXG4gICAgICAgIG4xID0gQSAvIEQxZExuO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4xID0gcGFyYW1WYWx1ZXMubjE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcmFtQ2hlY2tlZC5pczEpIHtcclxuICAgICAgICBJczEgPSBWSUF0ZDFbMV0gLyAoTWF0aC5leHAoKFZJQXRkMVswXSAqIEEgLyBuMSkgLSAxKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgSXMxID0gcGFyYW1WYWx1ZXMuaXMxO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTaW5nbGUgZGlvZGVcclxuICAgICAgbiA9IG4yO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbUNoZWNrZWQucnMpIHtcclxuICAgICAgUnMgPSBlc3RpbVJzKGFycmF5LCBULCBuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJzID0gcGFyYW1WYWx1ZXMucnM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhcmFtQ2hlY2tlZC5pczIpIHtcclxuICAgICAgSXMyID0gVklBdGQyWzFdIC8gKE1hdGguZXhwKChWSUF0ZDJbMF0gLSBWSUF0ZDJbMV0gKiBScykgKiBBIC8gbjIpIC0gMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBJczIgPSBwYXJhbVZhbHVlcy5pczI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG5ld1JwO1xyXG5cclxuICAgIGlmIChwYXJhbUNoZWNrZWQucnAxKSB7XHJcbiAgICAgIG5ld1JwID0gdXNlckRhdGEuZXN0aW1hdGVkUGFyYW1ldGVycy5ScDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ld1JwID0gcGFyYW1WYWx1ZXMucnAxO1xyXG4gICAgfVxyXG5cclxuICAgICQoJ3RkLmVzdGltYXRpb24jcnAxJykudGV4dChuZXdScC50b1ByZWNpc2lvbigzKSk7XHJcbiAgICAkKCd0ZC5lc3RpbWF0aW9uI3JzJykudGV4dChScy50b1ByZWNpc2lvbigyKSk7XHJcblxyXG4gICAgaWYgKGR1YWxEaW9kZSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG4xOiBuMSxcclxuICAgICAgICBuMjogbjIsXHJcbiAgICAgICAgSXMxOiBJczEsXHJcbiAgICAgICAgSXMyOiBJczIsXHJcbiAgICAgICAgUnAxOiBuZXdScCxcclxuICAgICAgICBSczogUnNcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbjE6IG4yLFxyXG4gICAgICAgIElzMTogSXMyLFxyXG4gICAgICAgIFJwMTogbmV3UnAsXHJcbiAgICAgICAgUnM6IFJzXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlc3RpbVJzKGFycmF5LCBULCBuKSB7XHJcbiAgICB2YXIgZElkViA9IGRlcml2KGFycmF5KSxcclxuICAgICAgaSA9IGFycmF5Lmxlbmd0aCAtIDIsXHJcbiAgICAgIGRJZFZhdGkgPSBkSWRWW2kgLSAxXVsxXSxcclxuICAgICAgZXhwLFxyXG4gICAgICBBID0gcSAvIChuICogayAqIFQpLFxyXG4gICAgICBCLCBDLFxyXG4gICAgICBJVmF0aSA9IGFycmF5W2ldLFxyXG4gICAgICBJID0gSVZhdGlbMV0sXHJcbiAgICAgIFYgPSBJVmF0aVswXSxcclxuICAgICAgUnMgPSAwO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgZXhwID0gTWF0aC5leHAoQSAqIChWIC0gSSAqIFJzKSk7XHJcbiAgICAgIEIgPSBBICogZXhwIC8gKGV4cCAtIDEpO1xyXG4gICAgICBDID0gQiAvICgxIC8gSSArIFJzICogQik7XHJcbiAgICAgIFJzICs9IDAuMDE7XHJcbiAgICB9IHdoaWxlIChDID4gZElkVmF0aSk7XHJcblxyXG4gICAgcmV0dXJuIFJzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlUGFyYW1zKHBhcmFtcywgcGxvdCwgdXBkYXRlUmFuZ2VJbnB1dCkge1xyXG4gICAgLy8gVXBkYXRlIG51bWJlciBpbnB1dCBhbmQgcmVzdWx0IHRhYmxlXHJcblxyXG4gICAgaWYgKHVwZGF0ZVJhbmdlSW5wdXQpIHtcclxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgICAgIGV2dC5pbml0RXZlbnQoJ2NoYW5nZScsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgcGFyYW0gb2YgcGFyYW1zKSB7XHJcbiAgICAgIGNvbnN0IGlkID0gcGFyYW1bMF0sXHJcbiAgICAgICAgdmFsdWUgPSBwYXJhbVsxXTtcclxuXHJcbiAgICAgIGxldCBlbGVtZW50ID0gJCgnW3R5cGU9bnVtYmVyXS4nICsgaWQpLmdldCgwKTtcclxuXHJcbiAgICAgIGlmICh1cGRhdGVSYW5nZUlucHV0KSB7XHJcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0ICR0ZCA9ICQoJ3RkI2ZpbmFsLScgKyBpZCksXHJcbiAgICAgICAgaXNTY2FsZUxvZyA9ICQoZWxlbWVudCkuaGFzQ2xhc3MoJ2xvZ3NjYWxlJyksXHJcbiAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSAoaXNTY2FsZUxvZykgPyB2YWx1ZS50b0V4cG9uZW50aWFsKDIpIDogdmFsdWUudG9QcmVjaXNpb24oMik7XHJcblxyXG4gICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICR0ZFxyXG4gICAgICAgIC50ZXh0KGZvcm1hdHRlZFZhbHVlKTtcclxuXHJcbiAgICAgIHBhcmFtZXRlcnMudXBkYXRlKCQoZWxlbWVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGl2UmVzdWx0ID0gY2FsY0lWKHBhcmFtZXRlcnMsIGdldE1vZGVsKCkpO1xyXG5cclxuICAgIGFycmF5Q2FsYyA9IGl2UmVzdWx0LmFycmF5Q2FsYztcclxuICAgIHBsb3RTdHlsZSA9IGl2UmVzdWx0LnBsb3RTdHlsZTtcclxuXHJcbiAgICBjYWxjU3FSZXNTdW0ocGFyYW1ldGVycywgdXNlckRhdGEuZGF0YUFycmF5LCBhcnJheUNhbGMpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmFyeSgpIHtcclxuICAgIC8vIFZhcmllcyBjaGVja2VkIGRpb2RlIHBhcmFtZXRlcnMgdW50aWxcclxuICAgIC8vIHN1bSBvZiBzcXVhcmUgcmVzaWR1YWxzIGlzIG1pbmltaXplZFxyXG5cclxuICAgIGNvbnN0IGVwcyA9IG1jaEVwcztcclxuXHJcbiAgICB2YXIgbjEgPSBwYXJhbWV0ZXJzLm4xLnZhbHVlLFxyXG4gICAgICBuMXZhcnkgPSBwYXJhbWV0ZXJzLm4xLmNoZWNrZWQsXHJcbiAgICAgIElzMSA9IHBhcmFtZXRlcnMuaXMxLnZhbHVlLFxyXG4gICAgICBJczF2YXJ5ID0gcGFyYW1ldGVycy5pczEuY2hlY2tlZCxcclxuICAgICAgUnAgPSBwYXJhbWV0ZXJzLnJwMS52YWx1ZSxcclxuICAgICAgUnB2YXJ5ID0gcGFyYW1ldGVycy5ycDEuY2hlY2tlZCxcclxuICAgICAgUnMgPSBwYXJhbWV0ZXJzLnJzLnZhbHVlLFxyXG4gICAgICBSc3ZhcnkgPSBwYXJhbWV0ZXJzLnJzLmNoZWNrZWQ7XHJcblxyXG4gICAgLy8gU2luZ2xlIGRpb2RlIG1vZGVsXHJcbiAgICBsZXQgcGFyYW1zID0gW1xyXG4gICAgICBbJ24xJywgbjEsIGVwcywgbjF2YXJ5XSxcclxuICAgICAgWydpczEnLCBJczEsIGVwcywgSXMxdmFyeV0sXHJcbiAgICAgIFsncnAxJywgUnAsIGVwcywgUnB2YXJ5XSxcclxuICAgICAgWydycycsIFJzLCBlcHMsIFJzdmFyeV1cclxuICAgIF07XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkb3VibGVEaW9kZScpLmNoZWNrZWQpIHtcclxuICAgICAgLy8gRHVhbCBkaW9kZSBtb2RlbFxyXG4gICAgICB2YXIgSXMyID0gcGFyYW1ldGVycy5pczIudmFsdWUsXHJcbiAgICAgICAgSXMydmFyeSA9IHBhcmFtZXRlcnMuaXMyLmNoZWNrZWQsXHJcbiAgICAgICAgbjIgPSBwYXJhbWV0ZXJzLm4yLnZhbHVlLFxyXG4gICAgICAgIG4ydmFyeSA9IHBhcmFtZXRlcnMubjIuY2hlY2tlZDtcclxuICAgICAgcGFyYW1zID0gW1snbjEnLCBuMSwgZXBzLCBuMXZhcnldLCBbJ24yJywgbjIsIGVwcywgbjJ2YXJ5XSwgWydpczEnLCBJczEsIGVwcywgSXMxdmFyeV0sIFsnaXMyJywgSXMyLCBlcHMsIElzMnZhcnldLCBbJ3JwMScsIFJwLCBlcHMsIFJwdmFyeV0sIFsncnMnLCBScywgZXBzLCBSc3ZhcnldXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVsLFxyXG4gICAgICBTLFxyXG4gICAgICBuZXdQYXIsXHJcbiAgICAgIGogPSAwLFxyXG4gICAgICBpaSA9IDAsXHJcbiAgICAgIHNpZ24sXHJcbiAgICAgIHN0b3AgPSBmYWxzZTtcclxuXHJcbiAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKFxyXG4gICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgUyA9IFNxUmVzU3VtO1xyXG4gICAgICAgIHZhciBuZXdQYXJzID0gW107XHJcbiAgICAgICAgLy9kZWwgPSBkZWxTO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocGFyYW1zW2ldWzNdKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgcGFyYW1ldGVyIGlzIGFsbG93ZWQgdG8gdmFyeVxyXG4gICAgICAgICAgICBkZWwgPSBkZWxTW2ldO1xyXG4gICAgICAgICAgICBzaWduID0gZGVsIC8gTWF0aC5hYnMoZGVsKTtcclxuXHJcbiAgICAgICAgICAgIG5ld1BhciA9IHBhcmFtc1tpXVsxXSAqIE1hdGgucG93KCgxICsgcGFyYW1zW2ldWzJdKSwgLXNpZ24pOyAvL3VwZGF0ZSBwYXJhbWV0ZXJcclxuXHJcbiAgICAgICAgICAgIHVwZGF0ZVBhcmFtcyhbW3BhcmFtc1tpXVswXSwgbmV3UGFyXV0sIGZhbHNlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGRlbCAvIE1hdGguYWJzKGRlbCkgIT0gZGVsU1tpXSAvIE1hdGguYWJzKGRlbFNbaV0pICYmIGogPCAxMDAgJiYgbmV3UGFyICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgcGFyYW1zW2ldWzJdIC89IDI7XHJcbiAgICAgICAgICAgICAgbmV3UGFyID0gcGFyYW1zW2ldWzFdICogTWF0aC5wb3coKDEgKyBwYXJhbXNbaV1bMl0pLCAtc2lnbik7IC8vdXBkYXRlIHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgIHVwZGF0ZVBhcmFtcyhbW3BhcmFtc1tpXVswXSwgbmV3UGFyXV0sIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgamogPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoZGVsIC8gTWF0aC5hYnMoZGVsKSA9PSBkZWxTW2ldIC8gTWF0aC5hYnMoZGVsU1tpXSkgJiYgamogPCAxMDAgJiYgbmV3UGFyICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgcGFyYW1zW2ldWzJdICo9IDI7XHJcbiAgICAgICAgICAgICAgbmV3UGFyID0gcGFyYW1zW2ldWzFdICogTWF0aC5wb3coKDEgKyBwYXJhbXNbaV1bMl0pLCAtc2lnbik7IC8vdXBkYXRlIHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgIHVwZGF0ZVBhcmFtcyhbW3BhcmFtc1tpXVswXSwgbmV3UGFyXV0sIGZhbHNlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgIGpqKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyYW1zW2ldWzFdID0gbmV3UGFyO1xyXG4gICAgICAgICAgICBuZXdQYXJzLnB1c2gobmV3UGFyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc05hTihuZXdQYXIpKSB7XHJcbiAgICAgICAgICAgICAgc3RvcCArPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpaSsrO1xyXG5cclxuICAgICAgICBjb25zdCBkUyA9IFNxUmVzU3VtIC0gUztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBTID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgJCgnI2RzJykudGV4dChkUy50b0V4cG9uZW50aWFsKDIpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnI2RzJykuZW1wdHkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aHJlc2hvbGQnKS52YWx1ZSxcclxuICAgICAgICAgIGZpdFN1Y2Nlc3NmdWwgPSBNYXRoLmFicyhkUykgPCB0aHJlc2hvbGQ7XHJcblxyXG4gICAgICAgIGlmIChmaXRTdWNjZXNzZnVsIHx8IGlpID4gMTAwMCB8fCBzdG9wKSB7XHJcbiAgICAgICAgICBpZiAoZml0U3VjY2Vzc2Z1bCkge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRDb250ZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGFibGVTdWNjZXNzQ29udGV4dChhZGRDb250ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRvZ2dsZVBsYXlCdXR0b24oKTtcclxuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgICBzdGFydFBhdXNlVmFyeShzdGFydCk7XHJcblxyXG4gICAgICAgICAgLy8gU3luYyBudW1iZXIgYW5kIHJhbmdlIGlucHV0c1xyXG4gICAgICAgICAgc3luY0FsbElucHV0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9jdW1lbnQud2Via2l0SGlkZGVuKSB7XHJcbiAgICAgICAgICAvLyBObyB1c2UgdG8gcGxvdDogdGhlIHBhZ2UgaXMgbm90IHZpc2libGUgKFdlYmtpdCBvbmx5KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb21iRGF0YUFuZENhbGMoLyphcnJheUNhbGMsIHBsb3RTdHlsZSwgc2NhbGUqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgICwgMSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdGFydFBhdXNlVmFyeShzdGFydCkge1xyXG4gICAgLy8gc3RhcnQgcGFyYW1ldGVyIGlzIGEgYm9vbGVhblxyXG5cclxuICAgIGlmIChzdGFydCA9PT0gdHJ1ZSkge1xyXG4gICAgICBjb25zdCBhZGRDb250ZXh0ID0gZmFsc2U7XHJcbiAgICAgIHRhYmxlU3VjY2Vzc0NvbnRleHQoYWRkQ29udGV4dCk7XHJcbiAgICAgIHZhcnkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHt9O1xyXG59KSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);