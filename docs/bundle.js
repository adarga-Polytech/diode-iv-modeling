/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"assets/samplefiles/T279K.txt\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2FtcGxlZmlsZXMvVDI3OUsudHh0P2VjZmMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL3NhbXBsZWZpbGVzL1QyNzlLLnR4dFwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fzc2V0cy9zYW1wbGVmaWxlcy9UMjc5Sy50eHRcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"index.html\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5odG1sPzhiZTkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW5kZXguaHRtbFwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(6)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./index.css\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./index.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5jc3M/Y2I3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = drawGraph;\n/* This file takes care of plotting the result in a graph.\r\n * I wrote this back when I was learning JavaScript and haven't\r\n * touched it since then (besides linting).\r\n * At the time, I could not find a plotting library that would\r\n * render scientific graphs that could be used directly in a\r\n * publication.\r\n * Also I thought it was a good exercice to code this myself.\r\n */\r\n\r\nfunction changePrecision(precision, number) {\r\n  return Math.round(number * Math.pow(10, precision)) / Math.pow(10, precision);\r\n}\r\n\r\n// returns the min value of an array\r\nfunction min(array) {\r\n  var min = '+Infinity',\r\n    element;\r\n\r\n  for (var i = 1; i < array.length; i++) {\r\n    element = array[i];\r\n    if (element < min && element != '-Infinity') {\r\n      min = element;\r\n\r\n    }\r\n  }\r\n  //alert(min);\r\n  return min;\r\n}\r\n\r\n// returns the max value of an array\r\nfunction max(array) {\r\n  var max;\r\n  for (var i = 0; i < array.length; i++) {\r\n    if (!max || array[i] > max) {\r\n      max = array[i];\r\n    }\r\n  }\r\n  return max;\r\n}\r\n\r\nfunction orderOfMagn(value) {\r\n  return Math.pow(10, Math.floor(log10(Math.abs(value))));\r\n}\r\n\r\nfunction log10(val) {\r\n  return Math.log(val) / Math.log(10);\r\n}\r\n\r\nlet array;\r\n\r\nfunction drawGraph(canvasId, arrayMult, focusedPlot, plotStyle, scaleType, xTitle, yTitle) {\r\n\r\n  //array will be used to build the graph area, max and min, distance between 2 ticks etc.\r\n  array = arrayMult[focusedPlot];\r\n  var xArray = [],\r\n    yArray = [],\r\n    y, xy;\r\n\r\n  for (var i = 0; i <= array.length - 1; i++) {\r\n    xy = array[i];\r\n    y = xy[1];\r\n    if (scaleType == 'logScale') {\r\n      if (y != 0) { //when scale is Log, don't include the points for which y = 0\r\n        xArray.push(xy[0]);\r\n        yArray.push(log10(Math.abs(y)));\r\n      }\r\n    } else {\r\n      xArray.push(xy[0]);\r\n      yArray.push(y);\r\n    }\r\n  }\r\n\r\n  var yMin = min(yArray);\r\n\r\n  if (scaleType == 'logScale' && yMin < -15) {\r\n    var index = yArray.indexOf(yMin);\r\n    xArray.splice(index, 1);\r\n    yArray.splice(index, 1);\r\n  }\r\n\r\n  var xMin = min(xArray),\r\n    xMax = max(xArray);\r\n  yMin = min(yArray);\r\n  var yMax = max(yArray),\r\n\r\n    //alert(xMin);\r\n    xyStep = calcStep(xMin, xMax, yMin, yMax),\r\n    xStep = xyStep[0],\r\n    yStep = xyStep[1],\r\n\r\n    axesMaxMin = calcAxesMaxMin(xMin, xMax, xStep, yMin, yMax, yStep),\r\n    xAxisMin = axesMaxMin[0],\r\n    xAxisMax = axesMaxMin[1],\r\n    yAxisMin = axesMaxMin[2],\r\n    yAxisMax = axesMaxMin[3],\r\n\r\n    canvas = document.getElementById(canvasId),\r\n    context = canvas.getContext('2d'),\r\n    canvasWidth = canvas.width,\r\n    canvasHeight = canvas.height,\r\n    margin = 40.5,\r\n    unitPx = calcUnitPx(xAxisMin, xAxisMax, canvasWidth, yAxisMin, yAxisMax, canvasHeight, margin),\r\n    xUnitPx = unitPx[0],\r\n    yUnitPx = unitPx[1];\r\n\r\n  canvas.height = canvasHeight; //clears the canvas\r\n\r\n  var axesPosition = drawAxis(context, scaleType, margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, xTitle, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yTitle),\r\n    xAxisPosition = axesPosition[0],\r\n    xTicksSide = axesPosition[1] / Math.abs(axesPosition[1]),\r\n    yAxisPosition = axesPosition[2],\r\n    yTicksSide = axesPosition[3] / Math.abs(axesPosition[3]);\r\n\r\n  drawTicks(context, scaleType, margin, xAxisMin, xAxisMax, xStep, canvasWidth, xUnitPx, xAxisPosition, xTicksSide, yAxisMin, yAxisMax, yStep, canvasHeight, yUnitPx, yAxisPosition, yTicksSide);\r\n\r\n  legend(context, scaleType, arrayMult, plotStyle, margin, xAxisMin, xUnitPx, yAxisMin, yUnitPx, canvasHeight);\r\n\r\n  for (var i = 0; i < arrayMult.length; i++) {\r\n    plot(arrayMult[i], context, scaleType, plotStyle[i], margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yAxisPosition);\r\n  }\r\n}\r\n\r\nfunction calcStep(xMin, xMax, yMin, yMax) {\r\n\r\n  var oOfMagn = orderOfMagn(xMax - xMin),\r\n    xStep = oOfMagn * 0.2,\r\n    xAxisMax,\r\n    xAxisMin;\r\n\r\n  if (xMax - xMin > oOfMagn * 4 / 3) {\r\n    xStep = oOfMagn * 0.5;\r\n  }\r\n  if (xMax - xMin > oOfMagn * 10 / 3) {\r\n    xStep = oOfMagn;\r\n  }\r\n  if (xMax - xMin > oOfMagn * 20 / 3) {\r\n    xStep = oOfMagn * 2;\r\n  }\r\n\r\n  oOfMagn = orderOfMagn(yMax - yMin);\r\n  var yStep = oOfMagn * 0.2,\r\n    yAxisMax,\r\n    yAxisMin;\r\n\r\n  if (yMax - yMin > oOfMagn * 4 / 3) {\r\n    yStep = oOfMagn * 0.5;\r\n  }\r\n  if (yMax - yMin > oOfMagn * 10 / 3) {\r\n    yStep = oOfMagn;\r\n  }\r\n  if (yMax - yMin > oOfMagn * 20 / 3) {\r\n    yStep = oOfMagn * 2;\r\n  }\r\n\r\n  return [xStep, yStep];\r\n}\r\n\r\nfunction calcAxesMaxMin(xMin, xMax, xStep, yMin, yMax, yStep) {\r\n\r\n  var min = [xMin, yMin],\r\n    max = [xMax, yMax],\r\n    step = [xStep, yStep],\r\n    axisMin = [0, 0],\r\n    axisMax = [0, 0];\r\n\r\n  for (var i = 0; i <= 1; i++) {\r\n    if (min[i] <= 0) {\r\n      while (axisMin[i] >= min[i]) {\r\n        axisMin[i] = axisMin[i] - step[i];\r\n      }\r\n      axisMax[i] = axisMin[i];\r\n      while (axisMax[i] <= max[i]) {\r\n        axisMax[i] = axisMax[i] + step[i];\r\n      }\r\n    } else {\r\n      while (axisMax[i] <= max[i]) {\r\n        axisMax[i] = axisMax[i] + step[i];\r\n      }\r\n      axisMin[i] = axisMax[i];\r\n      while (axisMin[i] >= min[i]) {\r\n        axisMin[i] = axisMin[i] - step[i];\r\n      }\r\n    }\r\n  }\r\n  return [axisMin[0], axisMax[0], axisMin[1], axisMax[1]];\r\n}\r\n\r\nfunction calcUnitPx(xAxisMin, xAxisMax, canvasWidth, yAxisMin, yAxisMax, canvasHeight, margin) {\r\n  var xUnitPx = (canvasWidth - 2 * margin) / (xAxisMax - xAxisMin),\r\n    yUnitPx = (canvasHeight - 2 * margin) / (yAxisMax - yAxisMin);\r\n\r\n  return [xUnitPx, yUnitPx];\r\n}\r\n\r\nfunction xDataToCanvas(value, margin, unitPx) {\r\n  return margin + Math.floor(value * unitPx);\r\n}\r\n\r\nfunction yDataToCanvas(value, margin, unitPx, canvasHeight) {\r\n  return canvasHeight - margin - Math.floor(value * unitPx);\r\n}\r\n\r\nfunction drawAxis(context, type, margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, xTitle, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yTitle) {\r\n  context.font = '10px Arial';\r\n  context.strokeStyle = 'black';\r\n  context.lineWidth = 1;\r\n  var yAxisPosition,\r\n    xAxisPosition,\r\n    yTitlePosition,\r\n    xTitlePosition,\r\n    yTitleSide,\r\n    xTitleSide;\r\n\r\n  //determine yAxis position\r\n  if (xAxisMin <= 0 && xAxisMax >= 0) { yAxisPosition = 0; }\r\n  else {\r\n    if (xAxisMin > 0) { yAxisPosition = xAxisMin; }\r\n    else { yAxisPosition = xAxisMax; }\r\n  }\r\n\r\n  //draw y Axis\r\n  context.beginPath(); // prevents weird behavior with IE9\r\n  context.moveTo(Math.floor((yAxisPosition - xAxisMin) * xUnitPx) + margin, canvasHeight - margin);\r\n  context.lineTo(Math.floor((yAxisPosition - xAxisMin) * xUnitPx) + margin, margin);\r\n\r\n  //determine x title position and y title's side\r\n  if (xAxisMax - yAxisPosition >= yAxisPosition - xAxisMin) { xTitlePosition = (xAxisMax + yAxisPosition) / 2; yTitleSide = -30; }\r\n  else { xTitlePosition = (yAxisPosition + xAxisMin) / 2; yTitleSide = +30; }\r\n  //alert(xTitlePosition);\r\n\r\n  //determine xAxis position\r\n  if (yAxisMin <= 0 && yAxisMax >= 0 && type == 'linearScale') { xAxisPosition = 0; }\r\n  else {\r\n    if (yAxisMin > 0 || type == 'logScale') { xAxisPosition = yAxisMin; }\r\n    else { xAxisPosition = yAxisMax; }\r\n  }\r\n\r\n  //draw x Axis\r\n\r\n  context.moveTo(margin, canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx));\r\n  context.lineTo(canvasWidth - margin, canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx));\r\n\r\n  //determine y title position and x title's side\r\n  if (yAxisMax - xAxisPosition >= xAxisPosition - yAxisMin) { yTitlePosition = (yAxisMax + xAxisPosition) / 2; xTitleSide = 25; }\r\n  else { yTitlePosition = (xAxisPosition + yAxisMin) / 2; xTitleSide = -25; }\r\n\r\n  //write x title\r\n  context.textAlign = 'center';\r\n  if (xTitleSide > 0) { context.textBaseline = 'top'; }\r\n  else { context.textBaseline = 'bottom'; }\r\n  context.fillText(xTitle, margin + Math.floor((xTitlePosition - xAxisMin) * xUnitPx), canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx) + xTitleSide);\r\n\r\n  //write y title\r\n  context.rotate(-Math.PI / 2); //rotate the whole canvas to write y title vertically\r\n  context.textAlign = 'center';\r\n  if (yTitleSide > 0) { context.textBaseline = 'top'; }\r\n  else { context.textBaseline = 'bottom'; }\r\n\r\n  var x = margin + Math.floor((yAxisPosition - xAxisMin) * xUnitPx) + yTitleSide,\r\n    y = canvasHeight - margin - Math.floor((yTitlePosition - yAxisMin) * yUnitPx);\r\n  context.fillText(yTitle, -y, x);\r\n  context.rotate(Math.PI / 2);\r\n\r\n\r\n  return [xAxisPosition, xTitleSide, yAxisPosition, yTitleSide];\r\n}\r\n\r\nfunction drawTicks(context, type, margin, xAxisMin, xAxisMax, xStep, canvasWidth, xUnitPx, xAxisPosition, xTicksSide, yAxisMin, yAxisMax, yStep, canvasHeight, yUnitPx, yAxisPosition, yTicksSide) {\r\n  var xPx,\r\n    yPx,\r\n    tickLabel;\r\n\r\n  //x Axis\r\n  context.textAlign = 'center';\r\n  if (xTicksSide > 0) { context.textBaseline = 'top'; }\r\n  else { context.textBaseline = 'bottom'; }\r\n\r\n  //major ticks\r\n  for (var x = xAxisMin; x <= xAxisMax; x += xStep) {\r\n    xPx = margin + Math.floor((x - xAxisMin) * xUnitPx);\r\n    yPx = canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx);\r\n    context.moveTo(xPx, yPx);\r\n    context.lineTo(xPx, yPx + 2 * xTicksSide);\r\n\r\n    if (x == xAxisPosition && xAxisPosition != yAxisMin && xAxisPosition != yAxisMax) {\r\n      xPx = xPx - 10 * yTicksSide;\r\n    } //avoids the messy zero labels at the axes' intersections\r\n    tickLabel = changePrecision(7, x);\r\n    context.fillText(tickLabel, xPx, yPx + 5 * xTicksSide); //tick label\r\n  }\r\n\r\n  //minor ticks\r\n  for (var x = xAxisMin; x < xAxisMax; x += xStep / 2) {\r\n    xPx = margin + Math.floor((x - xAxisMin) * xUnitPx);\r\n    yPx = canvasHeight - margin - Math.floor((xAxisPosition - yAxisMin) * yUnitPx);\r\n    context.moveTo(xPx, yPx);\r\n    context.lineTo(xPx, yPx + 1 * xTicksSide);\r\n  }\r\n\r\n  //y Axis\r\n  context.textBaseline = 'middle';\r\n  if (yTicksSide > 0) { context.textAlign = 'left'; }\r\n  else { context.textAlign = 'right'; }\r\n  //major ticks\r\n  for (var y = yAxisMin; y <= yAxisMax; y += yStep) {\r\n    yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n    xPx = margin + Math.floor((yAxisPosition - xAxisMin) * xUnitPx);\r\n    context.moveTo(xPx, yPx);\r\n    context.lineTo(xPx + 2 * yTicksSide, yPx);\r\n\r\n    if (type == 'logScale' && y < yAxisMax) {\r\n      for (var j = 1; j <= 10; j++) {\r\n        var yMinor = Math.floor(yPx - yStep * yUnitPx * log10(j / 10) - yStep * yUnitPx) + 0.5;\r\n\r\n        context.moveTo(xPx, yMinor);\r\n        context.lineTo(xPx + 1 * yTicksSide, yMinor);\r\n      }\r\n    }\r\n    tickLabel = changePrecision(7, y);\r\n    if (type == 'logScale') {\r\n      tickLabel = '1E' + y;\r\n    }\r\n    if (y == xAxisPosition && yAxisPosition != xAxisMin && yAxisPosition != xAxisMax) {\r\n      yPx = yPx - 10 * xTicksSide;\r\n    } //avoids the messy labels at the axes' intersections\r\n    context.fillText(tickLabel, xPx + 5 * yTicksSide, yPx); //tick label\r\n  }\r\n  //minor ticks\r\n  if (type == 'linearScale') {\r\n    for (var y = yAxisMin; y < yAxisMax; y += yStep / 2) {\r\n\r\n      yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n      xPx = margin + Math.floor((yAxisPosition - xAxisMin) * xUnitPx);\r\n\r\n      context.moveTo(xPx, yPx);\r\n      context.lineTo(xPx + 1 * yTicksSide, yPx);\r\n    }\r\n  }\r\n  context.stroke();\r\n}\r\n\r\nfunction legend(context, type, arrayMult, plotStyle, margin, xAxisMin, xUnitPx, yAxisMin, yUnitPx, canvasHeight) {\r\n  context.textBaseline = 'middle';\r\n  context.textAlign = 'left';\r\n  var x, y, xPx, yPx = '+Infinity', index, xy, array = [];\r\n  for (var i = 0; i < arrayMult.length; i++) {\r\n    array = arrayMult[i];\r\n    index = array.length - 1;//last point\r\n    xy = array[index];\r\n    x = xy[0];\r\n    y = xy[1];\r\n\r\n    xPx = 10 + margin + Math.floor((x - xAxisMin) * xUnitPx);\r\n    if (type == 'logScale') { y = log10(Math.abs(y)); }\r\n    if (isFinite(y)) {\r\n      yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n      context.fillStyle = plotStyle[i][1]; //color\r\n      context.fillText(plotStyle[i][2], xPx, yPx);\r\n    }\r\n  }\r\n}\r\n\r\nfunction plot(array, context, type, plotStyle, margin, xAxisMin, xAxisMax, canvasWidth, xUnitPx, yAxisMin, yAxisMax, canvasHeight, yUnitPx, yAxisPosition) {\r\n  var xPx, yPx, y, j = 0;\r\n  context.strokeStyle = plotStyle[1];\r\n  for (var i = 0; i < array.length; i++) { //one loop for each data point\r\n    xPx = margin + Math.floor((array[i][0] - xAxisMin) * xUnitPx);\r\n    y = (array[i][1]);\r\n    if (type == 'logScale') {\r\n      y = log10(Math.abs(y));\r\n    }\r\n    if (y != '-Infinity') {//y = '-Infinity' when y = 0 and scale is Log\r\n      yPx = canvasHeight - margin - Math.floor((y - yAxisMin) * yUnitPx);\r\n      switch (plotStyle[0]) {\r\n        case 'line': {\r\n          if (j == 0) { // j==0 <=> 1st plotted point, not necessarily 1st point in the array \r\n            context.beginPath();\r\n            context.moveTo(xPx, yPx);\r\n          }\r\n          context.lineTo(xPx, yPx);\r\n          break;\r\n        }\r\n        case 'circles': {\r\n          context.beginPath();\r\n          context.arc(xPx, yPx, 3, 0, 2 * Math.PI);\r\n          context.stroke();\r\n          break;\r\n        }\r\n        case 'diagonalCross': {\r\n          context.beginPath();\r\n          context.moveTo(xPx - 2, yPx - 2);\r\n          context.lineTo(xPx + 2, yPx + 2);\r\n          context.moveTo(xPx + 2, yPx - 2);\r\n          context.lineTo(xPx - 2, yPx + 2);\r\n          context.stroke();\r\n          break;\r\n        }\r\n        case 'verticalCross': {\r\n          context.beginPath();\r\n          context.moveTo(xPx, yPx - 2);\r\n          context.lineTo(xPx, yPx + 2);\r\n          context.moveTo(xPx + 2, yPx);\r\n          context.lineTo(xPx - 2, yPx);\r\n          context.stroke();\r\n          break;\r\n        }\r\n      }\r\n      j++;\r\n    }\r\n  }\r\n  if (plotStyle[0] == 'line') { context.stroke(); }\r\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hc3NldHMvanMvYm9iR3JhcGguanM/NjZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGlzIGZpbGUgdGFrZXMgY2FyZSBvZiBwbG90dGluZyB0aGUgcmVzdWx0IGluIGEgZ3JhcGguXHJcbiAqIEkgd3JvdGUgdGhpcyBiYWNrIHdoZW4gSSB3YXMgbGVhcm5pbmcgSmF2YVNjcmlwdCBhbmQgaGF2ZW4ndFxyXG4gKiB0b3VjaGVkIGl0IHNpbmNlIHRoZW4gKGJlc2lkZXMgbGludGluZykuXHJcbiAqIEF0IHRoZSB0aW1lLCBJIGNvdWxkIG5vdCBmaW5kIGEgcGxvdHRpbmcgbGlicmFyeSB0aGF0IHdvdWxkXHJcbiAqIHJlbmRlciBzY2llbnRpZmljIGdyYXBocyB0aGF0IGNvdWxkIGJlIHVzZWQgZGlyZWN0bHkgaW4gYVxyXG4gKiBwdWJsaWNhdGlvbi5cclxuICogQWxzbyBJIHRob3VnaHQgaXQgd2FzIGEgZ29vZCBleGVyY2ljZSB0byBjb2RlIHRoaXMgbXlzZWxmLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZVByZWNpc2lvbihwcmVjaXNpb24sIG51bWJlcikge1xyXG4gIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBwcmVjaXNpb24pKSAvIE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIHRoZSBtaW4gdmFsdWUgb2YgYW4gYXJyYXlcclxuZnVuY3Rpb24gbWluKGFycmF5KSB7XHJcbiAgdmFyIG1pbiA9ICcrSW5maW5pdHknLFxyXG4gICAgZWxlbWVudDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xyXG4gICAgaWYgKGVsZW1lbnQgPCBtaW4gJiYgZWxlbWVudCAhPSAnLUluZmluaXR5Jykge1xyXG4gICAgICBtaW4gPSBlbGVtZW50O1xyXG5cclxuICAgIH1cclxuICB9XHJcbiAgLy9hbGVydChtaW4pO1xyXG4gIHJldHVybiBtaW47XHJcbn1cclxuXHJcbi8vIHJldHVybnMgdGhlIG1heCB2YWx1ZSBvZiBhbiBhcnJheVxyXG5mdW5jdGlvbiBtYXgoYXJyYXkpIHtcclxuICB2YXIgbWF4O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghbWF4IHx8IGFycmF5W2ldID4gbWF4KSB7XHJcbiAgICAgIG1heCA9IGFycmF5W2ldO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbWF4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcmRlck9mTWFnbih2YWx1ZSkge1xyXG4gIHJldHVybiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChNYXRoLmFicyh2YWx1ZSkpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZzEwKHZhbCkge1xyXG4gIHJldHVybiBNYXRoLmxvZyh2YWwpIC8gTWF0aC5sb2coMTApO1xyXG59XHJcblxyXG5sZXQgYXJyYXk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkcmF3R3JhcGgoY2FudmFzSWQsIGFycmF5TXVsdCwgZm9jdXNlZFBsb3QsIHBsb3RTdHlsZSwgc2NhbGVUeXBlLCB4VGl0bGUsIHlUaXRsZSkge1xyXG5cclxuICAvL2FycmF5IHdpbGwgYmUgdXNlZCB0byBidWlsZCB0aGUgZ3JhcGggYXJlYSwgbWF4IGFuZCBtaW4sIGRpc3RhbmNlIGJldHdlZW4gMiB0aWNrcyBldGMuXHJcbiAgYXJyYXkgPSBhcnJheU11bHRbZm9jdXNlZFBsb3RdO1xyXG4gIHZhciB4QXJyYXkgPSBbXSxcclxuICAgIHlBcnJheSA9IFtdLFxyXG4gICAgeSwgeHk7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGFycmF5Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgeHkgPSBhcnJheVtpXTtcclxuICAgIHkgPSB4eVsxXTtcclxuICAgIGlmIChzY2FsZVR5cGUgPT0gJ2xvZ1NjYWxlJykge1xyXG4gICAgICBpZiAoeSAhPSAwKSB7IC8vd2hlbiBzY2FsZSBpcyBMb2csIGRvbid0IGluY2x1ZGUgdGhlIHBvaW50cyBmb3Igd2hpY2ggeSA9IDBcclxuICAgICAgICB4QXJyYXkucHVzaCh4eVswXSk7XHJcbiAgICAgICAgeUFycmF5LnB1c2gobG9nMTAoTWF0aC5hYnMoeSkpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeEFycmF5LnB1c2goeHlbMF0pO1xyXG4gICAgICB5QXJyYXkucHVzaCh5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciB5TWluID0gbWluKHlBcnJheSk7XHJcblxyXG4gIGlmIChzY2FsZVR5cGUgPT0gJ2xvZ1NjYWxlJyAmJiB5TWluIDwgLTE1KSB7XHJcbiAgICB2YXIgaW5kZXggPSB5QXJyYXkuaW5kZXhPZih5TWluKTtcclxuICAgIHhBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgeUFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgfVxyXG5cclxuICB2YXIgeE1pbiA9IG1pbih4QXJyYXkpLFxyXG4gICAgeE1heCA9IG1heCh4QXJyYXkpO1xyXG4gIHlNaW4gPSBtaW4oeUFycmF5KTtcclxuICB2YXIgeU1heCA9IG1heCh5QXJyYXkpLFxyXG5cclxuICAgIC8vYWxlcnQoeE1pbik7XHJcbiAgICB4eVN0ZXAgPSBjYWxjU3RlcCh4TWluLCB4TWF4LCB5TWluLCB5TWF4KSxcclxuICAgIHhTdGVwID0geHlTdGVwWzBdLFxyXG4gICAgeVN0ZXAgPSB4eVN0ZXBbMV0sXHJcblxyXG4gICAgYXhlc01heE1pbiA9IGNhbGNBeGVzTWF4TWluKHhNaW4sIHhNYXgsIHhTdGVwLCB5TWluLCB5TWF4LCB5U3RlcCksXHJcbiAgICB4QXhpc01pbiA9IGF4ZXNNYXhNaW5bMF0sXHJcbiAgICB4QXhpc01heCA9IGF4ZXNNYXhNaW5bMV0sXHJcbiAgICB5QXhpc01pbiA9IGF4ZXNNYXhNaW5bMl0sXHJcbiAgICB5QXhpc01heCA9IGF4ZXNNYXhNaW5bM10sXHJcblxyXG4gICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpLFxyXG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGgsXHJcbiAgICBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0LFxyXG4gICAgbWFyZ2luID0gNDAuNSxcclxuICAgIHVuaXRQeCA9IGNhbGNVbml0UHgoeEF4aXNNaW4sIHhBeGlzTWF4LCBjYW52YXNXaWR0aCwgeUF4aXNNaW4sIHlBeGlzTWF4LCBjYW52YXNIZWlnaHQsIG1hcmdpbiksXHJcbiAgICB4VW5pdFB4ID0gdW5pdFB4WzBdLFxyXG4gICAgeVVuaXRQeCA9IHVuaXRQeFsxXTtcclxuXHJcbiAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDsgLy9jbGVhcnMgdGhlIGNhbnZhc1xyXG5cclxuICB2YXIgYXhlc1Bvc2l0aW9uID0gZHJhd0F4aXMoY29udGV4dCwgc2NhbGVUeXBlLCBtYXJnaW4sIHhBeGlzTWluLCB4QXhpc01heCwgY2FudmFzV2lkdGgsIHhVbml0UHgsIHhUaXRsZSwgeUF4aXNNaW4sIHlBeGlzTWF4LCBjYW52YXNIZWlnaHQsIHlVbml0UHgsIHlUaXRsZSksXHJcbiAgICB4QXhpc1Bvc2l0aW9uID0gYXhlc1Bvc2l0aW9uWzBdLFxyXG4gICAgeFRpY2tzU2lkZSA9IGF4ZXNQb3NpdGlvblsxXSAvIE1hdGguYWJzKGF4ZXNQb3NpdGlvblsxXSksXHJcbiAgICB5QXhpc1Bvc2l0aW9uID0gYXhlc1Bvc2l0aW9uWzJdLFxyXG4gICAgeVRpY2tzU2lkZSA9IGF4ZXNQb3NpdGlvblszXSAvIE1hdGguYWJzKGF4ZXNQb3NpdGlvblszXSk7XHJcblxyXG4gIGRyYXdUaWNrcyhjb250ZXh0LCBzY2FsZVR5cGUsIG1hcmdpbiwgeEF4aXNNaW4sIHhBeGlzTWF4LCB4U3RlcCwgY2FudmFzV2lkdGgsIHhVbml0UHgsIHhBeGlzUG9zaXRpb24sIHhUaWNrc1NpZGUsIHlBeGlzTWluLCB5QXhpc01heCwgeVN0ZXAsIGNhbnZhc0hlaWdodCwgeVVuaXRQeCwgeUF4aXNQb3NpdGlvbiwgeVRpY2tzU2lkZSk7XHJcblxyXG4gIGxlZ2VuZChjb250ZXh0LCBzY2FsZVR5cGUsIGFycmF5TXVsdCwgcGxvdFN0eWxlLCBtYXJnaW4sIHhBeGlzTWluLCB4VW5pdFB4LCB5QXhpc01pbiwgeVVuaXRQeCwgY2FudmFzSGVpZ2h0KTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU11bHQubGVuZ3RoOyBpKyspIHtcclxuICAgIHBsb3QoYXJyYXlNdWx0W2ldLCBjb250ZXh0LCBzY2FsZVR5cGUsIHBsb3RTdHlsZVtpXSwgbWFyZ2luLCB4QXhpc01pbiwgeEF4aXNNYXgsIGNhbnZhc1dpZHRoLCB4VW5pdFB4LCB5QXhpc01pbiwgeUF4aXNNYXgsIGNhbnZhc0hlaWdodCwgeVVuaXRQeCwgeUF4aXNQb3NpdGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjU3RlcCh4TWluLCB4TWF4LCB5TWluLCB5TWF4KSB7XHJcblxyXG4gIHZhciBvT2ZNYWduID0gb3JkZXJPZk1hZ24oeE1heCAtIHhNaW4pLFxyXG4gICAgeFN0ZXAgPSBvT2ZNYWduICogMC4yLFxyXG4gICAgeEF4aXNNYXgsXHJcbiAgICB4QXhpc01pbjtcclxuXHJcbiAgaWYgKHhNYXggLSB4TWluID4gb09mTWFnbiAqIDQgLyAzKSB7XHJcbiAgICB4U3RlcCA9IG9PZk1hZ24gKiAwLjU7XHJcbiAgfVxyXG4gIGlmICh4TWF4IC0geE1pbiA+IG9PZk1hZ24gKiAxMCAvIDMpIHtcclxuICAgIHhTdGVwID0gb09mTWFnbjtcclxuICB9XHJcbiAgaWYgKHhNYXggLSB4TWluID4gb09mTWFnbiAqIDIwIC8gMykge1xyXG4gICAgeFN0ZXAgPSBvT2ZNYWduICogMjtcclxuICB9XHJcblxyXG4gIG9PZk1hZ24gPSBvcmRlck9mTWFnbih5TWF4IC0geU1pbik7XHJcbiAgdmFyIHlTdGVwID0gb09mTWFnbiAqIDAuMixcclxuICAgIHlBeGlzTWF4LFxyXG4gICAgeUF4aXNNaW47XHJcblxyXG4gIGlmICh5TWF4IC0geU1pbiA+IG9PZk1hZ24gKiA0IC8gMykge1xyXG4gICAgeVN0ZXAgPSBvT2ZNYWduICogMC41O1xyXG4gIH1cclxuICBpZiAoeU1heCAtIHlNaW4gPiBvT2ZNYWduICogMTAgLyAzKSB7XHJcbiAgICB5U3RlcCA9IG9PZk1hZ247XHJcbiAgfVxyXG4gIGlmICh5TWF4IC0geU1pbiA+IG9PZk1hZ24gKiAyMCAvIDMpIHtcclxuICAgIHlTdGVwID0gb09mTWFnbiAqIDI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gW3hTdGVwLCB5U3RlcF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGNBeGVzTWF4TWluKHhNaW4sIHhNYXgsIHhTdGVwLCB5TWluLCB5TWF4LCB5U3RlcCkge1xyXG5cclxuICB2YXIgbWluID0gW3hNaW4sIHlNaW5dLFxyXG4gICAgbWF4ID0gW3hNYXgsIHlNYXhdLFxyXG4gICAgc3RlcCA9IFt4U3RlcCwgeVN0ZXBdLFxyXG4gICAgYXhpc01pbiA9IFswLCAwXSxcclxuICAgIGF4aXNNYXggPSBbMCwgMF07XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xyXG4gICAgaWYgKG1pbltpXSA8PSAwKSB7XHJcbiAgICAgIHdoaWxlIChheGlzTWluW2ldID49IG1pbltpXSkge1xyXG4gICAgICAgIGF4aXNNaW5baV0gPSBheGlzTWluW2ldIC0gc3RlcFtpXTtcclxuICAgICAgfVxyXG4gICAgICBheGlzTWF4W2ldID0gYXhpc01pbltpXTtcclxuICAgICAgd2hpbGUgKGF4aXNNYXhbaV0gPD0gbWF4W2ldKSB7XHJcbiAgICAgICAgYXhpc01heFtpXSA9IGF4aXNNYXhbaV0gKyBzdGVwW2ldO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aGlsZSAoYXhpc01heFtpXSA8PSBtYXhbaV0pIHtcclxuICAgICAgICBheGlzTWF4W2ldID0gYXhpc01heFtpXSArIHN0ZXBbaV07XHJcbiAgICAgIH1cclxuICAgICAgYXhpc01pbltpXSA9IGF4aXNNYXhbaV07XHJcbiAgICAgIHdoaWxlIChheGlzTWluW2ldID49IG1pbltpXSkge1xyXG4gICAgICAgIGF4aXNNaW5baV0gPSBheGlzTWluW2ldIC0gc3RlcFtpXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gW2F4aXNNaW5bMF0sIGF4aXNNYXhbMF0sIGF4aXNNaW5bMV0sIGF4aXNNYXhbMV1dO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjVW5pdFB4KHhBeGlzTWluLCB4QXhpc01heCwgY2FudmFzV2lkdGgsIHlBeGlzTWluLCB5QXhpc01heCwgY2FudmFzSGVpZ2h0LCBtYXJnaW4pIHtcclxuICB2YXIgeFVuaXRQeCA9IChjYW52YXNXaWR0aCAtIDIgKiBtYXJnaW4pIC8gKHhBeGlzTWF4IC0geEF4aXNNaW4pLFxyXG4gICAgeVVuaXRQeCA9IChjYW52YXNIZWlnaHQgLSAyICogbWFyZ2luKSAvICh5QXhpc01heCAtIHlBeGlzTWluKTtcclxuXHJcbiAgcmV0dXJuIFt4VW5pdFB4LCB5VW5pdFB4XTtcclxufVxyXG5cclxuZnVuY3Rpb24geERhdGFUb0NhbnZhcyh2YWx1ZSwgbWFyZ2luLCB1bml0UHgpIHtcclxuICByZXR1cm4gbWFyZ2luICsgTWF0aC5mbG9vcih2YWx1ZSAqIHVuaXRQeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHlEYXRhVG9DYW52YXModmFsdWUsIG1hcmdpbiwgdW5pdFB4LCBjYW52YXNIZWlnaHQpIHtcclxuICByZXR1cm4gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcih2YWx1ZSAqIHVuaXRQeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdBeGlzKGNvbnRleHQsIHR5cGUsIG1hcmdpbiwgeEF4aXNNaW4sIHhBeGlzTWF4LCBjYW52YXNXaWR0aCwgeFVuaXRQeCwgeFRpdGxlLCB5QXhpc01pbiwgeUF4aXNNYXgsIGNhbnZhc0hlaWdodCwgeVVuaXRQeCwgeVRpdGxlKSB7XHJcbiAgY29udGV4dC5mb250ID0gJzEwcHggQXJpYWwnO1xyXG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xyXG4gIGNvbnRleHQubGluZVdpZHRoID0gMTtcclxuICB2YXIgeUF4aXNQb3NpdGlvbixcclxuICAgIHhBeGlzUG9zaXRpb24sXHJcbiAgICB5VGl0bGVQb3NpdGlvbixcclxuICAgIHhUaXRsZVBvc2l0aW9uLFxyXG4gICAgeVRpdGxlU2lkZSxcclxuICAgIHhUaXRsZVNpZGU7XHJcblxyXG4gIC8vZGV0ZXJtaW5lIHlBeGlzIHBvc2l0aW9uXHJcbiAgaWYgKHhBeGlzTWluIDw9IDAgJiYgeEF4aXNNYXggPj0gMCkgeyB5QXhpc1Bvc2l0aW9uID0gMDsgfVxyXG4gIGVsc2Uge1xyXG4gICAgaWYgKHhBeGlzTWluID4gMCkgeyB5QXhpc1Bvc2l0aW9uID0geEF4aXNNaW47IH1cclxuICAgIGVsc2UgeyB5QXhpc1Bvc2l0aW9uID0geEF4aXNNYXg7IH1cclxuICB9XHJcblxyXG4gIC8vZHJhdyB5IEF4aXNcclxuICBjb250ZXh0LmJlZ2luUGF0aCgpOyAvLyBwcmV2ZW50cyB3ZWlyZCBiZWhhdmlvciB3aXRoIElFOVxyXG4gIGNvbnRleHQubW92ZVRvKE1hdGguZmxvb3IoKHlBeGlzUG9zaXRpb24gLSB4QXhpc01pbikgKiB4VW5pdFB4KSArIG1hcmdpbiwgY2FudmFzSGVpZ2h0IC0gbWFyZ2luKTtcclxuICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKCh5QXhpc1Bvc2l0aW9uIC0geEF4aXNNaW4pICogeFVuaXRQeCkgKyBtYXJnaW4sIG1hcmdpbik7XHJcblxyXG4gIC8vZGV0ZXJtaW5lIHggdGl0bGUgcG9zaXRpb24gYW5kIHkgdGl0bGUncyBzaWRlXHJcbiAgaWYgKHhBeGlzTWF4IC0geUF4aXNQb3NpdGlvbiA+PSB5QXhpc1Bvc2l0aW9uIC0geEF4aXNNaW4pIHsgeFRpdGxlUG9zaXRpb24gPSAoeEF4aXNNYXggKyB5QXhpc1Bvc2l0aW9uKSAvIDI7IHlUaXRsZVNpZGUgPSAtMzA7IH1cclxuICBlbHNlIHsgeFRpdGxlUG9zaXRpb24gPSAoeUF4aXNQb3NpdGlvbiArIHhBeGlzTWluKSAvIDI7IHlUaXRsZVNpZGUgPSArMzA7IH1cclxuICAvL2FsZXJ0KHhUaXRsZVBvc2l0aW9uKTtcclxuXHJcbiAgLy9kZXRlcm1pbmUgeEF4aXMgcG9zaXRpb25cclxuICBpZiAoeUF4aXNNaW4gPD0gMCAmJiB5QXhpc01heCA+PSAwICYmIHR5cGUgPT0gJ2xpbmVhclNjYWxlJykgeyB4QXhpc1Bvc2l0aW9uID0gMDsgfVxyXG4gIGVsc2Uge1xyXG4gICAgaWYgKHlBeGlzTWluID4gMCB8fCB0eXBlID09ICdsb2dTY2FsZScpIHsgeEF4aXNQb3NpdGlvbiA9IHlBeGlzTWluOyB9XHJcbiAgICBlbHNlIHsgeEF4aXNQb3NpdGlvbiA9IHlBeGlzTWF4OyB9XHJcbiAgfVxyXG5cclxuICAvL2RyYXcgeCBBeGlzXHJcblxyXG4gIGNvbnRleHQubW92ZVRvKG1hcmdpbiwgY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeEF4aXNQb3NpdGlvbiAtIHlBeGlzTWluKSAqIHlVbml0UHgpKTtcclxuICBjb250ZXh0LmxpbmVUbyhjYW52YXNXaWR0aCAtIG1hcmdpbiwgY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeEF4aXNQb3NpdGlvbiAtIHlBeGlzTWluKSAqIHlVbml0UHgpKTtcclxuXHJcbiAgLy9kZXRlcm1pbmUgeSB0aXRsZSBwb3NpdGlvbiBhbmQgeCB0aXRsZSdzIHNpZGVcclxuICBpZiAoeUF4aXNNYXggLSB4QXhpc1Bvc2l0aW9uID49IHhBeGlzUG9zaXRpb24gLSB5QXhpc01pbikgeyB5VGl0bGVQb3NpdGlvbiA9ICh5QXhpc01heCArIHhBeGlzUG9zaXRpb24pIC8gMjsgeFRpdGxlU2lkZSA9IDI1OyB9XHJcbiAgZWxzZSB7IHlUaXRsZVBvc2l0aW9uID0gKHhBeGlzUG9zaXRpb24gKyB5QXhpc01pbikgLyAyOyB4VGl0bGVTaWRlID0gLTI1OyB9XHJcblxyXG4gIC8vd3JpdGUgeCB0aXRsZVxyXG4gIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgaWYgKHhUaXRsZVNpZGUgPiAwKSB7IGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7IH1cclxuICBlbHNlIHsgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJzsgfVxyXG4gIGNvbnRleHQuZmlsbFRleHQoeFRpdGxlLCBtYXJnaW4gKyBNYXRoLmZsb29yKCh4VGl0bGVQb3NpdGlvbiAtIHhBeGlzTWluKSAqIHhVbml0UHgpLCBjYW52YXNIZWlnaHQgLSBtYXJnaW4gLSBNYXRoLmZsb29yKCh4QXhpc1Bvc2l0aW9uIC0geUF4aXNNaW4pICogeVVuaXRQeCkgKyB4VGl0bGVTaWRlKTtcclxuXHJcbiAgLy93cml0ZSB5IHRpdGxlXHJcbiAgY29udGV4dC5yb3RhdGUoLU1hdGguUEkgLyAyKTsgLy9yb3RhdGUgdGhlIHdob2xlIGNhbnZhcyB0byB3cml0ZSB5IHRpdGxlIHZlcnRpY2FsbHlcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gIGlmICh5VGl0bGVTaWRlID4gMCkgeyBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnOyB9XHJcbiAgZWxzZSB7IGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7IH1cclxuXHJcbiAgdmFyIHggPSBtYXJnaW4gKyBNYXRoLmZsb29yKCh5QXhpc1Bvc2l0aW9uIC0geEF4aXNNaW4pICogeFVuaXRQeCkgKyB5VGl0bGVTaWRlLFxyXG4gICAgeSA9IGNhbnZhc0hlaWdodCAtIG1hcmdpbiAtIE1hdGguZmxvb3IoKHlUaXRsZVBvc2l0aW9uIC0geUF4aXNNaW4pICogeVVuaXRQeCk7XHJcbiAgY29udGV4dC5maWxsVGV4dCh5VGl0bGUsIC15LCB4KTtcclxuICBjb250ZXh0LnJvdGF0ZShNYXRoLlBJIC8gMik7XHJcblxyXG5cclxuICByZXR1cm4gW3hBeGlzUG9zaXRpb24sIHhUaXRsZVNpZGUsIHlBeGlzUG9zaXRpb24sIHlUaXRsZVNpZGVdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3VGlja3MoY29udGV4dCwgdHlwZSwgbWFyZ2luLCB4QXhpc01pbiwgeEF4aXNNYXgsIHhTdGVwLCBjYW52YXNXaWR0aCwgeFVuaXRQeCwgeEF4aXNQb3NpdGlvbiwgeFRpY2tzU2lkZSwgeUF4aXNNaW4sIHlBeGlzTWF4LCB5U3RlcCwgY2FudmFzSGVpZ2h0LCB5VW5pdFB4LCB5QXhpc1Bvc2l0aW9uLCB5VGlja3NTaWRlKSB7XHJcbiAgdmFyIHhQeCxcclxuICAgIHlQeCxcclxuICAgIHRpY2tMYWJlbDtcclxuXHJcbiAgLy94IEF4aXNcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gIGlmICh4VGlja3NTaWRlID4gMCkgeyBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnOyB9XHJcbiAgZWxzZSB7IGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7IH1cclxuXHJcbiAgLy9tYWpvciB0aWNrc1xyXG4gIGZvciAodmFyIHggPSB4QXhpc01pbjsgeCA8PSB4QXhpc01heDsgeCArPSB4U3RlcCkge1xyXG4gICAgeFB4ID0gbWFyZ2luICsgTWF0aC5mbG9vcigoeCAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgeVB4ID0gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeEF4aXNQb3NpdGlvbiAtIHlBeGlzTWluKSAqIHlVbml0UHgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oeFB4LCB5UHgpO1xyXG4gICAgY29udGV4dC5saW5lVG8oeFB4LCB5UHggKyAyICogeFRpY2tzU2lkZSk7XHJcblxyXG4gICAgaWYgKHggPT0geEF4aXNQb3NpdGlvbiAmJiB4QXhpc1Bvc2l0aW9uICE9IHlBeGlzTWluICYmIHhBeGlzUG9zaXRpb24gIT0geUF4aXNNYXgpIHtcclxuICAgICAgeFB4ID0geFB4IC0gMTAgKiB5VGlja3NTaWRlO1xyXG4gICAgfSAvL2F2b2lkcyB0aGUgbWVzc3kgemVybyBsYWJlbHMgYXQgdGhlIGF4ZXMnIGludGVyc2VjdGlvbnNcclxuICAgIHRpY2tMYWJlbCA9IGNoYW5nZVByZWNpc2lvbig3LCB4KTtcclxuICAgIGNvbnRleHQuZmlsbFRleHQodGlja0xhYmVsLCB4UHgsIHlQeCArIDUgKiB4VGlja3NTaWRlKTsgLy90aWNrIGxhYmVsXHJcbiAgfVxyXG5cclxuICAvL21pbm9yIHRpY2tzXHJcbiAgZm9yICh2YXIgeCA9IHhBeGlzTWluOyB4IDwgeEF4aXNNYXg7IHggKz0geFN0ZXAgLyAyKSB7XHJcbiAgICB4UHggPSBtYXJnaW4gKyBNYXRoLmZsb29yKCh4IC0geEF4aXNNaW4pICogeFVuaXRQeCk7XHJcbiAgICB5UHggPSBjYW52YXNIZWlnaHQgLSBtYXJnaW4gLSBNYXRoLmZsb29yKCh4QXhpc1Bvc2l0aW9uIC0geUF4aXNNaW4pICogeVVuaXRQeCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyh4UHgsIHlQeCk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyh4UHgsIHlQeCArIDEgKiB4VGlja3NTaWRlKTtcclxuICB9XHJcblxyXG4gIC8veSBBeGlzXHJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICBpZiAoeVRpY2tzU2lkZSA+IDApIHsgY29udGV4dC50ZXh0QWxpZ24gPSAnbGVmdCc7IH1cclxuICBlbHNlIHsgY29udGV4dC50ZXh0QWxpZ24gPSAncmlnaHQnOyB9XHJcbiAgLy9tYWpvciB0aWNrc1xyXG4gIGZvciAodmFyIHkgPSB5QXhpc01pbjsgeSA8PSB5QXhpc01heDsgeSArPSB5U3RlcCkge1xyXG4gICAgeVB4ID0gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeSAtIHlBeGlzTWluKSAqIHlVbml0UHgpO1xyXG4gICAgeFB4ID0gbWFyZ2luICsgTWF0aC5mbG9vcigoeUF4aXNQb3NpdGlvbiAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oeFB4LCB5UHgpO1xyXG4gICAgY29udGV4dC5saW5lVG8oeFB4ICsgMiAqIHlUaWNrc1NpZGUsIHlQeCk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT0gJ2xvZ1NjYWxlJyAmJiB5IDwgeUF4aXNNYXgpIHtcclxuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMTA7IGorKykge1xyXG4gICAgICAgIHZhciB5TWlub3IgPSBNYXRoLmZsb29yKHlQeCAtIHlTdGVwICogeVVuaXRQeCAqIGxvZzEwKGogLyAxMCkgLSB5U3RlcCAqIHlVbml0UHgpICsgMC41O1xyXG5cclxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UHgsIHlNaW5vcik7XHJcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFB4ICsgMSAqIHlUaWNrc1NpZGUsIHlNaW5vcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRpY2tMYWJlbCA9IGNoYW5nZVByZWNpc2lvbig3LCB5KTtcclxuICAgIGlmICh0eXBlID09ICdsb2dTY2FsZScpIHtcclxuICAgICAgdGlja0xhYmVsID0gJzFFJyArIHk7XHJcbiAgICB9XHJcbiAgICBpZiAoeSA9PSB4QXhpc1Bvc2l0aW9uICYmIHlBeGlzUG9zaXRpb24gIT0geEF4aXNNaW4gJiYgeUF4aXNQb3NpdGlvbiAhPSB4QXhpc01heCkge1xyXG4gICAgICB5UHggPSB5UHggLSAxMCAqIHhUaWNrc1NpZGU7XHJcbiAgICB9IC8vYXZvaWRzIHRoZSBtZXNzeSBsYWJlbHMgYXQgdGhlIGF4ZXMnIGludGVyc2VjdGlvbnNcclxuICAgIGNvbnRleHQuZmlsbFRleHQodGlja0xhYmVsLCB4UHggKyA1ICogeVRpY2tzU2lkZSwgeVB4KTsgLy90aWNrIGxhYmVsXHJcbiAgfVxyXG4gIC8vbWlub3IgdGlja3NcclxuICBpZiAodHlwZSA9PSAnbGluZWFyU2NhbGUnKSB7XHJcbiAgICBmb3IgKHZhciB5ID0geUF4aXNNaW47IHkgPCB5QXhpc01heDsgeSArPSB5U3RlcCAvIDIpIHtcclxuXHJcbiAgICAgIHlQeCA9IGNhbnZhc0hlaWdodCAtIG1hcmdpbiAtIE1hdGguZmxvb3IoKHkgLSB5QXhpc01pbikgKiB5VW5pdFB4KTtcclxuICAgICAgeFB4ID0gbWFyZ2luICsgTWF0aC5mbG9vcigoeUF4aXNQb3NpdGlvbiAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG5cclxuICAgICAgY29udGV4dC5tb3ZlVG8oeFB4LCB5UHgpO1xyXG4gICAgICBjb250ZXh0LmxpbmVUbyh4UHggKyAxICogeVRpY2tzU2lkZSwgeVB4KTtcclxuICAgIH1cclxuICB9XHJcbiAgY29udGV4dC5zdHJva2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVnZW5kKGNvbnRleHQsIHR5cGUsIGFycmF5TXVsdCwgcGxvdFN0eWxlLCBtYXJnaW4sIHhBeGlzTWluLCB4VW5pdFB4LCB5QXhpc01pbiwgeVVuaXRQeCwgY2FudmFzSGVpZ2h0KSB7XHJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdsZWZ0JztcclxuICB2YXIgeCwgeSwgeFB4LCB5UHggPSAnK0luZmluaXR5JywgaW5kZXgsIHh5LCBhcnJheSA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlNdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBhcnJheSA9IGFycmF5TXVsdFtpXTtcclxuICAgIGluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTsvL2xhc3QgcG9pbnRcclxuICAgIHh5ID0gYXJyYXlbaW5kZXhdO1xyXG4gICAgeCA9IHh5WzBdO1xyXG4gICAgeSA9IHh5WzFdO1xyXG5cclxuICAgIHhQeCA9IDEwICsgbWFyZ2luICsgTWF0aC5mbG9vcigoeCAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgaWYgKHR5cGUgPT0gJ2xvZ1NjYWxlJykgeyB5ID0gbG9nMTAoTWF0aC5hYnMoeSkpOyB9XHJcbiAgICBpZiAoaXNGaW5pdGUoeSkpIHtcclxuICAgICAgeVB4ID0gY2FudmFzSGVpZ2h0IC0gbWFyZ2luIC0gTWF0aC5mbG9vcigoeSAtIHlBeGlzTWluKSAqIHlVbml0UHgpO1xyXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBsb3RTdHlsZVtpXVsxXTsgLy9jb2xvclxyXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHBsb3RTdHlsZVtpXVsyXSwgeFB4LCB5UHgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcGxvdChhcnJheSwgY29udGV4dCwgdHlwZSwgcGxvdFN0eWxlLCBtYXJnaW4sIHhBeGlzTWluLCB4QXhpc01heCwgY2FudmFzV2lkdGgsIHhVbml0UHgsIHlBeGlzTWluLCB5QXhpc01heCwgY2FudmFzSGVpZ2h0LCB5VW5pdFB4LCB5QXhpc1Bvc2l0aW9uKSB7XHJcbiAgdmFyIHhQeCwgeVB4LCB5LCBqID0gMDtcclxuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcGxvdFN0eWxlWzFdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgLy9vbmUgbG9vcCBmb3IgZWFjaCBkYXRhIHBvaW50XHJcbiAgICB4UHggPSBtYXJnaW4gKyBNYXRoLmZsb29yKChhcnJheVtpXVswXSAtIHhBeGlzTWluKSAqIHhVbml0UHgpO1xyXG4gICAgeSA9IChhcnJheVtpXVsxXSk7XHJcbiAgICBpZiAodHlwZSA9PSAnbG9nU2NhbGUnKSB7XHJcbiAgICAgIHkgPSBsb2cxMChNYXRoLmFicyh5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoeSAhPSAnLUluZmluaXR5Jykgey8veSA9ICctSW5maW5pdHknIHdoZW4geSA9IDAgYW5kIHNjYWxlIGlzIExvZ1xyXG4gICAgICB5UHggPSBjYW52YXNIZWlnaHQgLSBtYXJnaW4gLSBNYXRoLmZsb29yKCh5IC0geUF4aXNNaW4pICogeVVuaXRQeCk7XHJcbiAgICAgIHN3aXRjaCAocGxvdFN0eWxlWzBdKSB7XHJcbiAgICAgICAgY2FzZSAnbGluZSc6IHtcclxuICAgICAgICAgIGlmIChqID09IDApIHsgLy8gaj09MCA8PT4gMXN0IHBsb3R0ZWQgcG9pbnQsIG5vdCBuZWNlc3NhcmlseSAxc3QgcG9pbnQgaW4gdGhlIGFycmF5IFxyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UHgsIHlQeCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4UHgsIHlQeCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnY2lyY2xlcyc6IHtcclxuICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICBjb250ZXh0LmFyYyh4UHgsIHlQeCwgMywgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdkaWFnb25hbENyb3NzJzoge1xyXG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQeCAtIDIsIHlQeCAtIDIpO1xyXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oeFB4ICsgMiwgeVB4ICsgMik7XHJcbiAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UHggKyAyLCB5UHggLSAyKTtcclxuICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQeCAtIDIsIHlQeCArIDIpO1xyXG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICd2ZXJ0aWNhbENyb3NzJzoge1xyXG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQeCwgeVB4IC0gMik7XHJcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4UHgsIHlQeCArIDIpO1xyXG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oeFB4ICsgMiwgeVB4KTtcclxuICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQeCAtIDIsIHlQeCk7XHJcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGorKztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHBsb3RTdHlsZVswXSA9PSAnbGluZScpIHsgY29udGV4dC5zdHJva2UoKTsgfVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2pzL2JvYkdyYXBoLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"/*\\r\\n * Base structure\\r\\n */\\r\\n\\r\\n/* Move down content because we have a fixed navbar that is 50px tall */\\r\\nbody {\\r\\n  padding-top: 60px;\\r\\n}\\r\\n\\r\\n.navbar-brand {\\r\\n  font-size: 36px;\\r\\n}\\r\\n\\r\\n/*\\r\\n * Global add-ons\\r\\n */\\r\\n\\r\\n.sub-header {\\r\\n  padding-bottom: 10px;\\r\\n  border-bottom: 1px solid #eee;\\r\\n}\\r\\n\\r\\n/*\\r\\n * Top navigation\\r\\n * Hide default border to remove 1px line.\\r\\n */\\r\\n.navbar-fixed-top {\\r\\n  border: 0;\\r\\n  height: 60px;\\r\\n}\\r\\n\\r\\n/*\\r\\n * Sidebar\\r\\n */\\r\\n\\r\\n@media (min-width: 768px) {\\r\\n  .sidebar {\\r\\n    position: fixed;\\r\\n    top: 60px;\\r\\n    bottom: 0;\\r\\n    left: 0;\\r\\n    z-index: 1000;\\r\\n    display: block;\\r\\n    padding: 20px;\\r\\n    overflow-x: hidden;\\r\\n    overflow-y: auto; /* Scrollable contents if viewport is shorter than content. */\\r\\n    background-color: #f5f5f5;\\r\\n    border-right: 1px solid #eee;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Sidebar navigation */\\r\\n.nav-sidebar {\\r\\n  margin-right: -21px; /* 20px padding + 1px border */\\r\\n  margin-bottom: 20px;\\r\\n  margin-left: -20px;\\r\\n}\\r\\n.nav-sidebar > li > a {\\r\\n  padding-right: 20px;\\r\\n  padding-left: 20px;\\r\\n}\\r\\n.nav-sidebar > .active > a,\\r\\n.nav-sidebar > .active > a:hover,\\r\\n.nav-sidebar > .active > a:focus {\\r\\n  color: #fff;\\r\\n  background-color: #428bca;\\r\\n}\\r\\n\\r\\n\\r\\n/*\\r\\n * Main content\\r\\n */\\r\\n\\r\\n.main {\\r\\n  padding: 20px;\\r\\n}\\r\\n@media (min-width: 768px) {\\r\\n  .main {\\r\\n    padding-right: 40px;\\r\\n    padding-left: 40px;\\r\\n  }\\r\\n}\\r\\n.main .page-header {\\r\\n  margin-top: 0;\\r\\n}\\r\\n\\r\\n/* fa icons */\\r\\n.fa-toggle-on, .fa-toggle-off {\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.fa-toggle-on {\\r\\n  /*color: #f1f1f1;*/\\r\\n  color: #dddddd;\\r\\n  color: #8ce196;\\r\\n}\\r\\n\\r\\n.fa-toggle-off {\\r\\n  color: #dddddd;\\r\\n}\\r\\n\\r\\nbutton.play > span#pause {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\nbutton.pause > span#play {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\ndiv.input-group#ds {\\r\\n  width: 60%;\\r\\n}\\r\\n\\r\\n.panel {\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.panel.nofile:after {\\r\\n  content: \\\" \\\";\\r\\n  z-index: 10;\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  background: rgba(255, 255, 255, 0.5);\\r\\n  border-radius: 4px;\\r\\n}\", \"\"]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5jc3M/NGNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcclxcbiAqIEJhc2Ugc3RydWN0dXJlXFxyXFxuICovXFxyXFxuXFxyXFxuLyogTW92ZSBkb3duIGNvbnRlbnQgYmVjYXVzZSB3ZSBoYXZlIGEgZml4ZWQgbmF2YmFyIHRoYXQgaXMgNTBweCB0YWxsICovXFxyXFxuYm9keSB7XFxyXFxuICBwYWRkaW5nLXRvcDogNjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLm5hdmJhci1icmFuZCB7XFxyXFxuICBmb250LXNpemU6IDM2cHg7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuICogR2xvYmFsIGFkZC1vbnNcXHJcXG4gKi9cXHJcXG5cXHJcXG4uc3ViLWhlYWRlciB7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXHJcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiAqIFRvcCBuYXZpZ2F0aW9uXFxyXFxuICogSGlkZSBkZWZhdWx0IGJvcmRlciB0byByZW1vdmUgMXB4IGxpbmUuXFxyXFxuICovXFxyXFxuLm5hdmJhci1maXhlZC10b3Age1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgaGVpZ2h0OiA2MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiAqIFNpZGViYXJcXHJcXG4gKi9cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXHJcXG4gIC5zaWRlYmFyIHtcXHJcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgICB0b3A6IDYwcHg7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgbGVmdDogMDtcXHJcXG4gICAgei1pbmRleDogMTAwMDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHBhZGRpbmc6IDIwcHg7XFxyXFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG4gICAgb3ZlcmZsb3cteTogYXV0bzsgLyogU2Nyb2xsYWJsZSBjb250ZW50cyBpZiB2aWV3cG9ydCBpcyBzaG9ydGVyIHRoYW4gY29udGVudC4gKi9cXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTtcXHJcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2VlZTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogU2lkZWJhciBuYXZpZ2F0aW9uICovXFxyXFxuLm5hdi1zaWRlYmFyIHtcXHJcXG4gIG1hcmdpbi1yaWdodDogLTIxcHg7IC8qIDIwcHggcGFkZGluZyArIDFweCBib3JkZXIgKi9cXHJcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxuICBtYXJnaW4tbGVmdDogLTIwcHg7XFxyXFxufVxcclxcbi5uYXYtc2lkZWJhciA+IGxpID4gYSB7XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xcclxcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcclxcbn1cXHJcXG4ubmF2LXNpZGViYXIgPiAuYWN0aXZlID4gYSxcXHJcXG4ubmF2LXNpZGViYXIgPiAuYWN0aXZlID4gYTpob3ZlcixcXHJcXG4ubmF2LXNpZGViYXIgPiAuYWN0aXZlID4gYTpmb2N1cyB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0MjhiY2E7XFxyXFxufVxcclxcblxcclxcblxcclxcbi8qXFxyXFxuICogTWFpbiBjb250ZW50XFxyXFxuICovXFxyXFxuXFxyXFxuLm1haW4ge1xcclxcbiAgcGFkZGluZzogMjBweDtcXHJcXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxyXFxuICAubWFpbiB7XFxyXFxuICAgIHBhZGRpbmctcmlnaHQ6IDQwcHg7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogNDBweDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuLm1haW4gLnBhZ2UtaGVhZGVyIHtcXHJcXG4gIG1hcmdpbi10b3A6IDA7XFxyXFxufVxcclxcblxcclxcbi8qIGZhIGljb25zICovXFxyXFxuLmZhLXRvZ2dsZS1vbiwgLmZhLXRvZ2dsZS1vZmYge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uZmEtdG9nZ2xlLW9uIHtcXHJcXG4gIC8qY29sb3I6ICNmMWYxZjE7Ki9cXHJcXG4gIGNvbG9yOiAjZGRkZGRkO1xcclxcbiAgY29sb3I6ICM4Y2UxOTY7XFxyXFxufVxcclxcblxcclxcbi5mYS10b2dnbGUtb2ZmIHtcXHJcXG4gIGNvbG9yOiAjZGRkZGRkO1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24ucGxheSA+IHNwYW4jcGF1c2Uge1xcclxcbiAgZGlzcGxheTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uLnBhdXNlID4gc3BhbiNwbGF5IHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbmRpdi5pbnB1dC1ncm91cCNkcyB7XFxyXFxuICB3aWR0aDogNjAlO1xcclxcbn1cXHJcXG5cXHJcXG4ucGFuZWwge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4ucGFuZWwubm9maWxlOmFmdGVyIHtcXHJcXG4gIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXHJcXG4gIHotaW5kZXg6IDEwO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxyXFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vc3JjL2luZGV4LmNzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/ZGEwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\t// Test for IE <= 9 as proposed by Browserhacks\n\t\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t\t// Tests for existence of standard globals is to allow style-loader \n\t\t// to operate correctly into non-standard environments\n\t\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\t\treturn window && document && document.all && !window.atob;\n\t}),\n\tgetElement = (function(fn) {\n\t\tvar memo = {};\n\t\treturn function(selector) {\n\t\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t\t}\n\t\t\treturn memo[selector]\n\t\t};\n\t})(function (styleTarget) {\n\t\treturn document.querySelector(styleTarget)\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [],\n\tfixUrls = __webpack_require__(7);\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (typeof options.insertInto === \"undefined\") options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar styleTarget = getElement(options.insertInto)\n\tif (!styleTarget) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\tstyleTarget.insertBefore(styleElement, styleTarget.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\tstyleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\tstyleTarget.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\tstyleTarget.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\toptions.attrs.type = \"text/css\";\n\n\tattachTagAttrs(styleElement, options.attrs);\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\tattachTagAttrs(linkElement, options.attrs);\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction attachTagAttrs(element, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\telement.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove, transformResult;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    transformResult = options.transform(obj.css);\n\t    \n\t    if (transformResult) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = transformResult;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css. \n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement, options);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls){\n\t\tcss = fixUrls(css);\n\t}\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcz9iOTgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHRcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0XHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxuXHRcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcblx0fSksXG5cdGdldEVsZW1lbnQgPSAoZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdFx0fTtcblx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXG5cdGZpeFVybHMgPSByZXF1aXJlKFwiLi9maXhVcmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cdGlmICghc3R5bGVUYXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIHN0eWxlVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmUsIHRyYW5zZm9ybVJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHRyYW5zZm9ybVJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXHQgICAgXG5cdCAgICBpZiAodHJhbnNmb3JtUmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gdHJhbnNmb3JtUmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy4gXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscyl7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanM/NGUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bobGraph__ = __webpack_require__(3);\n\r\n\r\n\r\n\r\n// Use webpack loaders to copy needed files to docs directory\r\n__webpack_require__(1);\r\n__webpack_require__(2);\r\n__webpack_require__(0);\r\n\r\n// Immediately Invoked Function Expression\r\n(function () {\r\n  const mchEps = machineEpsilon();\r\n\r\n  // Elementary charge and Boltzmann constant\r\n  const q = 1.60217653E-19,\r\n    k = 1.3806488E-23;\r\n\r\n  let arrayCalc,\r\n    fileOpened = false,\r\n    plotStyle = [],\r\n    userData = {\r\n      estimatedParameters: {\r\n        Rp: undefined\r\n      },\r\n      current: {\r\n        shunt: undefined,\r\n        nonLinear: undefined,\r\n        noIrpNoSCLCarray: undefined\r\n      },\r\n      dataArray: [],\r\n      modifDataArray: []\r\n    },\r\n    parameters = {\r\n      minVolt: undefined,\r\n      maxVolt: undefined,\r\n      stepVolt: undefined,\r\n      iph: undefined,\r\n      t: undefined,\r\n      n1: undefined,\r\n      n2: undefined,\r\n      is1: undefined,\r\n      is2: undefined,\r\n      rp1: undefined,\r\n      rp2: undefined,\r\n      rs: undefined,\r\n      // Methods:\r\n      init: initParameters,\r\n      update: updateParameter\r\n    },\r\n    model = {};\r\n\r\n  // Set parameter object's methods as non-enumerable so they\r\n  // do not show up in a (for in) loop\r\n  Object.defineProperty(parameters, 'init', { enumerable: false });\r\n  Object.defineProperty(parameters, 'update', { enumerable: false });\r\n\r\n  function initParameters() {\r\n    // Used as a method by parameter object\r\n    for (let property in this) {\r\n      const $inputNumber = $('[type=number].' + property),\r\n        $inputCheckBox = $('[type=checkbox].' + property);\r\n      this[property] = {\r\n        value: parseFloat($inputNumber.val()),\r\n        checked: $inputCheckBox.is(':checked')\r\n      };\r\n    }\r\n  }\r\n\r\n  function updateParameter($element) {\r\n    // Used as a method by parameter object\r\n    for (let property in this) {\r\n      if ($element.hasClass(property)) {\r\n        const elementValue = parseFloat($element.val()),\r\n          inputIsLogRange = $element.hasClass('logscale') && $element.attr('type') === 'range',\r\n          newValue = (inputIsLogRange) ? Math.pow(10, elementValue) : elementValue;\r\n        this[property] = {\r\n          value: newValue,\r\n          checked: $element.is(':checked')\r\n        };\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function machineEpsilon() {\r\n    // Calculate Machine Epsilon\r\n    let temp1, temp2;\r\n    temp1 = 1.0;\r\n    do {\r\n      temp1 /= 2;\r\n      temp2 = 1.0 + temp1;\r\n    } while (temp2 > 1.0);\r\n    return temp1;\r\n  }\r\n\r\n  $(function () {\r\n    // When page is loaded\r\n\r\n    $('input[type=radio].default')\r\n      .attr('checked', true);\r\n\r\n    clearFileInput();\r\n\r\n    parameters.init();\r\n\r\n    model = getModel();\r\n\r\n    // Calculate a first time\r\n    // IV using the initial parameters\r\n    calcIVandPlot();\r\n\r\n    bindEvents();\r\n  });\r\n\r\n  function bindEvents() {\r\n    $('input[type=range].syncme')\r\n      .on('input', inputEvent)\r\n      .mouseup(rangeInputMouseUp);\r\n\r\n    $('input[type=number].syncme')\r\n      .change(inputEvent)\r\n      .keydown(numberInputKeyDown)\r\n      .blur(changeStep);\r\n\r\n    $('input[type=number].voltage')\r\n      .change(voltageInputChanged);\r\n\r\n    $('input[type=radio].model')\r\n      .change(modelChanged);\r\n\r\n    $('input[type=radio].scale')\r\n      .change(changeScaleType);\r\n\r\n    $(':file')\r\n      .change(fileInputChanged);\r\n\r\n    $('.fa-toggle-on, .fa-toggle-off')\r\n      .click(faToggleClicked);\r\n\r\n    $('#useestimatedparams')\r\n      .click(useEstimatedParams);\r\n\r\n    $('button#start')\r\n      .click(startButtonClicked);\r\n\r\n    $('input#clear')\r\n      .click(clearData);\r\n\r\n    $('[type=checkbox]')\r\n      .change(parameterCheckBoxChanged);\r\n  }\r\n\r\n  function changeScaleType() {\r\n    // Event handler\r\n    // fired when user clicks on a scale type radio button\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function rangeInputMouseUp() {\r\n    // Event handler\r\n    adjustRange(this);\r\n  }\r\n\r\n  function numberInputKeyDown(event) {\r\n    const keyCode = event.which,\r\n      upOrDownArrowKeyDown = keyCode == 38 || keyCode == 40;\r\n\r\n    if (upOrDownArrowKeyDown) {\r\n      syncInputs(this);\r\n      adjustRange(this);\r\n      calcIVandPlot();\r\n    }\r\n  }\r\n\r\n  function calcIVandPlot() {\r\n    const ivResult = calcIV(parameters, getModel());\r\n\r\n    arrayCalc = ivResult.arrayCalc;\r\n    plotStyle = ivResult.plotStyle;\r\n\r\n    // and plot the result\r\n    combDataAndCalc();\r\n  }\r\n\r\n  function fileInputChanged() {\r\n    // Fired when user selects a new file\r\n    // to import\r\n    const file = this.files[0];\r\n    $(this)\r\n      .closest('.input-group')\r\n      .children('input:text')\r\n      .val(file.name);\r\n    processFiles(file);\r\n  }\r\n\r\n  function faToggleClicked() {\r\n    // Fired when user clicks on any of the font-awesome toggle icons\r\n    // As of now there are 2 of these icons on the page\r\n    const iElem = this; // <i> element\r\n\r\n    $(iElem)\r\n      .toggleClass('fa-toggle-on fa-toggle-off');\r\n\r\n    if (iElem.id === 'hideIrp') {\r\n      userData.modifDataArray = toggleIrp(userData.modifDataArray, userData.current.shunt, IprShowed());\r\n      combDataAndCalc();\r\n    }\r\n\r\n    if (iElem.id === 'hideNonLinCurr') {\r\n      const toggleResult = toggleNonLinCurr(userData, userData.modifDataArray, nonLinearCurrentShowed());\r\n      userData.dataArray = toggleResult.dataArray;\r\n      userData.modifDataArray = toggleResult.modifDataArray;\r\n      combDataAndCalc();\r\n    }\r\n  }\r\n\r\n  function parameterCheckBoxChanged() {\r\n    /* Fired when user clicks on any of the checkbox inputs\r\n    These checkboxes define whether the corresponding diode\r\n    parameter varies or not during optimization\r\n    Therefore, if unchecked, the parameter will not be estimated. */\r\n    findAndEstimateDiodes();\r\n  }\r\n\r\n  function syncInputs(sourceElem) {\r\n    // Sync range and number inputs\r\n\r\n    const $sourceInput = $(sourceElem),\r\n      isSourceRange = $sourceInput.attr('type') === 'range',\r\n      targetType = (isSourceRange) ? 'number' : 'range',\r\n      sourceValue = $sourceInput.val();\r\n\r\n    // Sync companion input\r\n    const $targetInput = $sourceInput\r\n      .closest('.row')\r\n      .find('input.syncme[type=' + targetType + ']'),\r\n      isScaleLog = $targetInput.hasClass('logscale');\r\n\r\n    if (isScaleLog) {\r\n      const targetValue = (isSourceRange) ? Math.pow(10, sourceValue).toExponential(2) : log10(sourceValue);\r\n      $targetInput.val(targetValue);\r\n    } else {\r\n      // Linear scale\r\n      $targetInput.val(sourceValue);\r\n    }\r\n  }\r\n\r\n  function syncAllInputs() {\r\n    $('input[type=number].syncme')\r\n      .each(function (index, element) {\r\n        syncInputs(element);\r\n      });\r\n  }\r\n\r\n  function inputEvent() {\r\n    // Event handler\r\n    // fired when user moves range input or change number input.\r\n    // So \"this\" is a number or range input element\r\n\r\n    const isNumberInput = $(this).attr('type') === 'number';\r\n\r\n    if (isNumberInput) {\r\n      adjustRange(this);\r\n    }\r\n\r\n    syncInputs(this);\r\n\r\n    parameters.update($(this));\r\n\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function voltageInputChanged() {\r\n    // Fired when one of the 3 .voltage inputs is changed by user\r\n\r\n    parameters\r\n      .update($(this));\r\n\r\n    checkVoltageInputs();\r\n\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function checkVoltageInputs() {\r\n    const minVolt = parameters.minVolt.value,\r\n      maxVolt = parameters.maxVolt.value,\r\n      stepVolt = parameters.stepVolt.value;\r\n\r\n    // Make sure maxVolt > minVolt\r\n    if (maxVolt < minVolt) {\r\n      document.getElementById('minVolt').value = maxVolt;\r\n      document.getElementById('maxVolt').value = minVolt;\r\n    }\r\n\r\n    // Make sure stepVolt != 0\r\n    if (stepVolt == 0) {\r\n      document.getElementById('stepVolt').value = 25;\r\n    }\r\n\r\n    // Make sure stepVolt > 0\r\n    if (stepVolt < 0) {\r\n      document.getElementById('stepVolt').value = Math.abs(stepVolt);\r\n    }\r\n  }\r\n\r\n  function log10(val) {\r\n    // Returns base 10 logarithmic\r\n    // (Math.log10() method is not supported by IE11)\r\n    // Could stop using this function with a transpiler\r\n    return Math.log(val) / Math.log(10);\r\n  }\r\n\r\n  function remDecimals(model, number) {\r\n    // Change a number's precision\r\n    const nbDecimals = nbAfterDot(model);\r\n    return Math.round(number * Math.pow(10, nbDecimals)) * Math.pow(10, -nbDecimals);\r\n  }\r\n\r\n  function nbAfterDot(number) {\r\n    // Return the number of digits\r\n    // after decimal separator\r\n    const n = number.toString().indexOf('.');\r\n    if (n == -1) {\r\n      return 0;\r\n    }\r\n    else {\r\n      let i = 0;\r\n      while (number.charAt(n + 1 + i) != '' && isFinite(number.charAt(n + 1 + i))) {\r\n        i++;\r\n      }\r\n      return i;\r\n    }\r\n  }\r\n\r\n  function getRowDiv($input) {\r\n    // Get parameter inputs'\r\n    // closest common ancestor\r\n    return $input\r\n      .closest('.row');\r\n  }\r\n\r\n  function adjustRange(element) {\r\n    // When value reaches input's range limit,\r\n    // modifies range so user is able to use it again\r\n\r\n    const $input = $(element),\r\n      inputType = $input.attr('type'),\r\n      $rowDiv = getRowDiv($input);\r\n\r\n    let $rangeInput = $input,\r\n      rangeInputElem = element,\r\n      $numberInput = $rowDiv\r\n        .find('[type=number]'),\r\n      numberInputElem = $numberInput.get(0);\r\n\r\n    if (inputType === 'number') {\r\n      $rangeInput = $rowDiv\r\n        .find('[type=range]');\r\n      rangeInputElem = $rangeInput.get(0);\r\n      $numberInput = $input;\r\n      numberInputElem = element;\r\n    }\r\n\r\n    let rangeChanged = false;\r\n\r\n    const rangeMax = parseFloat(rangeInputElem.max),\r\n      rangeMin = parseFloat(rangeInputElem.min),\r\n      numberValue = parseFloat(numberInputElem.value);\r\n\r\n    if ($rangeInput.hasClass('linearscale')) {\r\n      if (numberValue >= rangeMax) {\r\n        rangeInputElem.max = remDecimals(numberValue, 1.6 * numberValue);\r\n        rangeInputElem.value = numberValue;\r\n        rangeInputElem.min = remDecimals(numberValue, 0.4 * numberValue);\r\n        rangeChanged = true;\r\n      } else {\r\n        if (numberValue <= rangeMin) {\r\n          rangeInputElem.min = remDecimals(numberInputElem.value, 0.4 * numberInputElem.value);\r\n          rangeInputElem.value = numberInputElem.value;\r\n          rangeInputElem.max = remDecimals(numberInputElem.value, 1.6 * numberInputElem.value);\r\n          rangeChanged = true;\r\n        }\r\n      }\r\n      while (2 * rangeInputElem.step >= (rangeInputElem.max - rangeInputElem.min)) {\r\n        rangeInputElem.max = 2 * rangeInputElem.step + rangeInputElem.max;\r\n      }\r\n    } else {\r\n      // When scale is Log\r\n      if (numberValue >= Math.pow(10, rangeMax)) {\r\n        rangeInputElem.max = Math.round(log10(numberValue) + 3);\r\n        rangeInputElem.value = numberValue;\r\n        rangeInputElem.min = Math.round(log10(numberValue) - 3);\r\n        rangeChanged = true;\r\n      } else {\r\n        if (numberValue <= Math.pow(10, rangeMin)) {\r\n          rangeInputElem.min = Math.round(log10(numberValue) - 3);\r\n          rangeInputElem.value = numberValue;\r\n          rangeInputElem.max = Math.round(log10(numberValue) + 3);\r\n          rangeChanged = true;\r\n        }\r\n      }\r\n    }\r\n    return rangeChanged;\r\n  }\r\n\r\n  function changeStep() {\r\n    // Event handle fired when\r\n    // user blurs number input\r\n    let numberInputElem = this,\r\n      $rangeInput = getRowDiv($(numberInputElem))\r\n        .find('[type=range]'),\r\n      value = numberInputElem.value;\r\n\r\n    if ($rangeInput.hasClass('linearscale')) {\r\n      numberInputElem.value = parseFloat(value); // For Chrome\r\n      var newStep = Math.pow(10, -1 * nbAfterDot(value));\r\n\r\n      numberInputElem.step = newStep;\r\n    }\r\n\r\n    $rangeInput.get().step = newStep;\r\n  }\r\n\r\n  function modelChanged() {\r\n    // Fired when user changes number of diodes or the equivalent circuit\r\n\r\n    // Update model variable\r\n    model = getModel();\r\n\r\n    changeInputStatusBasedOnModel();\r\n\r\n    calcIVandPlot();\r\n\r\n    if (fileOpened) {\r\n      findAndEstimateDiodes();\r\n\r\n      calcSqResSum(parameters, userData.dataArray, arrayCalc);\r\n    }\r\n  }\r\n\r\n  function changeInputStatusBasedOnModel() {\r\n    if (model.circuit === 'parallel') {\r\n      $('input.rp2')\r\n        .prop('disabled', true);\r\n\r\n      const $inputs = $('input.n2, input.is2, #series, #parallel');\r\n\r\n      if (!fileOpened) {\r\n        $inputs\r\n          .not('[type=checkbox]');\r\n      }\r\n\r\n      $inputs\r\n        .prop('disabled', false);\r\n\r\n      document.getElementById('start').disabled = false;\r\n    }\r\n\r\n    if (model.diodeCount === 1) {\r\n      document.getElementById('series').checked = false;\r\n      document.getElementById('parallel').checked = true;\r\n\r\n      model.circuit = 'parallel';\r\n\r\n      $('input.n2, input.is2, #series, #parallel, input.rp2')\r\n        .prop('disabled', true);\r\n\r\n      if (fileOpened) {\r\n        // Will also enable checkboxes\r\n        $('input.n1, input.is1, input.rp1')\r\n          .prop('disabled', false);\r\n      }\r\n\r\n      document.getElementById('start').disabled = false;\r\n    }\r\n\r\n    if (model.circuit === 'series') {\r\n      $('input.n2, input.is2, input.rp2')\r\n        .prop('disabled', false);\r\n\r\n      // Disable fitting inputs because\r\n      // series model not supported for optimization\r\n      disableCheckboxes();\r\n      $('button#start')\r\n        .prop('disabled', true);\r\n    }\r\n  }\r\n\r\n  function disableCheckboxes() {\r\n    $('[type=checkbox]')\r\n      .prop('disabled', true);\r\n  }\r\n\r\n  function findAndEstimateDiodes() {\r\n    const findDiodesResult = findDiodes(userData, IprShowed(), nonLinearCurrentShowed()),\r\n      estimatedParams = estimD1D2Rs(getAllParams(), userData, findDiodesResult);\r\n\r\n    displayEstimatedParams(estimatedParams);\r\n  }\r\n\r\n  function displayEstimatedParams(estimatedParams) {\r\n    // Display the result of estimD1D2Rs into\r\n    // the results table\r\n\r\n    for (let paramName in estimatedParams) {\r\n      const id = paramName.toLowerCase(),\r\n        value = estimatedParams[paramName],\r\n        text = (isParamScaleLog(id)) ? value.toExponential(2) : value.toPrecision(2);\r\n\r\n      $('td.estimation#' + id)\r\n        .text(text);\r\n    }\r\n  }\r\n\r\n  function isParamScaleLog(elemID) {\r\n    // Returns whether scale type used for\r\n    // a given diode parameter is a logarithmic one\r\n    return $('[type=number]#' + elemID)\r\n      .hasClass('logscale');\r\n  }\r\n\r\n  function useEstimatedParams() {\r\n    // Fired when user clicks \"Use estimated parameters\" button\r\n    $('td.estimation')\r\n      .each(updateInput);\r\n\r\n    syncAllInputs();\r\n\r\n    parameters.init();\r\n\r\n    calcIVandPlot();\r\n  }\r\n\r\n  function updateInput(index, element) {\r\n    // Update a parameter input with an estimation\r\n\r\n    const $td = $(element),\r\n      paramClass = $td.attr('id'),\r\n      $input = $('input[type=number].' + paramClass);\r\n\r\n    if ($input.prop('disabled') === false) {\r\n      const value = parseFloat($td.text());\r\n      $input.val(value);\r\n    }\r\n  }\r\n\r\n  function startButtonClicked() {\r\n    // Fired when user clicks on the play/pause button\r\n    // to start or pause the fitting\r\n\r\n    const start = $(this)\r\n      .hasClass('play');\r\n\r\n    togglePlayButton();\r\n\r\n    startPauseVary(start);\r\n  }\r\n\r\n  function togglePlayButton() {\r\n    $('#start')\r\n      .toggleClass('play pause');\r\n  }\r\n\r\n  /* The two following functions calculate\r\n     the current at a given voltage */\r\n\r\n  function Iparallel(V, Iph, prevI, T, n1, n2, Is1, Is2, Rp, Rs) {\r\n    // Double diode (in parallel) model\r\n    let i = 0, I, f, df, r, Id1, Id2, Irp;\r\n\r\n    Iph = Iph / 1000; // mA -> A\r\n\r\n    if (!prevI) {\r\n      I = Iph;\r\n      prevI = I;\r\n    }\r\n\r\n    do {\r\n      if (i > 0) {\r\n        prevI = I;\r\n      }\r\n\r\n      Id1 = Is1 * (Math.exp(q * (V + prevI * Rs) / (n1 * k * T)) - 1);\r\n      Id2 = Is2 * (Math.exp(q * (V + prevI * Rs) / (n2 * k * T)) - 1);\r\n      Irp = (V + prevI * Rs) / Rp;\r\n\r\n      // f(V,prevI)\r\n      f = Iph - Id1 - Id2 - Irp - prevI;\r\n\r\n      // df(V,prevI)/dprevI\r\n      df = -((Is1 * Rs) / (n1 * T * k / q)) * Math.exp((V + prevI * Rs) / (n1 * T * k / q))\r\n        - ((Is2 * Rs) / (n2 * T * k / q)) * Math.exp((V + prevI * Rs) / (n2 * T * k / q))\r\n        - Rs / Rp - 1;\r\n\r\n      // f/df\r\n      r = f / df;\r\n\r\n      I = prevI - r;\r\n\r\n      i++;\r\n\r\n    } while (Math.abs(I - prevI) > mchEps && i < 500);\r\n\r\n    return [I, Id1, Id2, Irp, Id1 + Id2 + Irp];\r\n  }\r\n\r\n  function Iseries(V, T, Iph, n1, n2, Is1, Is2, Rp1, Rp2, Rs) {\r\n    // Double diode (in series) model\r\n    let i = 0, Ia, Ib, V1, V2, Id1, Id2, Irp1, Irp2, H = 10, L = -10;\r\n\r\n    do {\r\n      V1 = (H + L) / 2;\r\n\r\n      Id1 = Is1 * Math.exp(q * V1 / (n1 * k * T) - 1);\r\n      Irp1 = V1 / Rp1;\r\n\r\n      Ia = Id1 + Irp1;\r\n\r\n      V2 = V - V1 - Rs * Ia;\r\n\r\n      Id2 = Is2 * Math.exp(q * V2 / (n2 * k * T) - 1);\r\n      Irp2 = V2 / Rp2;\r\n      Ib = Id2 + Irp2;\r\n\r\n      var diffI = Ib - Ia;\r\n\r\n      if (diffI > 0) {\r\n        L = V1;\r\n      } else {\r\n        H = V1;\r\n      }\r\n      i++;\r\n\r\n    } while (Math.abs(diffI) > mchEps && i < 500);\r\n    return [Ia, Id1, Id2, Irp1, Irp2];\r\n  }\r\n\r\n  function getParam$(paramClass) {\r\n    return $('input[type=number]')\r\n      .filter('.' + paramClass);\r\n  }\r\n\r\n  function getParamValue(paramClass) {\r\n    return parseFloat(\r\n      getParam$(paramClass)\r\n        .val()\r\n    );\r\n  }\r\n\r\n  function getParamChecked(paramClass) {\r\n    return $('input[type=checkbox]')\r\n      .filter('.' + paramClass)\r\n      .is(':checked');\r\n  }\r\n\r\n  function getAllParams() {\r\n    let params = {\r\n      value: {\r\n        iph: undefined,\r\n        t: undefined,\r\n        n1: undefined,\r\n        n2: undefined,\r\n        is1: undefined,\r\n        is2: undefined,\r\n        rp1: undefined,\r\n        rp2: undefined,\r\n        rs: undefined\r\n      },\r\n      checked: {\r\n        iph: undefined,\r\n        t: undefined,\r\n        n1: undefined,\r\n        n2: undefined,\r\n        is1: undefined,\r\n        is2: undefined,\r\n        rp1: undefined,\r\n        rp2: undefined,\r\n        rs: undefined\r\n      }\r\n    };\r\n\r\n    for (let paramClass in params.value) {\r\n      params.value[paramClass] = getParamValue(paramClass);\r\n      params.checked[paramClass] = getParamChecked(paramClass);\r\n    }\r\n    return params;\r\n  }\r\n\r\n  function setParamValue(paramClass, value) {\r\n    getParam$(paramClass)\r\n      .val(value);\r\n  }\r\n\r\n  function getModel() {\r\n    const isSingleDiodeChecked = document.getElementById('singleDiode').checked,\r\n      isParallelChecked = document.getElementById('parallel').checked;\r\n    return {\r\n      diodeCount: (isSingleDiodeChecked) ? 1 : 2,\r\n      circuit: (isParallelChecked) ? 'parallel' : 'series'\r\n    };\r\n  }\r\n\r\n  function calcIV(params, model) {\r\n    // Calculates current for a range of voltage values\r\n\r\n    const minVolt = params.minVolt.value,\r\n      maxVolt = params.maxVolt.value,\r\n      stepVolt = params.stepVolt.value,\r\n      Iph = params.iph.value,\r\n      T = params.t.value,\r\n      n1 = params.n1.value,\r\n      Is1 = params.is1.value;\r\n\r\n    let n2 = params.n2.value,\r\n      Is2 = params.is2.value,\r\n      Rp2 = params.rp2.value;\r\n\r\n    if (model.diodeCount === 1) {\r\n      n2 = 1;\r\n      Is2 = 0;\r\n      Rp2;\r\n    }\r\n\r\n    var Rp = params.rp1.value,\r\n      Rs = params.rs.value;\r\n\r\n    let Ipar, Iser, I, Id1, Id2,\r\n      arrayVI = [],\r\n      arrayVId1 = [],\r\n      arrayVId2 = [],\r\n      arrayVIrp1 = [],\r\n      arrayVIrp2 = [],\r\n      parallel, modelCase;\r\n\r\n    if (model.circuit === 'parallel') {\r\n      parallel = true,\r\n        modelCase = 'parallel';\r\n    }\r\n\r\n    if (model.diodeCount === 1) {\r\n      parallel = true,\r\n        modelCase = 'single';\r\n    }\r\n    if (model.circuit === 'series') {\r\n      modelCase = 'series';\r\n    }\r\n\r\n    for (var V = minVolt; V <= maxVolt; V += stepVolt / 1000) {\r\n      if (parallel) {\r\n        Ipar = Iparallel(V, Iph, I, T, n1, n2, Is1, Is2, Rp, Rs);\r\n        I = - Ipar[0];\r\n        Id1 = Ipar[1];\r\n        Id2 = Ipar[2];\r\n        var Irp = Ipar[3];\r\n        arrayVIrp1.push([V, Irp]);\r\n        // Calculated current is used as the initial current for next voltage,\r\n        // speeds up equation solving, is important for high direct bias\r\n      } else {\r\n        Iser = Iseries(V, T, Iph, n1, n2, Is1, Is2, Rp, Rp2, Rs);\r\n        I = Iser[0];\r\n        Id1 = Iser[1];\r\n        Id2 = Iser[2];\r\n        var Irp1 = Iser[3],\r\n          Irp2 = Iser[4];\r\n        arrayVIrp1.push([V, Irp1]);\r\n        arrayVIrp2.push([V, Irp2]);\r\n      }\r\n\r\n      arrayVI.push([V, I]);\r\n      arrayVId1.push([V, Id1]);\r\n      arrayVId2.push([V, Id2]);\r\n    }\r\n\r\n    const modelCases = {\r\n      parallel: {\r\n        arrayCalc: [arrayVI, arrayVId1, arrayVId2, arrayVIrp1],\r\n        plotStyle: [\r\n          ['line', 'black', 'I'],\r\n          ['line', 'orange', 'Id1'],\r\n          ['line', 'orange', 'Id2'],\r\n          ['line', 'purple', 'Irp']\r\n        ]\r\n      },\r\n      single: {\r\n        arrayCalc: [arrayVI, arrayVId1, arrayVIrp1],\r\n        plotStyle: [\r\n          ['line', 'black', 'I'],\r\n          ['line', 'orange', 'Id1'],\r\n          ['line', 'purple', 'Irp']\r\n        ]\r\n      },\r\n      series: {\r\n        arrayCalc: [arrayVI, arrayVId1, arrayVId2, arrayVIrp1, arrayVIrp1],\r\n        plotStyle: [\r\n          ['line', 'black', 'I'],\r\n          ['line', 'orange', 'Id1'],\r\n          ['line', 'orange', 'Id2'],\r\n          ['line', 'purple', 'Irp1'],\r\n          ['line', 'purple', 'Irp2']\r\n        ]\r\n      }\r\n    };\r\n\r\n    return modelCases[modelCase];\r\n  }\r\n\r\n  function scaleType() {\r\n    // Returns the type of scale for y axis\r\n    const scaleIsLinear = document.getElementById('linear').checked;\r\n    return (scaleIsLinear) ? 'linearScale' : 'logScale';\r\n  }\r\n\r\n  function processFiles(file) {\r\n    // Fired when file input changed\r\n\r\n    let reader = new FileReader();\r\n\r\n    reader.onload = readerOnLoad;\r\n    reader.filename = file.name;\r\n\r\n    reader.readAsText(file);\r\n  }\r\n\r\n  function readerOnLoad(event) {\r\n    // Fired when data is ready\r\n\r\n    // Guess T from file name\r\n    let fileName = this.filename;\r\n\r\n    while (isNaN(parseFloat(fileName)) && fileName.length > 0) {\r\n      fileName = fileName.substring(1);\r\n    }\r\n\r\n    fileName = parseFloat(fileName);\r\n\r\n    const defaultT = (isNaN(fileName)) ? 298 : fileName,\r\n      T = prompt('Temperature? (K)', defaultT);\r\n\r\n    if (isFinite(T) && T > 0) {\r\n      setParamValue('t', T);\r\n      // document.getElementById('sliderT').value = T;\r\n      userData.dataArray = [];\r\n      userData.modifDataArray = [];\r\n\r\n      stringToArray(event.target.result);\r\n    }\r\n  }\r\n\r\n  function clearData() {\r\n    // Fired when user clicks on the Clear button\r\n\r\n    userData.dataArray = [];\r\n    userData.modifDataArray = [];\r\n    fileOpened = false;\r\n    combDataAndCalc();\r\n\r\n    $('.panel')\r\n      .addClass('nofile');\r\n\r\n    $('.fa-toggle-on')\r\n      .toggleClass('fa-toggle-on fa-toggle-off');\r\n\r\n    if (window.localFile /* FF is picky about that: not importing the file through classic 'browse' button result in an error here */) {\r\n      window.localFile.reset();\r\n    }\r\n\r\n    clearFileInput();\r\n\r\n    $('.estimation')\r\n      .add('.final')\r\n      .add('#s')\r\n      .add('#ds')\r\n      .empty();\r\n\r\n    if ($('#start').hasClass('pause')) {\r\n      togglePlayButton();\r\n    }\r\n\r\n    userData.estimatedParameters.Rp = undefined;\r\n\r\n    disableCheckboxes();\r\n  }\r\n\r\n  function clearFileInput() {\r\n    $('input[type=file]')\r\n      .val(null)\r\n      .closest('div')\r\n      .children('input[type=text]')\r\n      .val('');\r\n  }\r\n\r\n  function stringToArray(data) {\r\n    // Convert the dataset from a string\r\n    // to an array of arrays of numbers\r\n\r\n    let array = data.split('\\n'),\r\n      skipRow,\r\n      dataArray = [];\r\n\r\n    for (let stringRow of array) {\r\n      skipRow = false;\r\n      const row = stringRow.split('\\t');\r\n\r\n      // Make sure each of the first two\r\n      // elements in the row is a number\r\n      for (let j = 0; j < 2; j++) {\r\n        row[j] = Number(row[j]);\r\n        skipRow += isNaN(row[j]);\r\n      }\r\n\r\n      if (!skipRow) {\r\n        dataArray.push(row);\r\n      }\r\n    }\r\n\r\n    // Removes the semi-transparent\r\n    // overlay div\r\n    $('.panel')\r\n      .removeClass('nofile');\r\n\r\n    fileOpened = true;\r\n\r\n    // Enable checkboxes for the already\r\n    // enabled parameter inputs\r\n    $('[type=range]:enabled')\r\n      .each(enableCheckboxInput);\r\n\r\n    document.getElementById('minVolt').value = dataArray[0][0];\r\n    document.getElementById('maxVolt').value = dataArray[dataArray.length - 1][0] + document.getElementById('stepVolt').value / 1000;\r\n\r\n    dataArray = [dataArray];\r\n\r\n    userData.dataArray = dataArray;\r\n    userData.modifDataArray = dataArray;\r\n\r\n    const ivResult = calcIV(parameters, getModel());\r\n\r\n    /**** Estimate parameters ****/\r\n\r\n    // Parallel resistance Rp\r\n    const Rp = estimRp(dataArray);\r\n    userData.estimatedParameters.Rp = Rp;\r\n\r\n    // Calculate Parallel current and non linear reverse current\r\n    const current = calcIrpAndNonLinRevCurr(dataArray, Rp);\r\n    userData.current.nonLinear = current.nonLinear;\r\n    userData.current.shunt = current.shunt;\r\n\r\n    findAndEstimateDiodes();\r\n\r\n    calcSqResSum(parameters, dataArray, arrayCalc);\r\n\r\n    combDataAndCalc(ivResult);\r\n  }\r\n\r\n  function enableCheckboxInput(index, element) {\r\n    getRowDiv($(element))\r\n      .find('[type=checkbox]')\r\n      .prop('disabled', false);\r\n  }\r\n\r\n  function IprShowed() {\r\n    return $('#hideIrp').hasClass('fa-toggle-off');\r\n  }\r\n\r\n  function nonLinearCurrentShowed() {\r\n    return $('#hideNonLinCurr').hasClass('fa-toggle-off');\r\n  }\r\n\r\n  function combDataAndCalc() {\r\n    // Combine uploaded data and calculated IV into one graph\r\n    const canvasID = 'graph',\r\n      data = userData.modifDataArray.concat(arrayCalc),\r\n      primaryPlotIndex = 0,\r\n      xTitle = 'V (V)',\r\n      yTitle = 'I (A)';\r\n    let style;\r\n\r\n    if (fileOpened) {\r\n      const dataStyle = [['verticalCross', 'purple', 'Data']];\r\n      style = dataStyle.concat(plotStyle);\r\n    } else {\r\n      style = plotStyle;\r\n    }\r\n\r\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_bobGraph__[\"a\" /* default */])(canvasID, data, primaryPlotIndex, style, scaleType(), xTitle, yTitle);\r\n  }\r\n\r\n  function tableSuccessContext(add) {\r\n    // Add or remove \"success\" color on\r\n    // parameter's table's 3rd column\r\n\r\n    const $td = $('td.final');\r\n\r\n    if (add) {\r\n      $td.addClass('success');\r\n    } else {\r\n      $td.removeClass('success');\r\n    }\r\n  }\r\n\r\n  /*\r\n   *  Fit \r\n   */\r\n\r\n\r\n  let interval;\r\n\r\n  function estimRp(dataArray) {\r\n    // Estimate parallel resistance Rp\r\n    let min = +Infinity,\r\n      array = dataArray[0];\r\n\r\n    for (let xy of array) {\r\n      let x = xy[0],\r\n        slope = xy[1] / x;\r\n      if (slope < min && Math.abs(x) > 0.001) {\r\n        min = slope;\r\n      }\r\n    }\r\n\r\n    let Rp = 1 / min;\r\n    // var oOM = orderOfMagn(Rp);\r\n    //var roundedRp = Math.round(Rp * 1000 / oOM) * oOM / 1000;\r\n\r\n    return Rp;\r\n  }\r\n\r\n  function calcIrpAndNonLinRevCurr(dataArray, Rp) {\r\n    let array = dataArray[0],\r\n      nonLinDirCurr = [],\r\n      shuntCurrent = [],\r\n      nonLinCurr = [];\r\n\r\n    for (let VI of array) {\r\n      let V = VI[0],\r\n        Irp = V / Rp;\r\n      shuntCurrent.push([V, Irp]);\r\n\r\n      if (V < -0.0001) {\r\n        // Only looking at reverse polarization:\r\n        // Non-linear reverse current is total current minus parallel current (which is linear)\r\n        let Inl = VI[1] - Irp; // Inl -> 'nl' = 'Non-Linear'\r\n\r\n        // Deduce direct non linear current\r\n        nonLinDirCurr.unshift([-V, -Inl]);\r\n\r\n        // Reverse\r\n        nonLinCurr.push([V, Inl]);\r\n      }\r\n    }\r\n\r\n    // Combine reverse and direct\r\n    nonLinCurr = nonLinCurr.concat([[0, 0]], nonLinDirCurr);\r\n\r\n    return {\r\n      shunt: shuntCurrent,\r\n      nonLinear: nonLinCurr\r\n    };\r\n  }\r\n\r\n  function toggleIrp(modifDataArray, shuntCurrent, show) {\r\n    // Show or hide Irp on graph\r\n\r\n    let array = modifDataArray[0],\r\n      newArray = [],\r\n      i = 0,\r\n      sign = (show) ? 1 : -1;\r\n\r\n    for (let IV of array) {\r\n      newArray.push([IV[0], IV[1] + sign * shuntCurrent[i][1]]);\r\n      i++;\r\n    }\r\n\r\n    modifDataArray = [newArray];\r\n\r\n    return modifDataArray;\r\n  }\r\n\r\n  function toggleNonLinCurr(userData, modifDataArray, show) {\r\n\r\n    const nonLinearCurrent = userData.current.nonLinear;\r\n\r\n    let array1 = userData.dataArray[0],\r\n      array2 = userData.modifDataArray[0],\r\n      IV2,\r\n      newArray1 = [],\r\n      newArray2 = [],\r\n      sign = (show) ? 1 : -1,\r\n      i = 0;\r\n\r\n    for (let IV1 of array1) {\r\n      newArray1.push([IV1[0], IV1[1] + sign * nonLinearCurrent[i][1]]);\r\n      IV2 = array2[i];\r\n      newArray2.push([IV2[0], IV2[1] + sign * nonLinearCurrent[i][1]]);\r\n      i++;\r\n    }\r\n\r\n    return {\r\n      dataArray: [newArray1],\r\n      modifDataArray: [newArray2]\r\n    };\r\n  }\r\n\r\n  let SqResSum,\r\n    delS = [];\r\n\r\n  function calcSqResSum(params, dataArray, arrayCalc) {\r\n    // Calculates the sum of squared residuals\r\n\r\n    let n1 = params.n1.value,\r\n      Is1 = params.is1.value,\r\n      Rp = params.rp1.value,\r\n      Rs = params.rs.value,\r\n      T = params.t.value,\r\n      single = document.getElementById('singleDiode').checked,\r\n      n2, Is2;\r\n\r\n    SqResSum = 0;\r\n\r\n    if (single) {\r\n      // Single diode model\r\n      Is2 = 0;\r\n      n2 = 1;\r\n    } else {\r\n      // Dual diode model\r\n      Is2 = params.is2.value;\r\n      n2 = params.n2.value;\r\n    }\r\n\r\n    if (document.getElementById('series').checked) {\r\n      // Dual, series diode model\r\n      n1 = params.n1.value;\r\n    }\r\n\r\n    let r, calcI, j = 1, x1, x2, xy1, xy2, y1, y2, slope, x,\r\n      calcIV = arrayCalc[0],\r\n      array = dataArray[0],\r\n      data,\r\n      dSdn1 = 0,\r\n      dSdn2 = 0,\r\n      dSdIs1 = 0,\r\n      dSdIs2 = 0,\r\n      dSdRp = 0,\r\n      dSdRs = 0;\r\n\r\n    let dIdn1, dIdn2, dIdIs1, dIdIs2, dIdRp, dIdRs, exp1, exp2;\r\n\r\n    for (let row of array) {\r\n      // For each data point\r\n      x = row[0];\r\n\r\n      while (x > calcIV[j][0]) { j++; }\r\n      xy1 = calcIV[j - 1];\r\n      xy2 = calcIV[j];\r\n      x1 = xy1[0];\r\n      x2 = xy2[0];\r\n      y1 = xy1[1];\r\n      y2 = xy2[1];\r\n      data = row[1];\r\n\r\n      // Linear interpolation\r\n      slope = (y2 - y1) / (x2 - x1);\r\n      calcI = y1 + slope * (x - x1);\r\n\r\n      r = (calcI - data) / Math.abs(data);\r\n\r\n      if (isFinite(r)) {\r\n        exp1 = Math.exp(q * (x - Rs * calcI) / (n1 * k * T));\r\n        exp2 = Math.exp(q * (x - Rs * calcI) / (n2 * k * T));\r\n\r\n        dIdn1 = q * (Rs * calcI - x) / (Math.pow(n1, 2) * k * T * (1 + Rs / Rp + q * Is2 * Rs * exp2 / (n2 * k * T)) / (Is1 * exp1) + n1 * Rs * q);\r\n        dSdn1 += 2 * r * dIdn1 / Math.abs(data);\r\n\r\n        dIdn2 = q * (Rs * calcI - x) / (Math.pow(n2, 2) * k * T * (1 + Rs / Rp + q * Is1 * Rs * exp1 / (n1 * k * T)) / (Is2 * exp2) + n2 * Rs * q);\r\n        dSdn2 += 2 * r * dIdn2 / Math.abs(data);\r\n\r\n        dIdIs1 = (exp1 - 1) / (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + q * Is2 * Rs * exp2 / (n2 * k * T) + Rs / Rp);\r\n        //dIdIs1 = (exp1 - 1) / (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + Rs / Rp);\r\n        dSdIs1 += 2 * r * dIdIs1 / Math.abs(data);\r\n\r\n        dIdIs2 = (exp2 - 1) / (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + q * Is2 * Rs * exp2 / (n2 * k * T) + Rs / Rp);\r\n        dSdIs2 += 2 * r * dIdIs2 / Math.abs(data);\r\n\r\n        dIdRp = (calcI * Rs - x) / (Math.pow(Rp, 2) * (1 + q * Is1 * Rs * exp1 / (n1 * k * T) + q * Is2 * Rs * exp2 / (n2 * k * T) + Rs / Rp));\r\n        dSdRp += 2 * r * dIdRp / Math.abs(data);\r\n\r\n        dIdRs = - calcI * (q * Is1 * exp1 / (n1 * k * T) + q * Is2 * exp2 / (n2 * k * T) + 1 / Rp) / (1 + Rs * (q * Is1 * exp1 / (n1 * k * T) + q * Is2 * exp2 / (n2 * k * T) + 1 / Rp));\r\n        //dIdRs = - calcI * (q * Is1 * exp1 / (n1 * k * T) + 1 / Rp) / (1 + Rs * (q * Is1 * exp1 / (n1 * k * T) + 1 / Rp));\r\n        dSdRs += 2 * r * dIdRs / Math.abs(data);\r\n\r\n        SqResSum += Math.pow(r, 2);\r\n      }\r\n      delS = [dSdn1, dSdIs1, dSdRp, dSdRs];\r\n      if (!single) {\r\n        delS.splice(1, 0, dSdn2);\r\n        delS.splice(3, 0, dSdIs2);\r\n      }\r\n    }\r\n\r\n    // Display residue\r\n    $('#s').text(SqResSum.toExponential(2));\r\n\r\n    return SqResSum;\r\n  }\r\n\r\n  function deriv(array) {\r\n    var der, prev, next, derArray = [], stringArray = 'V\\tln(I)\\td[ln(I)]/dV';\r\n    for (var i = 1; i < array.length - 1; i++) {//Derivative not calculated for 1st and last point\r\n      prev = array[i - 1];\r\n      next = array[i + 1];\r\n      der = (next[1] - prev[1]) / (next[0] - prev[0]);\r\n      derArray.push([array[i][0], der]);\r\n      stringArray = stringArray.concat('\\n' + array[i][0] + '\\t' + array[i][1] + '\\t' + der);\r\n    }\r\n    return derArray;\r\n  }\r\n\r\n  function lnOfArray(array) {\r\n    var xy, y, newArray = [];\r\n    for (var i = 0; i < array.length; i++) {\r\n      xy = array[i];\r\n      y = xy[1];\r\n      if (y != 0) {\r\n        newArray.push([xy[0], Math.log(Math.abs(y))]);\r\n      }\r\n    }\r\n\r\n    return newArray;\r\n  }\r\n\r\n  function findDiodes(userData, IprShowed, nonLinearCurrentShowed) {\r\n    let modifDataArray = userData.modifDataArray,\r\n      shuntCurrent = userData.current.shunt;\r\n\r\n    if (IprShowed) {\r\n      modifDataArray = toggleIrp(modifDataArray, shuntCurrent, false);\r\n    } // diode parameters better evaluated when Rp = infinity\r\n\r\n    if (nonLinearCurrentShowed) {\r\n      let result = toggleNonLinCurr(userData, modifDataArray, false);\r\n      modifDataArray = result.modifDataArray;\r\n    }\r\n\r\n    let noIrpNoSCLCarray = modifDataArray[0],\r\n      array = modifDataArray[0];\r\n\r\n    // 1st order derivative\r\n    let array1 = deriv(lnOfArray(array));\r\n\r\n    // 2nd order derivative\r\n    array = deriv(array1);\r\n\r\n    let i = array.length - 2,\r\n      prev,\r\n      dLn = array[i][1],\r\n      dLnMin = 0,\r\n      deltaLnMax = 0,\r\n      j = 0;\r\n\r\n    let avDelta = function (array) {\r\n      var sum = 0,\r\n        length = array.length;\r\n      for (var i = 1; i < length; i++) {\r\n        sum += Math.abs(array[i][1] - array[i - 1][1]);\r\n      }\r\n      return sum / (length - 1);\r\n    };\r\n\r\n    const avD = avDelta(array);\r\n\r\n    var iMin = i,\r\n      fluctIn2ndHalf = false;\r\n    do {\r\n      i = iMin;\r\n      dLn = array[i][1];\r\n      var maxPassed = false;\r\n      do {\r\n        // Looking for minima between 0.04 V and Vmax\r\n        i--;\r\n        prev = dLn;\r\n        dLn = array[i][1];\r\n\r\n        fluctIn2ndHalf += Math.abs(dLn - prev) > avD && i < array.length / 2;\r\n        maxPassed += prev > dLn && Math.abs(dLn - prev) < avD;\r\n        var carryOn = !maxPassed || dLn < prev;\r\n      } while (i >= 0 && array[i][0] > 0.04 && carryOn && !fluctIn2ndHalf);\r\n\r\n      iMin = i + 1;\r\n      dLnMin = prev;\r\n\r\n      let dLnMax = dLnMin;\r\n\r\n      prev = -Infinity;\r\n      i = iMin - 1;\r\n      var iMax = iMin;\r\n\r\n      while (i >= 0 && array[i][0] > 0.04) {\r\n        // Looking for a maxima between 0.04 V and Vmax\r\n        dLn = array[i][1];\r\n\r\n        if (dLn < prev && prev > dLnMax && Math.abs(dLn - prev) < avD) {\r\n          iMax = i;\r\n          dLnMax = prev;\r\n        }\r\n        prev = dLn;\r\n        i--;\r\n      }\r\n\r\n      if (dLnMax - dLnMin > deltaLnMax) {\r\n        deltaLnMax = dLnMax - dLnMin;\r\n        var iMaxMax = iMax;\r\n      }\r\n      j++;\r\n    } while (iMax != iMin && j < 10 && !fluctIn2ndHalf);\r\n\r\n    if (!iMaxMax) {\r\n      return 'noDiode';\r\n    }\r\n\r\n    i = iMax = iMaxMax;\r\n    dLn = array[i][1];\r\n    do {\r\n      prev = dLn;\r\n      i--;\r\n      dLn = array[i][1];\r\n    } while (Math.abs(dLn) < Math.abs(prev) || dLn >= 0);\r\n\r\n    let iD1 = i + 2,\r\n      D1dLn = array1[iD1 + 1][1];\r\n\r\n    i = iMax;\r\n\r\n    do {\r\n      prev = dLn;\r\n      i++;\r\n      dLn = array[i][1];\r\n    } while (Math.abs(dLn) < Math.abs(prev) || dLn >= 0);\r\n\r\n    let iD2 = i - 1,\r\n      D2dLn = array1[iD2 + 1][1];\r\n\r\n    const length = array.length - 2;\r\n\r\n    iD2 = length - iD2;\r\n    iD1 = length - iD1;\r\n\r\n    /* iD2 (and iD1) are the indexes of the maxima (and minima), starting from the *end* of the original array,\r\n    in case points in reverse are missing after removal of Irp and SCLC */\r\n\r\n    return {\r\n      noIrpNoSCLCarray: noIrpNoSCLCarray,\r\n      diodes: [D2dLn, D1dLn, iD2, iD1]\r\n    };\r\n  }\r\n\r\n  function estimD1D2Rs(params, userData, findDiodesResult) {\r\n    if (document.getElementById('series').checked) {\r\n      // For now, no estimation for series model\r\n      return;\r\n    }\r\n\r\n    const paramValues = params.value,\r\n      paramChecked = params.checked;\r\n\r\n    let maxmin = findDiodesResult.diodes;\r\n\r\n    if (maxmin === 'noDiode') {\r\n      // TODO: Display message\r\n      return;\r\n    }\r\n\r\n    let dualDiode = !document.getElementById('singleDiode').checked,\r\n      array = findDiodesResult.noIrpNoSCLCarray,\r\n\r\n      D1dLn = maxmin[1],\r\n      D2dLn = maxmin[0],\r\n      VIAtd1 = array[array.length - 4 - maxmin[3]],\r\n      VIAtd2 = array[array.length - 4 - maxmin[2]],\r\n      T = paramValues.t,\r\n      A = q / (k * T),\r\n      n2 = A / D2dLn,\r\n      n, n1, Is1, Rs, Is2;\r\n\r\n    if (dualDiode) {\r\n      if (paramChecked.n2) {\r\n        n = n2;\r\n      } else {\r\n        n = n2 = paramValues.n2;\r\n      }\r\n      if (paramChecked.n1) {\r\n        n1 = A / D1dLn;\r\n      } else {\r\n        n1 = paramValues.n1;\r\n      }\r\n      if (paramChecked.is1) {\r\n        Is1 = VIAtd1[1] / (Math.exp((VIAtd1[0] * A / n1) - 1));\r\n      } else {\r\n        Is1 = paramValues.is1;\r\n      }\r\n    } else {\r\n      // Single diode\r\n      n = n2;\r\n    }\r\n\r\n    if (paramChecked.rs) {\r\n      Rs = estimRs(array, T, n);\r\n    } else {\r\n      Rs = paramValues.rs;\r\n    }\r\n\r\n    if (paramChecked.is2) {\r\n      Is2 = VIAtd2[1] / (Math.exp((VIAtd2[0] - VIAtd2[1] * Rs) * A / n2) - 1);\r\n    } else {\r\n      Is2 = paramValues.is2;\r\n    }\r\n\r\n    let newRp;\r\n\r\n    if (paramChecked.rp1) {\r\n      newRp = userData.estimatedParameters.Rp;\r\n    } else {\r\n      newRp = paramValues.rp1;\r\n    }\r\n\r\n    $('td.estimation#rp1').text(newRp.toPrecision(3));\r\n    $('td.estimation#rs').text(Rs.toPrecision(2));\r\n\r\n    if (dualDiode) {\r\n      return {\r\n        n1: n1,\r\n        n2: n2,\r\n        Is1: Is1,\r\n        Is2: Is2,\r\n        Rp1: newRp,\r\n        Rs: Rs\r\n      };\r\n    } else {\r\n      return {\r\n        n1: n2,\r\n        Is1: Is2,\r\n        Rp1: newRp,\r\n        Rs: Rs\r\n      };\r\n    }\r\n  }\r\n\r\n  function estimRs(array, T, n) {\r\n    var dIdV = deriv(array),\r\n      i = array.length - 2,\r\n      dIdVati = dIdV[i - 1][1],\r\n      exp,\r\n      A = q / (n * k * T),\r\n      B, C,\r\n      IVati = array[i],\r\n      I = IVati[1],\r\n      V = IVati[0],\r\n      Rs = 0;\r\n\r\n    do {\r\n      exp = Math.exp(A * (V - I * Rs));\r\n      B = A * exp / (exp - 1);\r\n      C = B / (1 / I + Rs * B);\r\n      Rs += 0.01;\r\n    } while (C > dIdVati);\r\n\r\n    return Rs;\r\n  }\r\n\r\n  function updateParams(params, plot, updateRangeInput) {\r\n    // Update number input and result table\r\n\r\n    if (updateRangeInput) {\r\n      var evt = document.createEvent('HTMLEvents');\r\n      evt.initEvent('change', false, false);\r\n    }\r\n\r\n    for (let param of params) {\r\n      const id = param[0],\r\n        value = param[1];\r\n\r\n      let element = $('[type=number].' + id).get(0);\r\n\r\n      if (updateRangeInput) {\r\n        element.dispatchEvent(evt);\r\n      }\r\n\r\n      const $td = $('td#final-' + id),\r\n        isScaleLog = $(element).hasClass('logscale'),\r\n        formattedValue = (isScaleLog) ? value.toExponential(2) : value.toPrecision(2);\r\n\r\n      element.value = value;\r\n      $td\r\n        .text(formattedValue);\r\n\r\n      parameters.update($(element));\r\n    }\r\n\r\n    const ivResult = calcIV(parameters, getModel());\r\n\r\n    arrayCalc = ivResult.arrayCalc;\r\n    plotStyle = ivResult.plotStyle;\r\n\r\n    calcSqResSum(parameters, userData.dataArray, arrayCalc);\r\n  }\r\n\r\n  function vary() {\r\n    // Varies checked diode parameters until\r\n    // sum of square residuals is minimized\r\n\r\n    const eps = mchEps;\r\n\r\n    var n1 = parameters.n1.value,\r\n      n1vary = parameters.n1.checked,\r\n      Is1 = parameters.is1.value,\r\n      Is1vary = parameters.is1.checked,\r\n      Rp = parameters.rp1.value,\r\n      Rpvary = parameters.rp1.checked,\r\n      Rs = parameters.rs.value,\r\n      Rsvary = parameters.rs.checked;\r\n\r\n    // Single diode model\r\n    let params = [\r\n      ['n1', n1, eps, n1vary],\r\n      ['is1', Is1, eps, Is1vary],\r\n      ['rp1', Rp, eps, Rpvary],\r\n      ['rs', Rs, eps, Rsvary]\r\n    ];\r\n\r\n    if (document.getElementById('doubleDiode').checked) {\r\n      // Dual diode model\r\n      var Is2 = parameters.is2.value,\r\n        Is2vary = parameters.is2.checked,\r\n        n2 = parameters.n2.value,\r\n        n2vary = parameters.n2.checked;\r\n      params = [['n1', n1, eps, n1vary], ['n2', n2, eps, n2vary], ['is1', Is1, eps, Is1vary], ['is2', Is2, eps, Is2vary], ['rp1', Rp, eps, Rpvary], ['rs', Rs, eps, Rsvary]];\r\n    }\r\n\r\n    var del,\r\n      S,\r\n      newPar,\r\n      j = 0,\r\n      ii = 0,\r\n      sign,\r\n      stop = false;\r\n\r\n    interval = setInterval(\r\n      function () {\r\n        S = SqResSum;\r\n        var newPars = [];\r\n        //del = delS;\r\n        for (var i = 0; i < params.length; i++) {\r\n          if (params[i][3]) {\r\n            // This parameter is allowed to vary\r\n            del = delS[i];\r\n            sign = del / Math.abs(del);\r\n\r\n            newPar = params[i][1] * Math.pow((1 + params[i][2]), -sign); //update parameter\r\n\r\n            updateParams([[params[i][0], newPar]], false, false);\r\n\r\n            j = 0;\r\n            while (del / Math.abs(del) != delS[i] / Math.abs(delS[i]) && j < 100 && newPar !== 0) {\r\n              params[i][2] /= 2;\r\n              newPar = params[i][1] * Math.pow((1 + params[i][2]), -sign); //update parameter\r\n              updateParams([[params[i][0], newPar]], false, false);\r\n              j++;\r\n            }\r\n\r\n            var jj = 0;\r\n            while (del / Math.abs(del) == delS[i] / Math.abs(delS[i]) && jj < 100 && newPar !== 0) {\r\n              params[i][2] *= 2;\r\n              newPar = params[i][1] * Math.pow((1 + params[i][2]), -sign); //update parameter\r\n              updateParams([[params[i][0], newPar]], false, false);\r\n\r\n              jj++;\r\n            }\r\n            params[i][1] = newPar;\r\n            newPars.push(newPar);\r\n\r\n            if (isNaN(newPar)) {\r\n              stop += true;\r\n            }\r\n          }\r\n        }\r\n\r\n        ii++;\r\n\r\n        const dS = SqResSum - S;\r\n\r\n        if (typeof S === 'number') {\r\n          $('#ds').text(dS.toExponential(2));\r\n        } else {\r\n          $('#ds').empty();\r\n        }\r\n\r\n        const threshold = document.getElementById('threshold').value,\r\n          fitSuccessful = Math.abs(dS) < threshold;\r\n\r\n        if (fitSuccessful || ii > 1000 || stop) {\r\n          if (fitSuccessful) {\r\n            const addContext = true;\r\n            tableSuccessContext(addContext);\r\n          }\r\n          togglePlayButton();\r\n          const start = false;\r\n          startPauseVary(start);\r\n\r\n          // Sync number and range inputs\r\n          syncAllInputs();\r\n        }\r\n        if (document.webkitHidden) {\r\n          // No use to plot: the page is not visible (Webkit only)\r\n        } else {\r\n          combDataAndCalc(/*arrayCalc, plotStyle, scale*/);\r\n        }\r\n      }\r\n      , 1);\r\n  }\r\n\r\n  function startPauseVary(start) {\r\n    // start parameter is a boolean\r\n\r\n    if (start === true) {\r\n      const addContext = false;\r\n      tableSuccessContext(addContext);\r\n      vary();\r\n    } else {\r\n      clearInterval(interval);\r\n    }\r\n  }\r\n\r\n  return {};\r\n})();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz85NTUyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBkcmF3R3JhcGggZnJvbSAnYm9iR3JhcGgnO1xyXG5cclxuLy8gVXNlIHdlYnBhY2sgbG9hZGVycyB0byBjb3B5IG5lZWRlZCBmaWxlcyB0byBkb2NzIGRpcmVjdG9yeVxyXG5yZXF1aXJlKCdpbmRleC5odG1sJyk7XHJcbnJlcXVpcmUoJ2luZGV4LmNzcycpO1xyXG5yZXF1aXJlKCdhc3NldHMvc2FtcGxlZmlsZXMvVDI3OUsudHh0Jyk7XHJcblxyXG4vLyBJbW1lZGlhdGVseSBJbnZva2VkIEZ1bmN0aW9uIEV4cHJlc3Npb25cclxuKGZ1bmN0aW9uICgpIHtcclxuICBjb25zdCBtY2hFcHMgPSBtYWNoaW5lRXBzaWxvbigpO1xyXG5cclxuICAvLyBFbGVtZW50YXJ5IGNoYXJnZSBhbmQgQm9sdHptYW5uIGNvbnN0YW50XHJcbiAgY29uc3QgcSA9IDEuNjAyMTc2NTNFLTE5LFxyXG4gICAgayA9IDEuMzgwNjQ4OEUtMjM7XHJcblxyXG4gIGxldCBhcnJheUNhbGMsXHJcbiAgICBmaWxlT3BlbmVkID0gZmFsc2UsXHJcbiAgICBwbG90U3R5bGUgPSBbXSxcclxuICAgIHVzZXJEYXRhID0ge1xyXG4gICAgICBlc3RpbWF0ZWRQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgUnA6IHVuZGVmaW5lZFxyXG4gICAgICB9LFxyXG4gICAgICBjdXJyZW50OiB7XHJcbiAgICAgICAgc2h1bnQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBub25MaW5lYXI6IHVuZGVmaW5lZCxcclxuICAgICAgICBub0lycE5vU0NMQ2FycmF5OiB1bmRlZmluZWRcclxuICAgICAgfSxcclxuICAgICAgZGF0YUFycmF5OiBbXSxcclxuICAgICAgbW9kaWZEYXRhQXJyYXk6IFtdXHJcbiAgICB9LFxyXG4gICAgcGFyYW1ldGVycyA9IHtcclxuICAgICAgbWluVm9sdDogdW5kZWZpbmVkLFxyXG4gICAgICBtYXhWb2x0OiB1bmRlZmluZWQsXHJcbiAgICAgIHN0ZXBWb2x0OiB1bmRlZmluZWQsXHJcbiAgICAgIGlwaDogdW5kZWZpbmVkLFxyXG4gICAgICB0OiB1bmRlZmluZWQsXHJcbiAgICAgIG4xOiB1bmRlZmluZWQsXHJcbiAgICAgIG4yOiB1bmRlZmluZWQsXHJcbiAgICAgIGlzMTogdW5kZWZpbmVkLFxyXG4gICAgICBpczI6IHVuZGVmaW5lZCxcclxuICAgICAgcnAxOiB1bmRlZmluZWQsXHJcbiAgICAgIHJwMjogdW5kZWZpbmVkLFxyXG4gICAgICByczogdW5kZWZpbmVkLFxyXG4gICAgICAvLyBNZXRob2RzOlxyXG4gICAgICBpbml0OiBpbml0UGFyYW1ldGVycyxcclxuICAgICAgdXBkYXRlOiB1cGRhdGVQYXJhbWV0ZXJcclxuICAgIH0sXHJcbiAgICBtb2RlbCA9IHt9O1xyXG5cclxuICAvLyBTZXQgcGFyYW1ldGVyIG9iamVjdCdzIG1ldGhvZHMgYXMgbm9uLWVudW1lcmFibGUgc28gdGhleVxyXG4gIC8vIGRvIG5vdCBzaG93IHVwIGluIGEgKGZvciBpbikgbG9vcFxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJhbWV0ZXJzLCAnaW5pdCcsIHsgZW51bWVyYWJsZTogZmFsc2UgfSk7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmFtZXRlcnMsICd1cGRhdGUnLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xyXG5cclxuICBmdW5jdGlvbiBpbml0UGFyYW1ldGVycygpIHtcclxuICAgIC8vIFVzZWQgYXMgYSBtZXRob2QgYnkgcGFyYW1ldGVyIG9iamVjdFxyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykge1xyXG4gICAgICBjb25zdCAkaW5wdXROdW1iZXIgPSAkKCdbdHlwZT1udW1iZXJdLicgKyBwcm9wZXJ0eSksXHJcbiAgICAgICAgJGlucHV0Q2hlY2tCb3ggPSAkKCdbdHlwZT1jaGVja2JveF0uJyArIHByb3BlcnR5KTtcclxuICAgICAgdGhpc1twcm9wZXJ0eV0gPSB7XHJcbiAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQoJGlucHV0TnVtYmVyLnZhbCgpKSxcclxuICAgICAgICBjaGVja2VkOiAkaW5wdXRDaGVja0JveC5pcygnOmNoZWNrZWQnKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlUGFyYW1ldGVyKCRlbGVtZW50KSB7XHJcbiAgICAvLyBVc2VkIGFzIGEgbWV0aG9kIGJ5IHBhcmFtZXRlciBvYmplY3RcclxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIHtcclxuICAgICAgaWYgKCRlbGVtZW50Lmhhc0NsYXNzKHByb3BlcnR5KSkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IHBhcnNlRmxvYXQoJGVsZW1lbnQudmFsKCkpLFxyXG4gICAgICAgICAgaW5wdXRJc0xvZ1JhbmdlID0gJGVsZW1lbnQuaGFzQ2xhc3MoJ2xvZ3NjYWxlJykgJiYgJGVsZW1lbnQuYXR0cigndHlwZScpID09PSAncmFuZ2UnLFxyXG4gICAgICAgICAgbmV3VmFsdWUgPSAoaW5wdXRJc0xvZ1JhbmdlKSA/IE1hdGgucG93KDEwLCBlbGVtZW50VmFsdWUpIDogZWxlbWVudFZhbHVlO1xyXG4gICAgICAgIHRoaXNbcHJvcGVydHldID0ge1xyXG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgY2hlY2tlZDogJGVsZW1lbnQuaXMoJzpjaGVja2VkJylcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtYWNoaW5lRXBzaWxvbigpIHtcclxuICAgIC8vIENhbGN1bGF0ZSBNYWNoaW5lIEVwc2lsb25cclxuICAgIGxldCB0ZW1wMSwgdGVtcDI7XHJcbiAgICB0ZW1wMSA9IDEuMDtcclxuICAgIGRvIHtcclxuICAgICAgdGVtcDEgLz0gMjtcclxuICAgICAgdGVtcDIgPSAxLjAgKyB0ZW1wMTtcclxuICAgIH0gd2hpbGUgKHRlbXAyID4gMS4wKTtcclxuICAgIHJldHVybiB0ZW1wMTtcclxuICB9XHJcblxyXG4gICQoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gV2hlbiBwYWdlIGlzIGxvYWRlZFxyXG5cclxuICAgICQoJ2lucHV0W3R5cGU9cmFkaW9dLmRlZmF1bHQnKVxyXG4gICAgICAuYXR0cignY2hlY2tlZCcsIHRydWUpO1xyXG5cclxuICAgIGNsZWFyRmlsZUlucHV0KCk7XHJcblxyXG4gICAgcGFyYW1ldGVycy5pbml0KCk7XHJcblxyXG4gICAgbW9kZWwgPSBnZXRNb2RlbCgpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhIGZpcnN0IHRpbWVcclxuICAgIC8vIElWIHVzaW5nIHRoZSBpbml0aWFsIHBhcmFtZXRlcnNcclxuICAgIGNhbGNJVmFuZFBsb3QoKTtcclxuXHJcbiAgICBiaW5kRXZlbnRzKCk7XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XHJcbiAgICAkKCdpbnB1dFt0eXBlPXJhbmdlXS5zeW5jbWUnKVxyXG4gICAgICAub24oJ2lucHV0JywgaW5wdXRFdmVudClcclxuICAgICAgLm1vdXNldXAocmFuZ2VJbnB1dE1vdXNlVXApO1xyXG5cclxuICAgICQoJ2lucHV0W3R5cGU9bnVtYmVyXS5zeW5jbWUnKVxyXG4gICAgICAuY2hhbmdlKGlucHV0RXZlbnQpXHJcbiAgICAgIC5rZXlkb3duKG51bWJlcklucHV0S2V5RG93bilcclxuICAgICAgLmJsdXIoY2hhbmdlU3RlcCk7XHJcblxyXG4gICAgJCgnaW5wdXRbdHlwZT1udW1iZXJdLnZvbHRhZ2UnKVxyXG4gICAgICAuY2hhbmdlKHZvbHRhZ2VJbnB1dENoYW5nZWQpO1xyXG5cclxuICAgICQoJ2lucHV0W3R5cGU9cmFkaW9dLm1vZGVsJylcclxuICAgICAgLmNoYW5nZShtb2RlbENoYW5nZWQpO1xyXG5cclxuICAgICQoJ2lucHV0W3R5cGU9cmFkaW9dLnNjYWxlJylcclxuICAgICAgLmNoYW5nZShjaGFuZ2VTY2FsZVR5cGUpO1xyXG5cclxuICAgICQoJzpmaWxlJylcclxuICAgICAgLmNoYW5nZShmaWxlSW5wdXRDaGFuZ2VkKTtcclxuXHJcbiAgICAkKCcuZmEtdG9nZ2xlLW9uLCAuZmEtdG9nZ2xlLW9mZicpXHJcbiAgICAgIC5jbGljayhmYVRvZ2dsZUNsaWNrZWQpO1xyXG5cclxuICAgICQoJyN1c2Vlc3RpbWF0ZWRwYXJhbXMnKVxyXG4gICAgICAuY2xpY2sodXNlRXN0aW1hdGVkUGFyYW1zKTtcclxuXHJcbiAgICAkKCdidXR0b24jc3RhcnQnKVxyXG4gICAgICAuY2xpY2soc3RhcnRCdXR0b25DbGlja2VkKTtcclxuXHJcbiAgICAkKCdpbnB1dCNjbGVhcicpXHJcbiAgICAgIC5jbGljayhjbGVhckRhdGEpO1xyXG5cclxuICAgICQoJ1t0eXBlPWNoZWNrYm94XScpXHJcbiAgICAgIC5jaGFuZ2UocGFyYW1ldGVyQ2hlY2tCb3hDaGFuZ2VkKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoYW5nZVNjYWxlVHlwZSgpIHtcclxuICAgIC8vIEV2ZW50IGhhbmRsZXJcclxuICAgIC8vIGZpcmVkIHdoZW4gdXNlciBjbGlja3Mgb24gYSBzY2FsZSB0eXBlIHJhZGlvIGJ1dHRvblxyXG4gICAgY2FsY0lWYW5kUGxvdCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmFuZ2VJbnB1dE1vdXNlVXAoKSB7XHJcbiAgICAvLyBFdmVudCBoYW5kbGVyXHJcbiAgICBhZGp1c3RSYW5nZSh0aGlzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG51bWJlcklucHV0S2V5RG93bihldmVudCkge1xyXG4gICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LndoaWNoLFxyXG4gICAgICB1cE9yRG93bkFycm93S2V5RG93biA9IGtleUNvZGUgPT0gMzggfHwga2V5Q29kZSA9PSA0MDtcclxuXHJcbiAgICBpZiAodXBPckRvd25BcnJvd0tleURvd24pIHtcclxuICAgICAgc3luY0lucHV0cyh0aGlzKTtcclxuICAgICAgYWRqdXN0UmFuZ2UodGhpcyk7XHJcbiAgICAgIGNhbGNJVmFuZFBsb3QoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbGNJVmFuZFBsb3QoKSB7XHJcbiAgICBjb25zdCBpdlJlc3VsdCA9IGNhbGNJVihwYXJhbWV0ZXJzLCBnZXRNb2RlbCgpKTtcclxuXHJcbiAgICBhcnJheUNhbGMgPSBpdlJlc3VsdC5hcnJheUNhbGM7XHJcbiAgICBwbG90U3R5bGUgPSBpdlJlc3VsdC5wbG90U3R5bGU7XHJcblxyXG4gICAgLy8gYW5kIHBsb3QgdGhlIHJlc3VsdFxyXG4gICAgY29tYkRhdGFBbmRDYWxjKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaWxlSW5wdXRDaGFuZ2VkKCkge1xyXG4gICAgLy8gRmlyZWQgd2hlbiB1c2VyIHNlbGVjdHMgYSBuZXcgZmlsZVxyXG4gICAgLy8gdG8gaW1wb3J0XHJcbiAgICBjb25zdCBmaWxlID0gdGhpcy5maWxlc1swXTtcclxuICAgICQodGhpcylcclxuICAgICAgLmNsb3Nlc3QoJy5pbnB1dC1ncm91cCcpXHJcbiAgICAgIC5jaGlsZHJlbignaW5wdXQ6dGV4dCcpXHJcbiAgICAgIC52YWwoZmlsZS5uYW1lKTtcclxuICAgIHByb2Nlc3NGaWxlcyhmaWxlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZhVG9nZ2xlQ2xpY2tlZCgpIHtcclxuICAgIC8vIEZpcmVkIHdoZW4gdXNlciBjbGlja3Mgb24gYW55IG9mIHRoZSBmb250LWF3ZXNvbWUgdG9nZ2xlIGljb25zXHJcbiAgICAvLyBBcyBvZiBub3cgdGhlcmUgYXJlIDIgb2YgdGhlc2UgaWNvbnMgb24gdGhlIHBhZ2VcclxuICAgIGNvbnN0IGlFbGVtID0gdGhpczsgLy8gPGk+IGVsZW1lbnRcclxuXHJcbiAgICAkKGlFbGVtKVxyXG4gICAgICAudG9nZ2xlQ2xhc3MoJ2ZhLXRvZ2dsZS1vbiBmYS10b2dnbGUtb2ZmJyk7XHJcblxyXG4gICAgaWYgKGlFbGVtLmlkID09PSAnaGlkZUlycCcpIHtcclxuICAgICAgdXNlckRhdGEubW9kaWZEYXRhQXJyYXkgPSB0b2dnbGVJcnAodXNlckRhdGEubW9kaWZEYXRhQXJyYXksIHVzZXJEYXRhLmN1cnJlbnQuc2h1bnQsIElwclNob3dlZCgpKTtcclxuICAgICAgY29tYkRhdGFBbmRDYWxjKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlFbGVtLmlkID09PSAnaGlkZU5vbkxpbkN1cnInKSB7XHJcbiAgICAgIGNvbnN0IHRvZ2dsZVJlc3VsdCA9IHRvZ2dsZU5vbkxpbkN1cnIodXNlckRhdGEsIHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5LCBub25MaW5lYXJDdXJyZW50U2hvd2VkKCkpO1xyXG4gICAgICB1c2VyRGF0YS5kYXRhQXJyYXkgPSB0b2dnbGVSZXN1bHQuZGF0YUFycmF5O1xyXG4gICAgICB1c2VyRGF0YS5tb2RpZkRhdGFBcnJheSA9IHRvZ2dsZVJlc3VsdC5tb2RpZkRhdGFBcnJheTtcclxuICAgICAgY29tYkRhdGFBbmRDYWxjKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJhbWV0ZXJDaGVja0JveENoYW5nZWQoKSB7XHJcbiAgICAvKiBGaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIGFueSBvZiB0aGUgY2hlY2tib3ggaW5wdXRzXHJcbiAgICBUaGVzZSBjaGVja2JveGVzIGRlZmluZSB3aGV0aGVyIHRoZSBjb3JyZXNwb25kaW5nIGRpb2RlXHJcbiAgICBwYXJhbWV0ZXIgdmFyaWVzIG9yIG5vdCBkdXJpbmcgb3B0aW1pemF0aW9uXHJcbiAgICBUaGVyZWZvcmUsIGlmIHVuY2hlY2tlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBlc3RpbWF0ZWQuICovXHJcbiAgICBmaW5kQW5kRXN0aW1hdGVEaW9kZXMoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN5bmNJbnB1dHMoc291cmNlRWxlbSkge1xyXG4gICAgLy8gU3luYyByYW5nZSBhbmQgbnVtYmVyIGlucHV0c1xyXG5cclxuICAgIGNvbnN0ICRzb3VyY2VJbnB1dCA9ICQoc291cmNlRWxlbSksXHJcbiAgICAgIGlzU291cmNlUmFuZ2UgPSAkc291cmNlSW5wdXQuYXR0cigndHlwZScpID09PSAncmFuZ2UnLFxyXG4gICAgICB0YXJnZXRUeXBlID0gKGlzU291cmNlUmFuZ2UpID8gJ251bWJlcicgOiAncmFuZ2UnLFxyXG4gICAgICBzb3VyY2VWYWx1ZSA9ICRzb3VyY2VJbnB1dC52YWwoKTtcclxuXHJcbiAgICAvLyBTeW5jIGNvbXBhbmlvbiBpbnB1dFxyXG4gICAgY29uc3QgJHRhcmdldElucHV0ID0gJHNvdXJjZUlucHV0XHJcbiAgICAgIC5jbG9zZXN0KCcucm93JylcclxuICAgICAgLmZpbmQoJ2lucHV0LnN5bmNtZVt0eXBlPScgKyB0YXJnZXRUeXBlICsgJ10nKSxcclxuICAgICAgaXNTY2FsZUxvZyA9ICR0YXJnZXRJbnB1dC5oYXNDbGFzcygnbG9nc2NhbGUnKTtcclxuXHJcbiAgICBpZiAoaXNTY2FsZUxvZykge1xyXG4gICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IChpc1NvdXJjZVJhbmdlKSA/IE1hdGgucG93KDEwLCBzb3VyY2VWYWx1ZSkudG9FeHBvbmVudGlhbCgyKSA6IGxvZzEwKHNvdXJjZVZhbHVlKTtcclxuICAgICAgJHRhcmdldElucHV0LnZhbCh0YXJnZXRWYWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBMaW5lYXIgc2NhbGVcclxuICAgICAgJHRhcmdldElucHV0LnZhbChzb3VyY2VWYWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzeW5jQWxsSW5wdXRzKCkge1xyXG4gICAgJCgnaW5wdXRbdHlwZT1udW1iZXJdLnN5bmNtZScpXHJcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xyXG4gICAgICAgIHN5bmNJbnB1dHMoZWxlbWVudCk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5wdXRFdmVudCgpIHtcclxuICAgIC8vIEV2ZW50IGhhbmRsZXJcclxuICAgIC8vIGZpcmVkIHdoZW4gdXNlciBtb3ZlcyByYW5nZSBpbnB1dCBvciBjaGFuZ2UgbnVtYmVyIGlucHV0LlxyXG4gICAgLy8gU28gXCJ0aGlzXCIgaXMgYSBudW1iZXIgb3IgcmFuZ2UgaW5wdXQgZWxlbWVudFxyXG5cclxuICAgIGNvbnN0IGlzTnVtYmVySW5wdXQgPSAkKHRoaXMpLmF0dHIoJ3R5cGUnKSA9PT0gJ251bWJlcic7XHJcblxyXG4gICAgaWYgKGlzTnVtYmVySW5wdXQpIHtcclxuICAgICAgYWRqdXN0UmFuZ2UodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc3luY0lucHV0cyh0aGlzKTtcclxuXHJcbiAgICBwYXJhbWV0ZXJzLnVwZGF0ZSgkKHRoaXMpKTtcclxuXHJcbiAgICBjYWxjSVZhbmRQbG90KCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB2b2x0YWdlSW5wdXRDaGFuZ2VkKCkge1xyXG4gICAgLy8gRmlyZWQgd2hlbiBvbmUgb2YgdGhlIDMgLnZvbHRhZ2UgaW5wdXRzIGlzIGNoYW5nZWQgYnkgdXNlclxyXG5cclxuICAgIHBhcmFtZXRlcnNcclxuICAgICAgLnVwZGF0ZSgkKHRoaXMpKTtcclxuXHJcbiAgICBjaGVja1ZvbHRhZ2VJbnB1dHMoKTtcclxuXHJcbiAgICBjYWxjSVZhbmRQbG90KCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGVja1ZvbHRhZ2VJbnB1dHMoKSB7XHJcbiAgICBjb25zdCBtaW5Wb2x0ID0gcGFyYW1ldGVycy5taW5Wb2x0LnZhbHVlLFxyXG4gICAgICBtYXhWb2x0ID0gcGFyYW1ldGVycy5tYXhWb2x0LnZhbHVlLFxyXG4gICAgICBzdGVwVm9sdCA9IHBhcmFtZXRlcnMuc3RlcFZvbHQudmFsdWU7XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIG1heFZvbHQgPiBtaW5Wb2x0XHJcbiAgICBpZiAobWF4Vm9sdCA8IG1pblZvbHQpIHtcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pblZvbHQnKS52YWx1ZSA9IG1heFZvbHQ7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXhWb2x0JykudmFsdWUgPSBtaW5Wb2x0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBzdGVwVm9sdCAhPSAwXHJcbiAgICBpZiAoc3RlcFZvbHQgPT0gMCkge1xyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RlcFZvbHQnKS52YWx1ZSA9IDI1O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBzdGVwVm9sdCA+IDBcclxuICAgIGlmIChzdGVwVm9sdCA8IDApIHtcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0ZXBWb2x0JykudmFsdWUgPSBNYXRoLmFicyhzdGVwVm9sdCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2cxMCh2YWwpIHtcclxuICAgIC8vIFJldHVybnMgYmFzZSAxMCBsb2dhcml0aG1pY1xyXG4gICAgLy8gKE1hdGgubG9nMTAoKSBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSBJRTExKVxyXG4gICAgLy8gQ291bGQgc3RvcCB1c2luZyB0aGlzIGZ1bmN0aW9uIHdpdGggYSB0cmFuc3BpbGVyXHJcbiAgICByZXR1cm4gTWF0aC5sb2codmFsKSAvIE1hdGgubG9nKDEwKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbURlY2ltYWxzKG1vZGVsLCBudW1iZXIpIHtcclxuICAgIC8vIENoYW5nZSBhIG51bWJlcidzIHByZWNpc2lvblxyXG4gICAgY29uc3QgbmJEZWNpbWFscyA9IG5iQWZ0ZXJEb3QobW9kZWwpO1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogTWF0aC5wb3coMTAsIG5iRGVjaW1hbHMpKSAqIE1hdGgucG93KDEwLCAtbmJEZWNpbWFscyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBuYkFmdGVyRG90KG51bWJlcikge1xyXG4gICAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAvLyBhZnRlciBkZWNpbWFsIHNlcGFyYXRvclxyXG4gICAgY29uc3QgbiA9IG51bWJlci50b1N0cmluZygpLmluZGV4T2YoJy4nKTtcclxuICAgIGlmIChuID09IC0xKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGxldCBpID0gMDtcclxuICAgICAgd2hpbGUgKG51bWJlci5jaGFyQXQobiArIDEgKyBpKSAhPSAnJyAmJiBpc0Zpbml0ZShudW1iZXIuY2hhckF0KG4gKyAxICsgaSkpKSB7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Um93RGl2KCRpbnB1dCkge1xyXG4gICAgLy8gR2V0IHBhcmFtZXRlciBpbnB1dHMnXHJcbiAgICAvLyBjbG9zZXN0IGNvbW1vbiBhbmNlc3RvclxyXG4gICAgcmV0dXJuICRpbnB1dFxyXG4gICAgICAuY2xvc2VzdCgnLnJvdycpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRqdXN0UmFuZ2UoZWxlbWVudCkge1xyXG4gICAgLy8gV2hlbiB2YWx1ZSByZWFjaGVzIGlucHV0J3MgcmFuZ2UgbGltaXQsXHJcbiAgICAvLyBtb2RpZmllcyByYW5nZSBzbyB1c2VyIGlzIGFibGUgdG8gdXNlIGl0IGFnYWluXHJcblxyXG4gICAgY29uc3QgJGlucHV0ID0gJChlbGVtZW50KSxcclxuICAgICAgaW5wdXRUeXBlID0gJGlucHV0LmF0dHIoJ3R5cGUnKSxcclxuICAgICAgJHJvd0RpdiA9IGdldFJvd0RpdigkaW5wdXQpO1xyXG5cclxuICAgIGxldCAkcmFuZ2VJbnB1dCA9ICRpbnB1dCxcclxuICAgICAgcmFuZ2VJbnB1dEVsZW0gPSBlbGVtZW50LFxyXG4gICAgICAkbnVtYmVySW5wdXQgPSAkcm93RGl2XHJcbiAgICAgICAgLmZpbmQoJ1t0eXBlPW51bWJlcl0nKSxcclxuICAgICAgbnVtYmVySW5wdXRFbGVtID0gJG51bWJlcklucHV0LmdldCgwKTtcclxuXHJcbiAgICBpZiAoaW5wdXRUeXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAkcmFuZ2VJbnB1dCA9ICRyb3dEaXZcclxuICAgICAgICAuZmluZCgnW3R5cGU9cmFuZ2VdJyk7XHJcbiAgICAgIHJhbmdlSW5wdXRFbGVtID0gJHJhbmdlSW5wdXQuZ2V0KDApO1xyXG4gICAgICAkbnVtYmVySW5wdXQgPSAkaW5wdXQ7XHJcbiAgICAgIG51bWJlcklucHV0RWxlbSA9IGVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJhbmdlQ2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0IHJhbmdlTWF4ID0gcGFyc2VGbG9hdChyYW5nZUlucHV0RWxlbS5tYXgpLFxyXG4gICAgICByYW5nZU1pbiA9IHBhcnNlRmxvYXQocmFuZ2VJbnB1dEVsZW0ubWluKSxcclxuICAgICAgbnVtYmVyVmFsdWUgPSBwYXJzZUZsb2F0KG51bWJlcklucHV0RWxlbS52YWx1ZSk7XHJcblxyXG4gICAgaWYgKCRyYW5nZUlucHV0Lmhhc0NsYXNzKCdsaW5lYXJzY2FsZScpKSB7XHJcbiAgICAgIGlmIChudW1iZXJWYWx1ZSA+PSByYW5nZU1heCkge1xyXG4gICAgICAgIHJhbmdlSW5wdXRFbGVtLm1heCA9IHJlbURlY2ltYWxzKG51bWJlclZhbHVlLCAxLjYgKiBudW1iZXJWYWx1ZSk7XHJcbiAgICAgICAgcmFuZ2VJbnB1dEVsZW0udmFsdWUgPSBudW1iZXJWYWx1ZTtcclxuICAgICAgICByYW5nZUlucHV0RWxlbS5taW4gPSByZW1EZWNpbWFscyhudW1iZXJWYWx1ZSwgMC40ICogbnVtYmVyVmFsdWUpO1xyXG4gICAgICAgIHJhbmdlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG51bWJlclZhbHVlIDw9IHJhbmdlTWluKSB7XHJcbiAgICAgICAgICByYW5nZUlucHV0RWxlbS5taW4gPSByZW1EZWNpbWFscyhudW1iZXJJbnB1dEVsZW0udmFsdWUsIDAuNCAqIG51bWJlcklucHV0RWxlbS52YWx1ZSk7XHJcbiAgICAgICAgICByYW5nZUlucHV0RWxlbS52YWx1ZSA9IG51bWJlcklucHV0RWxlbS52YWx1ZTtcclxuICAgICAgICAgIHJhbmdlSW5wdXRFbGVtLm1heCA9IHJlbURlY2ltYWxzKG51bWJlcklucHV0RWxlbS52YWx1ZSwgMS42ICogbnVtYmVySW5wdXRFbGVtLnZhbHVlKTtcclxuICAgICAgICAgIHJhbmdlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICgyICogcmFuZ2VJbnB1dEVsZW0uc3RlcCA+PSAocmFuZ2VJbnB1dEVsZW0ubWF4IC0gcmFuZ2VJbnB1dEVsZW0ubWluKSkge1xyXG4gICAgICAgIHJhbmdlSW5wdXRFbGVtLm1heCA9IDIgKiByYW5nZUlucHV0RWxlbS5zdGVwICsgcmFuZ2VJbnB1dEVsZW0ubWF4O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBXaGVuIHNjYWxlIGlzIExvZ1xyXG4gICAgICBpZiAobnVtYmVyVmFsdWUgPj0gTWF0aC5wb3coMTAsIHJhbmdlTWF4KSkge1xyXG4gICAgICAgIHJhbmdlSW5wdXRFbGVtLm1heCA9IE1hdGgucm91bmQobG9nMTAobnVtYmVyVmFsdWUpICsgMyk7XHJcbiAgICAgICAgcmFuZ2VJbnB1dEVsZW0udmFsdWUgPSBudW1iZXJWYWx1ZTtcclxuICAgICAgICByYW5nZUlucHV0RWxlbS5taW4gPSBNYXRoLnJvdW5kKGxvZzEwKG51bWJlclZhbHVlKSAtIDMpO1xyXG4gICAgICAgIHJhbmdlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG51bWJlclZhbHVlIDw9IE1hdGgucG93KDEwLCByYW5nZU1pbikpIHtcclxuICAgICAgICAgIHJhbmdlSW5wdXRFbGVtLm1pbiA9IE1hdGgucm91bmQobG9nMTAobnVtYmVyVmFsdWUpIC0gMyk7XHJcbiAgICAgICAgICByYW5nZUlucHV0RWxlbS52YWx1ZSA9IG51bWJlclZhbHVlO1xyXG4gICAgICAgICAgcmFuZ2VJbnB1dEVsZW0ubWF4ID0gTWF0aC5yb3VuZChsb2cxMChudW1iZXJWYWx1ZSkgKyAzKTtcclxuICAgICAgICAgIHJhbmdlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmFuZ2VDaGFuZ2VkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hhbmdlU3RlcCgpIHtcclxuICAgIC8vIEV2ZW50IGhhbmRsZSBmaXJlZCB3aGVuXHJcbiAgICAvLyB1c2VyIGJsdXJzIG51bWJlciBpbnB1dFxyXG4gICAgbGV0IG51bWJlcklucHV0RWxlbSA9IHRoaXMsXHJcbiAgICAgICRyYW5nZUlucHV0ID0gZ2V0Um93RGl2KCQobnVtYmVySW5wdXRFbGVtKSlcclxuICAgICAgICAuZmluZCgnW3R5cGU9cmFuZ2VdJyksXHJcbiAgICAgIHZhbHVlID0gbnVtYmVySW5wdXRFbGVtLnZhbHVlO1xyXG5cclxuICAgIGlmICgkcmFuZ2VJbnB1dC5oYXNDbGFzcygnbGluZWFyc2NhbGUnKSkge1xyXG4gICAgICBudW1iZXJJbnB1dEVsZW0udmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTsgLy8gRm9yIENocm9tZVxyXG4gICAgICB2YXIgbmV3U3RlcCA9IE1hdGgucG93KDEwLCAtMSAqIG5iQWZ0ZXJEb3QodmFsdWUpKTtcclxuXHJcbiAgICAgIG51bWJlcklucHV0RWxlbS5zdGVwID0gbmV3U3RlcDtcclxuICAgIH1cclxuXHJcbiAgICAkcmFuZ2VJbnB1dC5nZXQoKS5zdGVwID0gbmV3U3RlcDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1vZGVsQ2hhbmdlZCgpIHtcclxuICAgIC8vIEZpcmVkIHdoZW4gdXNlciBjaGFuZ2VzIG51bWJlciBvZiBkaW9kZXMgb3IgdGhlIGVxdWl2YWxlbnQgY2lyY3VpdFxyXG5cclxuICAgIC8vIFVwZGF0ZSBtb2RlbCB2YXJpYWJsZVxyXG4gICAgbW9kZWwgPSBnZXRNb2RlbCgpO1xyXG5cclxuICAgIGNoYW5nZUlucHV0U3RhdHVzQmFzZWRPbk1vZGVsKCk7XHJcblxyXG4gICAgY2FsY0lWYW5kUGxvdCgpO1xyXG5cclxuICAgIGlmIChmaWxlT3BlbmVkKSB7XHJcbiAgICAgIGZpbmRBbmRFc3RpbWF0ZURpb2RlcygpO1xyXG5cclxuICAgICAgY2FsY1NxUmVzU3VtKHBhcmFtZXRlcnMsIHVzZXJEYXRhLmRhdGFBcnJheSwgYXJyYXlDYWxjKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoYW5nZUlucHV0U3RhdHVzQmFzZWRPbk1vZGVsKCkge1xyXG4gICAgaWYgKG1vZGVsLmNpcmN1aXQgPT09ICdwYXJhbGxlbCcpIHtcclxuICAgICAgJCgnaW5wdXQucnAyJylcclxuICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcclxuXHJcbiAgICAgIGNvbnN0ICRpbnB1dHMgPSAkKCdpbnB1dC5uMiwgaW5wdXQuaXMyLCAjc2VyaWVzLCAjcGFyYWxsZWwnKTtcclxuXHJcbiAgICAgIGlmICghZmlsZU9wZW5lZCkge1xyXG4gICAgICAgICRpbnB1dHNcclxuICAgICAgICAgIC5ub3QoJ1t0eXBlPWNoZWNrYm94XScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkaW5wdXRzXHJcbiAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG5cclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0JykuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobW9kZWwuZGlvZGVDb3VudCA9PT0gMSkge1xyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VyaWVzJykuY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyYWxsZWwnKS5jaGVja2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgIG1vZGVsLmNpcmN1aXQgPSAncGFyYWxsZWwnO1xyXG5cclxuICAgICAgJCgnaW5wdXQubjIsIGlucHV0LmlzMiwgI3NlcmllcywgI3BhcmFsbGVsLCBpbnB1dC5ycDInKVxyXG4gICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xyXG5cclxuICAgICAgaWYgKGZpbGVPcGVuZWQpIHtcclxuICAgICAgICAvLyBXaWxsIGFsc28gZW5hYmxlIGNoZWNrYm94ZXNcclxuICAgICAgICAkKCdpbnB1dC5uMSwgaW5wdXQuaXMxLCBpbnB1dC5ycDEnKVxyXG4gICAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnQnKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtb2RlbC5jaXJjdWl0ID09PSAnc2VyaWVzJykge1xyXG4gICAgICAkKCdpbnB1dC5uMiwgaW5wdXQuaXMyLCBpbnB1dC5ycDInKVxyXG4gICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuXHJcbiAgICAgIC8vIERpc2FibGUgZml0dGluZyBpbnB1dHMgYmVjYXVzZVxyXG4gICAgICAvLyBzZXJpZXMgbW9kZWwgbm90IHN1cHBvcnRlZCBmb3Igb3B0aW1pemF0aW9uXHJcbiAgICAgIGRpc2FibGVDaGVja2JveGVzKCk7XHJcbiAgICAgICQoJ2J1dHRvbiNzdGFydCcpXHJcbiAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkaXNhYmxlQ2hlY2tib3hlcygpIHtcclxuICAgICQoJ1t0eXBlPWNoZWNrYm94XScpXHJcbiAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmluZEFuZEVzdGltYXRlRGlvZGVzKCkge1xyXG4gICAgY29uc3QgZmluZERpb2Rlc1Jlc3VsdCA9IGZpbmREaW9kZXModXNlckRhdGEsIElwclNob3dlZCgpLCBub25MaW5lYXJDdXJyZW50U2hvd2VkKCkpLFxyXG4gICAgICBlc3RpbWF0ZWRQYXJhbXMgPSBlc3RpbUQxRDJScyhnZXRBbGxQYXJhbXMoKSwgdXNlckRhdGEsIGZpbmREaW9kZXNSZXN1bHQpO1xyXG5cclxuICAgIGRpc3BsYXlFc3RpbWF0ZWRQYXJhbXMoZXN0aW1hdGVkUGFyYW1zKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRpc3BsYXlFc3RpbWF0ZWRQYXJhbXMoZXN0aW1hdGVkUGFyYW1zKSB7XHJcbiAgICAvLyBEaXNwbGF5IHRoZSByZXN1bHQgb2YgZXN0aW1EMUQyUnMgaW50b1xyXG4gICAgLy8gdGhlIHJlc3VsdHMgdGFibGVcclxuXHJcbiAgICBmb3IgKGxldCBwYXJhbU5hbWUgaW4gZXN0aW1hdGVkUGFyYW1zKSB7XHJcbiAgICAgIGNvbnN0IGlkID0gcGFyYW1OYW1lLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgdmFsdWUgPSBlc3RpbWF0ZWRQYXJhbXNbcGFyYW1OYW1lXSxcclxuICAgICAgICB0ZXh0ID0gKGlzUGFyYW1TY2FsZUxvZyhpZCkpID8gdmFsdWUudG9FeHBvbmVudGlhbCgyKSA6IHZhbHVlLnRvUHJlY2lzaW9uKDIpO1xyXG5cclxuICAgICAgJCgndGQuZXN0aW1hdGlvbiMnICsgaWQpXHJcbiAgICAgICAgLnRleHQodGV4dCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1BhcmFtU2NhbGVMb2coZWxlbUlEKSB7XHJcbiAgICAvLyBSZXR1cm5zIHdoZXRoZXIgc2NhbGUgdHlwZSB1c2VkIGZvclxyXG4gICAgLy8gYSBnaXZlbiBkaW9kZSBwYXJhbWV0ZXIgaXMgYSBsb2dhcml0aG1pYyBvbmVcclxuICAgIHJldHVybiAkKCdbdHlwZT1udW1iZXJdIycgKyBlbGVtSUQpXHJcbiAgICAgIC5oYXNDbGFzcygnbG9nc2NhbGUnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVzZUVzdGltYXRlZFBhcmFtcygpIHtcclxuICAgIC8vIEZpcmVkIHdoZW4gdXNlciBjbGlja3MgXCJVc2UgZXN0aW1hdGVkIHBhcmFtZXRlcnNcIiBidXR0b25cclxuICAgICQoJ3RkLmVzdGltYXRpb24nKVxyXG4gICAgICAuZWFjaCh1cGRhdGVJbnB1dCk7XHJcblxyXG4gICAgc3luY0FsbElucHV0cygpO1xyXG5cclxuICAgIHBhcmFtZXRlcnMuaW5pdCgpO1xyXG5cclxuICAgIGNhbGNJVmFuZFBsb3QoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZUlucHV0KGluZGV4LCBlbGVtZW50KSB7XHJcbiAgICAvLyBVcGRhdGUgYSBwYXJhbWV0ZXIgaW5wdXQgd2l0aCBhbiBlc3RpbWF0aW9uXHJcblxyXG4gICAgY29uc3QgJHRkID0gJChlbGVtZW50KSxcclxuICAgICAgcGFyYW1DbGFzcyA9ICR0ZC5hdHRyKCdpZCcpLFxyXG4gICAgICAkaW5wdXQgPSAkKCdpbnB1dFt0eXBlPW51bWJlcl0uJyArIHBhcmFtQ2xhc3MpO1xyXG5cclxuICAgIGlmICgkaW5wdXQucHJvcCgnZGlzYWJsZWQnKSA9PT0gZmFsc2UpIHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KCR0ZC50ZXh0KCkpO1xyXG4gICAgICAkaW5wdXQudmFsKHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0YXJ0QnV0dG9uQ2xpY2tlZCgpIHtcclxuICAgIC8vIEZpcmVkIHdoZW4gdXNlciBjbGlja3Mgb24gdGhlIHBsYXkvcGF1c2UgYnV0dG9uXHJcbiAgICAvLyB0byBzdGFydCBvciBwYXVzZSB0aGUgZml0dGluZ1xyXG5cclxuICAgIGNvbnN0IHN0YXJ0ID0gJCh0aGlzKVxyXG4gICAgICAuaGFzQ2xhc3MoJ3BsYXknKTtcclxuXHJcbiAgICB0b2dnbGVQbGF5QnV0dG9uKCk7XHJcblxyXG4gICAgc3RhcnRQYXVzZVZhcnkoc3RhcnQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlUGxheUJ1dHRvbigpIHtcclxuICAgICQoJyNzdGFydCcpXHJcbiAgICAgIC50b2dnbGVDbGFzcygncGxheSBwYXVzZScpO1xyXG4gIH1cclxuXHJcbiAgLyogVGhlIHR3byBmb2xsb3dpbmcgZnVuY3Rpb25zIGNhbGN1bGF0ZVxyXG4gICAgIHRoZSBjdXJyZW50IGF0IGEgZ2l2ZW4gdm9sdGFnZSAqL1xyXG5cclxuICBmdW5jdGlvbiBJcGFyYWxsZWwoViwgSXBoLCBwcmV2SSwgVCwgbjEsIG4yLCBJczEsIElzMiwgUnAsIFJzKSB7XHJcbiAgICAvLyBEb3VibGUgZGlvZGUgKGluIHBhcmFsbGVsKSBtb2RlbFxyXG4gICAgbGV0IGkgPSAwLCBJLCBmLCBkZiwgciwgSWQxLCBJZDIsIElycDtcclxuXHJcbiAgICBJcGggPSBJcGggLyAxMDAwOyAvLyBtQSAtPiBBXHJcblxyXG4gICAgaWYgKCFwcmV2SSkge1xyXG4gICAgICBJID0gSXBoO1xyXG4gICAgICBwcmV2SSA9IEk7XHJcbiAgICB9XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICBwcmV2SSA9IEk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIElkMSA9IElzMSAqIChNYXRoLmV4cChxICogKFYgKyBwcmV2SSAqIFJzKSAvIChuMSAqIGsgKiBUKSkgLSAxKTtcclxuICAgICAgSWQyID0gSXMyICogKE1hdGguZXhwKHEgKiAoViArIHByZXZJICogUnMpIC8gKG4yICogayAqIFQpKSAtIDEpO1xyXG4gICAgICBJcnAgPSAoViArIHByZXZJICogUnMpIC8gUnA7XHJcblxyXG4gICAgICAvLyBmKFYscHJldkkpXHJcbiAgICAgIGYgPSBJcGggLSBJZDEgLSBJZDIgLSBJcnAgLSBwcmV2STtcclxuXHJcbiAgICAgIC8vIGRmKFYscHJldkkpL2RwcmV2SVxyXG4gICAgICBkZiA9IC0oKElzMSAqIFJzKSAvIChuMSAqIFQgKiBrIC8gcSkpICogTWF0aC5leHAoKFYgKyBwcmV2SSAqIFJzKSAvIChuMSAqIFQgKiBrIC8gcSkpXHJcbiAgICAgICAgLSAoKElzMiAqIFJzKSAvIChuMiAqIFQgKiBrIC8gcSkpICogTWF0aC5leHAoKFYgKyBwcmV2SSAqIFJzKSAvIChuMiAqIFQgKiBrIC8gcSkpXHJcbiAgICAgICAgLSBScyAvIFJwIC0gMTtcclxuXHJcbiAgICAgIC8vIGYvZGZcclxuICAgICAgciA9IGYgLyBkZjtcclxuXHJcbiAgICAgIEkgPSBwcmV2SSAtIHI7XHJcblxyXG4gICAgICBpKys7XHJcblxyXG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoSSAtIHByZXZJKSA+IG1jaEVwcyAmJiBpIDwgNTAwKTtcclxuXHJcbiAgICByZXR1cm4gW0ksIElkMSwgSWQyLCBJcnAsIElkMSArIElkMiArIElycF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBJc2VyaWVzKFYsIFQsIElwaCwgbjEsIG4yLCBJczEsIElzMiwgUnAxLCBScDIsIFJzKSB7XHJcbiAgICAvLyBEb3VibGUgZGlvZGUgKGluIHNlcmllcykgbW9kZWxcclxuICAgIGxldCBpID0gMCwgSWEsIEliLCBWMSwgVjIsIElkMSwgSWQyLCBJcnAxLCBJcnAyLCBIID0gMTAsIEwgPSAtMTA7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICBWMSA9IChIICsgTCkgLyAyO1xyXG5cclxuICAgICAgSWQxID0gSXMxICogTWF0aC5leHAocSAqIFYxIC8gKG4xICogayAqIFQpIC0gMSk7XHJcbiAgICAgIElycDEgPSBWMSAvIFJwMTtcclxuXHJcbiAgICAgIElhID0gSWQxICsgSXJwMTtcclxuXHJcbiAgICAgIFYyID0gViAtIFYxIC0gUnMgKiBJYTtcclxuXHJcbiAgICAgIElkMiA9IElzMiAqIE1hdGguZXhwKHEgKiBWMiAvIChuMiAqIGsgKiBUKSAtIDEpO1xyXG4gICAgICBJcnAyID0gVjIgLyBScDI7XHJcbiAgICAgIEliID0gSWQyICsgSXJwMjtcclxuXHJcbiAgICAgIHZhciBkaWZmSSA9IEliIC0gSWE7XHJcblxyXG4gICAgICBpZiAoZGlmZkkgPiAwKSB7XHJcbiAgICAgICAgTCA9IFYxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEggPSBWMTtcclxuICAgICAgfVxyXG4gICAgICBpKys7XHJcblxyXG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoZGlmZkkpID4gbWNoRXBzICYmIGkgPCA1MDApO1xyXG4gICAgcmV0dXJuIFtJYSwgSWQxLCBJZDIsIElycDEsIElycDJdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UGFyYW0kKHBhcmFtQ2xhc3MpIHtcclxuICAgIHJldHVybiAkKCdpbnB1dFt0eXBlPW51bWJlcl0nKVxyXG4gICAgICAuZmlsdGVyKCcuJyArIHBhcmFtQ2xhc3MpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UGFyYW1WYWx1ZShwYXJhbUNsYXNzKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdChcclxuICAgICAgZ2V0UGFyYW0kKHBhcmFtQ2xhc3MpXHJcbiAgICAgICAgLnZhbCgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UGFyYW1DaGVja2VkKHBhcmFtQ2xhc3MpIHtcclxuICAgIHJldHVybiAkKCdpbnB1dFt0eXBlPWNoZWNrYm94XScpXHJcbiAgICAgIC5maWx0ZXIoJy4nICsgcGFyYW1DbGFzcylcclxuICAgICAgLmlzKCc6Y2hlY2tlZCcpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QWxsUGFyYW1zKCkge1xyXG4gICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgdmFsdWU6IHtcclxuICAgICAgICBpcGg6IHVuZGVmaW5lZCxcclxuICAgICAgICB0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgbjE6IHVuZGVmaW5lZCxcclxuICAgICAgICBuMjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGlzMTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGlzMjogdW5kZWZpbmVkLFxyXG4gICAgICAgIHJwMTogdW5kZWZpbmVkLFxyXG4gICAgICAgIHJwMjogdW5kZWZpbmVkLFxyXG4gICAgICAgIHJzOiB1bmRlZmluZWRcclxuICAgICAgfSxcclxuICAgICAgY2hlY2tlZDoge1xyXG4gICAgICAgIGlwaDogdW5kZWZpbmVkLFxyXG4gICAgICAgIHQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBuMTogdW5kZWZpbmVkLFxyXG4gICAgICAgIG4yOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaXMxOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaXMyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcnAxOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcnAyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgcnM6IHVuZGVmaW5lZFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IHBhcmFtQ2xhc3MgaW4gcGFyYW1zLnZhbHVlKSB7XHJcbiAgICAgIHBhcmFtcy52YWx1ZVtwYXJhbUNsYXNzXSA9IGdldFBhcmFtVmFsdWUocGFyYW1DbGFzcyk7XHJcbiAgICAgIHBhcmFtcy5jaGVja2VkW3BhcmFtQ2xhc3NdID0gZ2V0UGFyYW1DaGVja2VkKHBhcmFtQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFBhcmFtVmFsdWUocGFyYW1DbGFzcywgdmFsdWUpIHtcclxuICAgIGdldFBhcmFtJChwYXJhbUNsYXNzKVxyXG4gICAgICAudmFsKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldE1vZGVsKCkge1xyXG4gICAgY29uc3QgaXNTaW5nbGVEaW9kZUNoZWNrZWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2luZ2xlRGlvZGUnKS5jaGVja2VkLFxyXG4gICAgICBpc1BhcmFsbGVsQ2hlY2tlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJhbGxlbCcpLmNoZWNrZWQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkaW9kZUNvdW50OiAoaXNTaW5nbGVEaW9kZUNoZWNrZWQpID8gMSA6IDIsXHJcbiAgICAgIGNpcmN1aXQ6IChpc1BhcmFsbGVsQ2hlY2tlZCkgPyAncGFyYWxsZWwnIDogJ3NlcmllcydcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYWxjSVYocGFyYW1zLCBtb2RlbCkge1xyXG4gICAgLy8gQ2FsY3VsYXRlcyBjdXJyZW50IGZvciBhIHJhbmdlIG9mIHZvbHRhZ2UgdmFsdWVzXHJcblxyXG4gICAgY29uc3QgbWluVm9sdCA9IHBhcmFtcy5taW5Wb2x0LnZhbHVlLFxyXG4gICAgICBtYXhWb2x0ID0gcGFyYW1zLm1heFZvbHQudmFsdWUsXHJcbiAgICAgIHN0ZXBWb2x0ID0gcGFyYW1zLnN0ZXBWb2x0LnZhbHVlLFxyXG4gICAgICBJcGggPSBwYXJhbXMuaXBoLnZhbHVlLFxyXG4gICAgICBUID0gcGFyYW1zLnQudmFsdWUsXHJcbiAgICAgIG4xID0gcGFyYW1zLm4xLnZhbHVlLFxyXG4gICAgICBJczEgPSBwYXJhbXMuaXMxLnZhbHVlO1xyXG5cclxuICAgIGxldCBuMiA9IHBhcmFtcy5uMi52YWx1ZSxcclxuICAgICAgSXMyID0gcGFyYW1zLmlzMi52YWx1ZSxcclxuICAgICAgUnAyID0gcGFyYW1zLnJwMi52YWx1ZTtcclxuXHJcbiAgICBpZiAobW9kZWwuZGlvZGVDb3VudCA9PT0gMSkge1xyXG4gICAgICBuMiA9IDE7XHJcbiAgICAgIElzMiA9IDA7XHJcbiAgICAgIFJwMjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgUnAgPSBwYXJhbXMucnAxLnZhbHVlLFxyXG4gICAgICBScyA9IHBhcmFtcy5ycy52YWx1ZTtcclxuXHJcbiAgICBsZXQgSXBhciwgSXNlciwgSSwgSWQxLCBJZDIsXHJcbiAgICAgIGFycmF5VkkgPSBbXSxcclxuICAgICAgYXJyYXlWSWQxID0gW10sXHJcbiAgICAgIGFycmF5VklkMiA9IFtdLFxyXG4gICAgICBhcnJheVZJcnAxID0gW10sXHJcbiAgICAgIGFycmF5VklycDIgPSBbXSxcclxuICAgICAgcGFyYWxsZWwsIG1vZGVsQ2FzZTtcclxuXHJcbiAgICBpZiAobW9kZWwuY2lyY3VpdCA9PT0gJ3BhcmFsbGVsJykge1xyXG4gICAgICBwYXJhbGxlbCA9IHRydWUsXHJcbiAgICAgICAgbW9kZWxDYXNlID0gJ3BhcmFsbGVsJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobW9kZWwuZGlvZGVDb3VudCA9PT0gMSkge1xyXG4gICAgICBwYXJhbGxlbCA9IHRydWUsXHJcbiAgICAgICAgbW9kZWxDYXNlID0gJ3NpbmdsZSc7XHJcbiAgICB9XHJcbiAgICBpZiAobW9kZWwuY2lyY3VpdCA9PT0gJ3NlcmllcycpIHtcclxuICAgICAgbW9kZWxDYXNlID0gJ3Nlcmllcyc7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgViA9IG1pblZvbHQ7IFYgPD0gbWF4Vm9sdDsgViArPSBzdGVwVm9sdCAvIDEwMDApIHtcclxuICAgICAgaWYgKHBhcmFsbGVsKSB7XHJcbiAgICAgICAgSXBhciA9IElwYXJhbGxlbChWLCBJcGgsIEksIFQsIG4xLCBuMiwgSXMxLCBJczIsIFJwLCBScyk7XHJcbiAgICAgICAgSSA9IC0gSXBhclswXTtcclxuICAgICAgICBJZDEgPSBJcGFyWzFdO1xyXG4gICAgICAgIElkMiA9IElwYXJbMl07XHJcbiAgICAgICAgdmFyIElycCA9IElwYXJbM107XHJcbiAgICAgICAgYXJyYXlWSXJwMS5wdXNoKFtWLCBJcnBdKTtcclxuICAgICAgICAvLyBDYWxjdWxhdGVkIGN1cnJlbnQgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCBjdXJyZW50IGZvciBuZXh0IHZvbHRhZ2UsXHJcbiAgICAgICAgLy8gc3BlZWRzIHVwIGVxdWF0aW9uIHNvbHZpbmcsIGlzIGltcG9ydGFudCBmb3IgaGlnaCBkaXJlY3QgYmlhc1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIElzZXIgPSBJc2VyaWVzKFYsIFQsIElwaCwgbjEsIG4yLCBJczEsIElzMiwgUnAsIFJwMiwgUnMpO1xyXG4gICAgICAgIEkgPSBJc2VyWzBdO1xyXG4gICAgICAgIElkMSA9IElzZXJbMV07XHJcbiAgICAgICAgSWQyID0gSXNlclsyXTtcclxuICAgICAgICB2YXIgSXJwMSA9IElzZXJbM10sXHJcbiAgICAgICAgICBJcnAyID0gSXNlcls0XTtcclxuICAgICAgICBhcnJheVZJcnAxLnB1c2goW1YsIElycDFdKTtcclxuICAgICAgICBhcnJheVZJcnAyLnB1c2goW1YsIElycDJdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXJyYXlWSS5wdXNoKFtWLCBJXSk7XHJcbiAgICAgIGFycmF5VklkMS5wdXNoKFtWLCBJZDFdKTtcclxuICAgICAgYXJyYXlWSWQyLnB1c2goW1YsIElkMl0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1vZGVsQ2FzZXMgPSB7XHJcbiAgICAgIHBhcmFsbGVsOiB7XHJcbiAgICAgICAgYXJyYXlDYWxjOiBbYXJyYXlWSSwgYXJyYXlWSWQxLCBhcnJheVZJZDIsIGFycmF5VklycDFdLFxyXG4gICAgICAgIHBsb3RTdHlsZTogW1xyXG4gICAgICAgICAgWydsaW5lJywgJ2JsYWNrJywgJ0knXSxcclxuICAgICAgICAgIFsnbGluZScsICdvcmFuZ2UnLCAnSWQxJ10sXHJcbiAgICAgICAgICBbJ2xpbmUnLCAnb3JhbmdlJywgJ0lkMiddLFxyXG4gICAgICAgICAgWydsaW5lJywgJ3B1cnBsZScsICdJcnAnXVxyXG4gICAgICAgIF1cclxuICAgICAgfSxcclxuICAgICAgc2luZ2xlOiB7XHJcbiAgICAgICAgYXJyYXlDYWxjOiBbYXJyYXlWSSwgYXJyYXlWSWQxLCBhcnJheVZJcnAxXSxcclxuICAgICAgICBwbG90U3R5bGU6IFtcclxuICAgICAgICAgIFsnbGluZScsICdibGFjaycsICdJJ10sXHJcbiAgICAgICAgICBbJ2xpbmUnLCAnb3JhbmdlJywgJ0lkMSddLFxyXG4gICAgICAgICAgWydsaW5lJywgJ3B1cnBsZScsICdJcnAnXVxyXG4gICAgICAgIF1cclxuICAgICAgfSxcclxuICAgICAgc2VyaWVzOiB7XHJcbiAgICAgICAgYXJyYXlDYWxjOiBbYXJyYXlWSSwgYXJyYXlWSWQxLCBhcnJheVZJZDIsIGFycmF5VklycDEsIGFycmF5VklycDFdLFxyXG4gICAgICAgIHBsb3RTdHlsZTogW1xyXG4gICAgICAgICAgWydsaW5lJywgJ2JsYWNrJywgJ0knXSxcclxuICAgICAgICAgIFsnbGluZScsICdvcmFuZ2UnLCAnSWQxJ10sXHJcbiAgICAgICAgICBbJ2xpbmUnLCAnb3JhbmdlJywgJ0lkMiddLFxyXG4gICAgICAgICAgWydsaW5lJywgJ3B1cnBsZScsICdJcnAxJ10sXHJcbiAgICAgICAgICBbJ2xpbmUnLCAncHVycGxlJywgJ0lycDInXVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbW9kZWxDYXNlc1ttb2RlbENhc2VdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NhbGVUeXBlKCkge1xyXG4gICAgLy8gUmV0dXJucyB0aGUgdHlwZSBvZiBzY2FsZSBmb3IgeSBheGlzXHJcbiAgICBjb25zdCBzY2FsZUlzTGluZWFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbmVhcicpLmNoZWNrZWQ7XHJcbiAgICByZXR1cm4gKHNjYWxlSXNMaW5lYXIpID8gJ2xpbmVhclNjYWxlJyA6ICdsb2dTY2FsZSc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoZmlsZSkge1xyXG4gICAgLy8gRmlyZWQgd2hlbiBmaWxlIGlucHV0IGNoYW5nZWRcclxuXHJcbiAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICByZWFkZXIub25sb2FkID0gcmVhZGVyT25Mb2FkO1xyXG4gICAgcmVhZGVyLmZpbGVuYW1lID0gZmlsZS5uYW1lO1xyXG5cclxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZGVyT25Mb2FkKGV2ZW50KSB7XHJcbiAgICAvLyBGaXJlZCB3aGVuIGRhdGEgaXMgcmVhZHlcclxuXHJcbiAgICAvLyBHdWVzcyBUIGZyb20gZmlsZSBuYW1lXHJcbiAgICBsZXQgZmlsZU5hbWUgPSB0aGlzLmZpbGVuYW1lO1xyXG5cclxuICAgIHdoaWxlIChpc05hTihwYXJzZUZsb2F0KGZpbGVOYW1lKSkgJiYgZmlsZU5hbWUubGVuZ3RoID4gMCkge1xyXG4gICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cmluZygxKTtcclxuICAgIH1cclxuXHJcbiAgICBmaWxlTmFtZSA9IHBhcnNlRmxvYXQoZmlsZU5hbWUpO1xyXG5cclxuICAgIGNvbnN0IGRlZmF1bHRUID0gKGlzTmFOKGZpbGVOYW1lKSkgPyAyOTggOiBmaWxlTmFtZSxcclxuICAgICAgVCA9IHByb21wdCgnVGVtcGVyYXR1cmU/IChLKScsIGRlZmF1bHRUKTtcclxuXHJcbiAgICBpZiAoaXNGaW5pdGUoVCkgJiYgVCA+IDApIHtcclxuICAgICAgc2V0UGFyYW1WYWx1ZSgndCcsIFQpO1xyXG4gICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2xpZGVyVCcpLnZhbHVlID0gVDtcclxuICAgICAgdXNlckRhdGEuZGF0YUFycmF5ID0gW107XHJcbiAgICAgIHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5ID0gW107XHJcblxyXG4gICAgICBzdHJpbmdUb0FycmF5KGV2ZW50LnRhcmdldC5yZXN1bHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xlYXJEYXRhKCkge1xyXG4gICAgLy8gRmlyZWQgd2hlbiB1c2VyIGNsaWNrcyBvbiB0aGUgQ2xlYXIgYnV0dG9uXHJcblxyXG4gICAgdXNlckRhdGEuZGF0YUFycmF5ID0gW107XHJcbiAgICB1c2VyRGF0YS5tb2RpZkRhdGFBcnJheSA9IFtdO1xyXG4gICAgZmlsZU9wZW5lZCA9IGZhbHNlO1xyXG4gICAgY29tYkRhdGFBbmRDYWxjKCk7XHJcblxyXG4gICAgJCgnLnBhbmVsJylcclxuICAgICAgLmFkZENsYXNzKCdub2ZpbGUnKTtcclxuXHJcbiAgICAkKCcuZmEtdG9nZ2xlLW9uJylcclxuICAgICAgLnRvZ2dsZUNsYXNzKCdmYS10b2dnbGUtb24gZmEtdG9nZ2xlLW9mZicpO1xyXG5cclxuICAgIGlmICh3aW5kb3cubG9jYWxGaWxlIC8qIEZGIGlzIHBpY2t5IGFib3V0IHRoYXQ6IG5vdCBpbXBvcnRpbmcgdGhlIGZpbGUgdGhyb3VnaCBjbGFzc2ljICdicm93c2UnIGJ1dHRvbiByZXN1bHQgaW4gYW4gZXJyb3IgaGVyZSAqLykge1xyXG4gICAgICB3aW5kb3cubG9jYWxGaWxlLnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJGaWxlSW5wdXQoKTtcclxuXHJcbiAgICAkKCcuZXN0aW1hdGlvbicpXHJcbiAgICAgIC5hZGQoJy5maW5hbCcpXHJcbiAgICAgIC5hZGQoJyNzJylcclxuICAgICAgLmFkZCgnI2RzJylcclxuICAgICAgLmVtcHR5KCk7XHJcblxyXG4gICAgaWYgKCQoJyNzdGFydCcpLmhhc0NsYXNzKCdwYXVzZScpKSB7XHJcbiAgICAgIHRvZ2dsZVBsYXlCdXR0b24oKTtcclxuICAgIH1cclxuXHJcbiAgICB1c2VyRGF0YS5lc3RpbWF0ZWRQYXJhbWV0ZXJzLlJwID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGRpc2FibGVDaGVja2JveGVzKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbGVhckZpbGVJbnB1dCgpIHtcclxuICAgICQoJ2lucHV0W3R5cGU9ZmlsZV0nKVxyXG4gICAgICAudmFsKG51bGwpXHJcbiAgICAgIC5jbG9zZXN0KCdkaXYnKVxyXG4gICAgICAuY2hpbGRyZW4oJ2lucHV0W3R5cGU9dGV4dF0nKVxyXG4gICAgICAudmFsKCcnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoZGF0YSkge1xyXG4gICAgLy8gQ29udmVydCB0aGUgZGF0YXNldCBmcm9tIGEgc3RyaW5nXHJcbiAgICAvLyB0byBhbiBhcnJheSBvZiBhcnJheXMgb2YgbnVtYmVyc1xyXG5cclxuICAgIGxldCBhcnJheSA9IGRhdGEuc3BsaXQoJ1xcbicpLFxyXG4gICAgICBza2lwUm93LFxyXG4gICAgICBkYXRhQXJyYXkgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBzdHJpbmdSb3cgb2YgYXJyYXkpIHtcclxuICAgICAgc2tpcFJvdyA9IGZhbHNlO1xyXG4gICAgICBjb25zdCByb3cgPSBzdHJpbmdSb3cuc3BsaXQoJ1xcdCcpO1xyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIGVhY2ggb2YgdGhlIGZpcnN0IHR3b1xyXG4gICAgICAvLyBlbGVtZW50cyBpbiB0aGUgcm93IGlzIGEgbnVtYmVyXHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XHJcbiAgICAgICAgcm93W2pdID0gTnVtYmVyKHJvd1tqXSk7XHJcbiAgICAgICAgc2tpcFJvdyArPSBpc05hTihyb3dbal0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXNraXBSb3cpIHtcclxuICAgICAgICBkYXRhQXJyYXkucHVzaChyb3cpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlcyB0aGUgc2VtaS10cmFuc3BhcmVudFxyXG4gICAgLy8gb3ZlcmxheSBkaXZcclxuICAgICQoJy5wYW5lbCcpXHJcbiAgICAgIC5yZW1vdmVDbGFzcygnbm9maWxlJyk7XHJcblxyXG4gICAgZmlsZU9wZW5lZCA9IHRydWU7XHJcblxyXG4gICAgLy8gRW5hYmxlIGNoZWNrYm94ZXMgZm9yIHRoZSBhbHJlYWR5XHJcbiAgICAvLyBlbmFibGVkIHBhcmFtZXRlciBpbnB1dHNcclxuICAgICQoJ1t0eXBlPXJhbmdlXTplbmFibGVkJylcclxuICAgICAgLmVhY2goZW5hYmxlQ2hlY2tib3hJbnB1dCk7XHJcblxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pblZvbHQnKS52YWx1ZSA9IGRhdGFBcnJheVswXVswXTtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXhWb2x0JykudmFsdWUgPSBkYXRhQXJyYXlbZGF0YUFycmF5Lmxlbmd0aCAtIDFdWzBdICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0ZXBWb2x0JykudmFsdWUgLyAxMDAwO1xyXG5cclxuICAgIGRhdGFBcnJheSA9IFtkYXRhQXJyYXldO1xyXG5cclxuICAgIHVzZXJEYXRhLmRhdGFBcnJheSA9IGRhdGFBcnJheTtcclxuICAgIHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5ID0gZGF0YUFycmF5O1xyXG5cclxuICAgIGNvbnN0IGl2UmVzdWx0ID0gY2FsY0lWKHBhcmFtZXRlcnMsIGdldE1vZGVsKCkpO1xyXG5cclxuICAgIC8qKioqIEVzdGltYXRlIHBhcmFtZXRlcnMgKioqKi9cclxuXHJcbiAgICAvLyBQYXJhbGxlbCByZXNpc3RhbmNlIFJwXHJcbiAgICBjb25zdCBScCA9IGVzdGltUnAoZGF0YUFycmF5KTtcclxuICAgIHVzZXJEYXRhLmVzdGltYXRlZFBhcmFtZXRlcnMuUnAgPSBScDtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgUGFyYWxsZWwgY3VycmVudCBhbmQgbm9uIGxpbmVhciByZXZlcnNlIGN1cnJlbnRcclxuICAgIGNvbnN0IGN1cnJlbnQgPSBjYWxjSXJwQW5kTm9uTGluUmV2Q3VycihkYXRhQXJyYXksIFJwKTtcclxuICAgIHVzZXJEYXRhLmN1cnJlbnQubm9uTGluZWFyID0gY3VycmVudC5ub25MaW5lYXI7XHJcbiAgICB1c2VyRGF0YS5jdXJyZW50LnNodW50ID0gY3VycmVudC5zaHVudDtcclxuXHJcbiAgICBmaW5kQW5kRXN0aW1hdGVEaW9kZXMoKTtcclxuXHJcbiAgICBjYWxjU3FSZXNTdW0ocGFyYW1ldGVycywgZGF0YUFycmF5LCBhcnJheUNhbGMpO1xyXG5cclxuICAgIGNvbWJEYXRhQW5kQ2FsYyhpdlJlc3VsdCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbmFibGVDaGVja2JveElucHV0KGluZGV4LCBlbGVtZW50KSB7XHJcbiAgICBnZXRSb3dEaXYoJChlbGVtZW50KSlcclxuICAgICAgLmZpbmQoJ1t0eXBlPWNoZWNrYm94XScpXHJcbiAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIElwclNob3dlZCgpIHtcclxuICAgIHJldHVybiAkKCcjaGlkZUlycCcpLmhhc0NsYXNzKCdmYS10b2dnbGUtb2ZmJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBub25MaW5lYXJDdXJyZW50U2hvd2VkKCkge1xyXG4gICAgcmV0dXJuICQoJyNoaWRlTm9uTGluQ3VycicpLmhhc0NsYXNzKCdmYS10b2dnbGUtb2ZmJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21iRGF0YUFuZENhbGMoKSB7XHJcbiAgICAvLyBDb21iaW5lIHVwbG9hZGVkIGRhdGEgYW5kIGNhbGN1bGF0ZWQgSVYgaW50byBvbmUgZ3JhcGhcclxuICAgIGNvbnN0IGNhbnZhc0lEID0gJ2dyYXBoJyxcclxuICAgICAgZGF0YSA9IHVzZXJEYXRhLm1vZGlmRGF0YUFycmF5LmNvbmNhdChhcnJheUNhbGMpLFxyXG4gICAgICBwcmltYXJ5UGxvdEluZGV4ID0gMCxcclxuICAgICAgeFRpdGxlID0gJ1YgKFYpJyxcclxuICAgICAgeVRpdGxlID0gJ0kgKEEpJztcclxuICAgIGxldCBzdHlsZTtcclxuXHJcbiAgICBpZiAoZmlsZU9wZW5lZCkge1xyXG4gICAgICBjb25zdCBkYXRhU3R5bGUgPSBbWyd2ZXJ0aWNhbENyb3NzJywgJ3B1cnBsZScsICdEYXRhJ11dO1xyXG4gICAgICBzdHlsZSA9IGRhdGFTdHlsZS5jb25jYXQocGxvdFN0eWxlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0eWxlID0gcGxvdFN0eWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdHcmFwaChjYW52YXNJRCwgZGF0YSwgcHJpbWFyeVBsb3RJbmRleCwgc3R5bGUsIHNjYWxlVHlwZSgpLCB4VGl0bGUsIHlUaXRsZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0YWJsZVN1Y2Nlc3NDb250ZXh0KGFkZCkge1xyXG4gICAgLy8gQWRkIG9yIHJlbW92ZSBcInN1Y2Nlc3NcIiBjb2xvciBvblxyXG4gICAgLy8gcGFyYW1ldGVyJ3MgdGFibGUncyAzcmQgY29sdW1uXHJcblxyXG4gICAgY29uc3QgJHRkID0gJCgndGQuZmluYWwnKTtcclxuXHJcbiAgICBpZiAoYWRkKSB7XHJcbiAgICAgICR0ZC5hZGRDbGFzcygnc3VjY2VzcycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJHRkLnJlbW92ZUNsYXNzKCdzdWNjZXNzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqICBGaXQgXHJcbiAgICovXHJcblxyXG5cclxuICBsZXQgaW50ZXJ2YWw7XHJcblxyXG4gIGZ1bmN0aW9uIGVzdGltUnAoZGF0YUFycmF5KSB7XHJcbiAgICAvLyBFc3RpbWF0ZSBwYXJhbGxlbCByZXNpc3RhbmNlIFJwXHJcbiAgICBsZXQgbWluID0gK0luZmluaXR5LFxyXG4gICAgICBhcnJheSA9IGRhdGFBcnJheVswXTtcclxuXHJcbiAgICBmb3IgKGxldCB4eSBvZiBhcnJheSkge1xyXG4gICAgICBsZXQgeCA9IHh5WzBdLFxyXG4gICAgICAgIHNsb3BlID0geHlbMV0gLyB4O1xyXG4gICAgICBpZiAoc2xvcGUgPCBtaW4gJiYgTWF0aC5hYnMoeCkgPiAwLjAwMSkge1xyXG4gICAgICAgIG1pbiA9IHNsb3BlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IFJwID0gMSAvIG1pbjtcclxuICAgIC8vIHZhciBvT00gPSBvcmRlck9mTWFnbihScCk7XHJcbiAgICAvL3ZhciByb3VuZGVkUnAgPSBNYXRoLnJvdW5kKFJwICogMTAwMCAvIG9PTSkgKiBvT00gLyAxMDAwO1xyXG5cclxuICAgIHJldHVybiBScDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbGNJcnBBbmROb25MaW5SZXZDdXJyKGRhdGFBcnJheSwgUnApIHtcclxuICAgIGxldCBhcnJheSA9IGRhdGFBcnJheVswXSxcclxuICAgICAgbm9uTGluRGlyQ3VyciA9IFtdLFxyXG4gICAgICBzaHVudEN1cnJlbnQgPSBbXSxcclxuICAgICAgbm9uTGluQ3VyciA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IFZJIG9mIGFycmF5KSB7XHJcbiAgICAgIGxldCBWID0gVklbMF0sXHJcbiAgICAgICAgSXJwID0gViAvIFJwO1xyXG4gICAgICBzaHVudEN1cnJlbnQucHVzaChbViwgSXJwXSk7XHJcblxyXG4gICAgICBpZiAoViA8IC0wLjAwMDEpIHtcclxuICAgICAgICAvLyBPbmx5IGxvb2tpbmcgYXQgcmV2ZXJzZSBwb2xhcml6YXRpb246XHJcbiAgICAgICAgLy8gTm9uLWxpbmVhciByZXZlcnNlIGN1cnJlbnQgaXMgdG90YWwgY3VycmVudCBtaW51cyBwYXJhbGxlbCBjdXJyZW50ICh3aGljaCBpcyBsaW5lYXIpXHJcbiAgICAgICAgbGV0IElubCA9IFZJWzFdIC0gSXJwOyAvLyBJbmwgLT4gJ25sJyA9ICdOb24tTGluZWFyJ1xyXG5cclxuICAgICAgICAvLyBEZWR1Y2UgZGlyZWN0IG5vbiBsaW5lYXIgY3VycmVudFxyXG4gICAgICAgIG5vbkxpbkRpckN1cnIudW5zaGlmdChbLVYsIC1JbmxdKTtcclxuXHJcbiAgICAgICAgLy8gUmV2ZXJzZVxyXG4gICAgICAgIG5vbkxpbkN1cnIucHVzaChbViwgSW5sXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21iaW5lIHJldmVyc2UgYW5kIGRpcmVjdFxyXG4gICAgbm9uTGluQ3VyciA9IG5vbkxpbkN1cnIuY29uY2F0KFtbMCwgMF1dLCBub25MaW5EaXJDdXJyKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzaHVudDogc2h1bnRDdXJyZW50LFxyXG4gICAgICBub25MaW5lYXI6IG5vbkxpbkN1cnJcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVJcnAobW9kaWZEYXRhQXJyYXksIHNodW50Q3VycmVudCwgc2hvdykge1xyXG4gICAgLy8gU2hvdyBvciBoaWRlIElycCBvbiBncmFwaFxyXG5cclxuICAgIGxldCBhcnJheSA9IG1vZGlmRGF0YUFycmF5WzBdLFxyXG4gICAgICBuZXdBcnJheSA9IFtdLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgc2lnbiA9IChzaG93KSA/IDEgOiAtMTtcclxuXHJcbiAgICBmb3IgKGxldCBJViBvZiBhcnJheSkge1xyXG4gICAgICBuZXdBcnJheS5wdXNoKFtJVlswXSwgSVZbMV0gKyBzaWduICogc2h1bnRDdXJyZW50W2ldWzFdXSk7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICBtb2RpZkRhdGFBcnJheSA9IFtuZXdBcnJheV07XHJcblxyXG4gICAgcmV0dXJuIG1vZGlmRGF0YUFycmF5O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlTm9uTGluQ3Vycih1c2VyRGF0YSwgbW9kaWZEYXRhQXJyYXksIHNob3cpIHtcclxuXHJcbiAgICBjb25zdCBub25MaW5lYXJDdXJyZW50ID0gdXNlckRhdGEuY3VycmVudC5ub25MaW5lYXI7XHJcblxyXG4gICAgbGV0IGFycmF5MSA9IHVzZXJEYXRhLmRhdGFBcnJheVswXSxcclxuICAgICAgYXJyYXkyID0gdXNlckRhdGEubW9kaWZEYXRhQXJyYXlbMF0sXHJcbiAgICAgIElWMixcclxuICAgICAgbmV3QXJyYXkxID0gW10sXHJcbiAgICAgIG5ld0FycmF5MiA9IFtdLFxyXG4gICAgICBzaWduID0gKHNob3cpID8gMSA6IC0xLFxyXG4gICAgICBpID0gMDtcclxuXHJcbiAgICBmb3IgKGxldCBJVjEgb2YgYXJyYXkxKSB7XHJcbiAgICAgIG5ld0FycmF5MS5wdXNoKFtJVjFbMF0sIElWMVsxXSArIHNpZ24gKiBub25MaW5lYXJDdXJyZW50W2ldWzFdXSk7XHJcbiAgICAgIElWMiA9IGFycmF5MltpXTtcclxuICAgICAgbmV3QXJyYXkyLnB1c2goW0lWMlswXSwgSVYyWzFdICsgc2lnbiAqIG5vbkxpbmVhckN1cnJlbnRbaV1bMV1dKTtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGFBcnJheTogW25ld0FycmF5MV0sXHJcbiAgICAgIG1vZGlmRGF0YUFycmF5OiBbbmV3QXJyYXkyXVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGxldCBTcVJlc1N1bSxcclxuICAgIGRlbFMgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gY2FsY1NxUmVzU3VtKHBhcmFtcywgZGF0YUFycmF5LCBhcnJheUNhbGMpIHtcclxuICAgIC8vIENhbGN1bGF0ZXMgdGhlIHN1bSBvZiBzcXVhcmVkIHJlc2lkdWFsc1xyXG5cclxuICAgIGxldCBuMSA9IHBhcmFtcy5uMS52YWx1ZSxcclxuICAgICAgSXMxID0gcGFyYW1zLmlzMS52YWx1ZSxcclxuICAgICAgUnAgPSBwYXJhbXMucnAxLnZhbHVlLFxyXG4gICAgICBScyA9IHBhcmFtcy5ycy52YWx1ZSxcclxuICAgICAgVCA9IHBhcmFtcy50LnZhbHVlLFxyXG4gICAgICBzaW5nbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2luZ2xlRGlvZGUnKS5jaGVja2VkLFxyXG4gICAgICBuMiwgSXMyO1xyXG5cclxuICAgIFNxUmVzU3VtID0gMDtcclxuXHJcbiAgICBpZiAoc2luZ2xlKSB7XHJcbiAgICAgIC8vIFNpbmdsZSBkaW9kZSBtb2RlbFxyXG4gICAgICBJczIgPSAwO1xyXG4gICAgICBuMiA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBEdWFsIGRpb2RlIG1vZGVsXHJcbiAgICAgIElzMiA9IHBhcmFtcy5pczIudmFsdWU7XHJcbiAgICAgIG4yID0gcGFyYW1zLm4yLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VyaWVzJykuY2hlY2tlZCkge1xyXG4gICAgICAvLyBEdWFsLCBzZXJpZXMgZGlvZGUgbW9kZWxcclxuICAgICAgbjEgPSBwYXJhbXMubjEudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHIsIGNhbGNJLCBqID0gMSwgeDEsIHgyLCB4eTEsIHh5MiwgeTEsIHkyLCBzbG9wZSwgeCxcclxuICAgICAgY2FsY0lWID0gYXJyYXlDYWxjWzBdLFxyXG4gICAgICBhcnJheSA9IGRhdGFBcnJheVswXSxcclxuICAgICAgZGF0YSxcclxuICAgICAgZFNkbjEgPSAwLFxyXG4gICAgICBkU2RuMiA9IDAsXHJcbiAgICAgIGRTZElzMSA9IDAsXHJcbiAgICAgIGRTZElzMiA9IDAsXHJcbiAgICAgIGRTZFJwID0gMCxcclxuICAgICAgZFNkUnMgPSAwO1xyXG5cclxuICAgIGxldCBkSWRuMSwgZElkbjIsIGRJZElzMSwgZElkSXMyLCBkSWRScCwgZElkUnMsIGV4cDEsIGV4cDI7XHJcblxyXG4gICAgZm9yIChsZXQgcm93IG9mIGFycmF5KSB7XHJcbiAgICAgIC8vIEZvciBlYWNoIGRhdGEgcG9pbnRcclxuICAgICAgeCA9IHJvd1swXTtcclxuXHJcbiAgICAgIHdoaWxlICh4ID4gY2FsY0lWW2pdWzBdKSB7IGorKzsgfVxyXG4gICAgICB4eTEgPSBjYWxjSVZbaiAtIDFdO1xyXG4gICAgICB4eTIgPSBjYWxjSVZbal07XHJcbiAgICAgIHgxID0geHkxWzBdO1xyXG4gICAgICB4MiA9IHh5MlswXTtcclxuICAgICAgeTEgPSB4eTFbMV07XHJcbiAgICAgIHkyID0geHkyWzFdO1xyXG4gICAgICBkYXRhID0gcm93WzFdO1xyXG5cclxuICAgICAgLy8gTGluZWFyIGludGVycG9sYXRpb25cclxuICAgICAgc2xvcGUgPSAoeTIgLSB5MSkgLyAoeDIgLSB4MSk7XHJcbiAgICAgIGNhbGNJID0geTEgKyBzbG9wZSAqICh4IC0geDEpO1xyXG5cclxuICAgICAgciA9IChjYWxjSSAtIGRhdGEpIC8gTWF0aC5hYnMoZGF0YSk7XHJcblxyXG4gICAgICBpZiAoaXNGaW5pdGUocikpIHtcclxuICAgICAgICBleHAxID0gTWF0aC5leHAocSAqICh4IC0gUnMgKiBjYWxjSSkgLyAobjEgKiBrICogVCkpO1xyXG4gICAgICAgIGV4cDIgPSBNYXRoLmV4cChxICogKHggLSBScyAqIGNhbGNJKSAvIChuMiAqIGsgKiBUKSk7XHJcblxyXG4gICAgICAgIGRJZG4xID0gcSAqIChScyAqIGNhbGNJIC0geCkgLyAoTWF0aC5wb3cobjEsIDIpICogayAqIFQgKiAoMSArIFJzIC8gUnAgKyBxICogSXMyICogUnMgKiBleHAyIC8gKG4yICogayAqIFQpKSAvIChJczEgKiBleHAxKSArIG4xICogUnMgKiBxKTtcclxuICAgICAgICBkU2RuMSArPSAyICogciAqIGRJZG4xIC8gTWF0aC5hYnMoZGF0YSk7XHJcblxyXG4gICAgICAgIGRJZG4yID0gcSAqIChScyAqIGNhbGNJIC0geCkgLyAoTWF0aC5wb3cobjIsIDIpICogayAqIFQgKiAoMSArIFJzIC8gUnAgKyBxICogSXMxICogUnMgKiBleHAxIC8gKG4xICogayAqIFQpKSAvIChJczIgKiBleHAyKSArIG4yICogUnMgKiBxKTtcclxuICAgICAgICBkU2RuMiArPSAyICogciAqIGRJZG4yIC8gTWF0aC5hYnMoZGF0YSk7XHJcblxyXG4gICAgICAgIGRJZElzMSA9IChleHAxIC0gMSkgLyAoMSArIHEgKiBJczEgKiBScyAqIGV4cDEgLyAobjEgKiBrICogVCkgKyBxICogSXMyICogUnMgKiBleHAyIC8gKG4yICogayAqIFQpICsgUnMgLyBScCk7XHJcbiAgICAgICAgLy9kSWRJczEgPSAoZXhwMSAtIDEpIC8gKDEgKyBxICogSXMxICogUnMgKiBleHAxIC8gKG4xICogayAqIFQpICsgUnMgLyBScCk7XHJcbiAgICAgICAgZFNkSXMxICs9IDIgKiByICogZElkSXMxIC8gTWF0aC5hYnMoZGF0YSk7XHJcblxyXG4gICAgICAgIGRJZElzMiA9IChleHAyIC0gMSkgLyAoMSArIHEgKiBJczEgKiBScyAqIGV4cDEgLyAobjEgKiBrICogVCkgKyBxICogSXMyICogUnMgKiBleHAyIC8gKG4yICogayAqIFQpICsgUnMgLyBScCk7XHJcbiAgICAgICAgZFNkSXMyICs9IDIgKiByICogZElkSXMyIC8gTWF0aC5hYnMoZGF0YSk7XHJcblxyXG4gICAgICAgIGRJZFJwID0gKGNhbGNJICogUnMgLSB4KSAvIChNYXRoLnBvdyhScCwgMikgKiAoMSArIHEgKiBJczEgKiBScyAqIGV4cDEgLyAobjEgKiBrICogVCkgKyBxICogSXMyICogUnMgKiBleHAyIC8gKG4yICogayAqIFQpICsgUnMgLyBScCkpO1xyXG4gICAgICAgIGRTZFJwICs9IDIgKiByICogZElkUnAgLyBNYXRoLmFicyhkYXRhKTtcclxuXHJcbiAgICAgICAgZElkUnMgPSAtIGNhbGNJICogKHEgKiBJczEgKiBleHAxIC8gKG4xICogayAqIFQpICsgcSAqIElzMiAqIGV4cDIgLyAobjIgKiBrICogVCkgKyAxIC8gUnApIC8gKDEgKyBScyAqIChxICogSXMxICogZXhwMSAvIChuMSAqIGsgKiBUKSArIHEgKiBJczIgKiBleHAyIC8gKG4yICogayAqIFQpICsgMSAvIFJwKSk7XHJcbiAgICAgICAgLy9kSWRScyA9IC0gY2FsY0kgKiAocSAqIElzMSAqIGV4cDEgLyAobjEgKiBrICogVCkgKyAxIC8gUnApIC8gKDEgKyBScyAqIChxICogSXMxICogZXhwMSAvIChuMSAqIGsgKiBUKSArIDEgLyBScCkpO1xyXG4gICAgICAgIGRTZFJzICs9IDIgKiByICogZElkUnMgLyBNYXRoLmFicyhkYXRhKTtcclxuXHJcbiAgICAgICAgU3FSZXNTdW0gKz0gTWF0aC5wb3cociwgMik7XHJcbiAgICAgIH1cclxuICAgICAgZGVsUyA9IFtkU2RuMSwgZFNkSXMxLCBkU2RScCwgZFNkUnNdO1xyXG4gICAgICBpZiAoIXNpbmdsZSkge1xyXG4gICAgICAgIGRlbFMuc3BsaWNlKDEsIDAsIGRTZG4yKTtcclxuICAgICAgICBkZWxTLnNwbGljZSgzLCAwLCBkU2RJczIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGxheSByZXNpZHVlXHJcbiAgICAkKCcjcycpLnRleHQoU3FSZXNTdW0udG9FeHBvbmVudGlhbCgyKSk7XHJcblxyXG4gICAgcmV0dXJuIFNxUmVzU3VtO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVyaXYoYXJyYXkpIHtcclxuICAgIHZhciBkZXIsIHByZXYsIG5leHQsIGRlckFycmF5ID0gW10sIHN0cmluZ0FycmF5ID0gJ1ZcXHRsbihJKVxcdGRbbG4oSSldL2RWJztcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoIC0gMTsgaSsrKSB7Ly9EZXJpdmF0aXZlIG5vdCBjYWxjdWxhdGVkIGZvciAxc3QgYW5kIGxhc3QgcG9pbnRcclxuICAgICAgcHJldiA9IGFycmF5W2kgLSAxXTtcclxuICAgICAgbmV4dCA9IGFycmF5W2kgKyAxXTtcclxuICAgICAgZGVyID0gKG5leHRbMV0gLSBwcmV2WzFdKSAvIChuZXh0WzBdIC0gcHJldlswXSk7XHJcbiAgICAgIGRlckFycmF5LnB1c2goW2FycmF5W2ldWzBdLCBkZXJdKTtcclxuICAgICAgc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheS5jb25jYXQoJ1xcbicgKyBhcnJheVtpXVswXSArICdcXHQnICsgYXJyYXlbaV1bMV0gKyAnXFx0JyArIGRlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVyQXJyYXk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsbk9mQXJyYXkoYXJyYXkpIHtcclxuICAgIHZhciB4eSwgeSwgbmV3QXJyYXkgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgeHkgPSBhcnJheVtpXTtcclxuICAgICAgeSA9IHh5WzFdO1xyXG4gICAgICBpZiAoeSAhPSAwKSB7XHJcbiAgICAgICAgbmV3QXJyYXkucHVzaChbeHlbMF0sIE1hdGgubG9nKE1hdGguYWJzKHkpKV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ld0FycmF5O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmluZERpb2Rlcyh1c2VyRGF0YSwgSXByU2hvd2VkLCBub25MaW5lYXJDdXJyZW50U2hvd2VkKSB7XHJcbiAgICBsZXQgbW9kaWZEYXRhQXJyYXkgPSB1c2VyRGF0YS5tb2RpZkRhdGFBcnJheSxcclxuICAgICAgc2h1bnRDdXJyZW50ID0gdXNlckRhdGEuY3VycmVudC5zaHVudDtcclxuXHJcbiAgICBpZiAoSXByU2hvd2VkKSB7XHJcbiAgICAgIG1vZGlmRGF0YUFycmF5ID0gdG9nZ2xlSXJwKG1vZGlmRGF0YUFycmF5LCBzaHVudEN1cnJlbnQsIGZhbHNlKTtcclxuICAgIH0gLy8gZGlvZGUgcGFyYW1ldGVycyBiZXR0ZXIgZXZhbHVhdGVkIHdoZW4gUnAgPSBpbmZpbml0eVxyXG5cclxuICAgIGlmIChub25MaW5lYXJDdXJyZW50U2hvd2VkKSB7XHJcbiAgICAgIGxldCByZXN1bHQgPSB0b2dnbGVOb25MaW5DdXJyKHVzZXJEYXRhLCBtb2RpZkRhdGFBcnJheSwgZmFsc2UpO1xyXG4gICAgICBtb2RpZkRhdGFBcnJheSA9IHJlc3VsdC5tb2RpZkRhdGFBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbm9JcnBOb1NDTENhcnJheSA9IG1vZGlmRGF0YUFycmF5WzBdLFxyXG4gICAgICBhcnJheSA9IG1vZGlmRGF0YUFycmF5WzBdO1xyXG5cclxuICAgIC8vIDFzdCBvcmRlciBkZXJpdmF0aXZlXHJcbiAgICBsZXQgYXJyYXkxID0gZGVyaXYobG5PZkFycmF5KGFycmF5KSk7XHJcblxyXG4gICAgLy8gMm5kIG9yZGVyIGRlcml2YXRpdmVcclxuICAgIGFycmF5ID0gZGVyaXYoYXJyYXkxKTtcclxuXHJcbiAgICBsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDIsXHJcbiAgICAgIHByZXYsXHJcbiAgICAgIGRMbiA9IGFycmF5W2ldWzFdLFxyXG4gICAgICBkTG5NaW4gPSAwLFxyXG4gICAgICBkZWx0YUxuTWF4ID0gMCxcclxuICAgICAgaiA9IDA7XHJcblxyXG4gICAgbGV0IGF2RGVsdGEgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgdmFyIHN1bSA9IDAsXHJcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtICs9IE1hdGguYWJzKGFycmF5W2ldWzFdIC0gYXJyYXlbaSAtIDFdWzFdKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3VtIC8gKGxlbmd0aCAtIDEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBhdkQgPSBhdkRlbHRhKGFycmF5KTtcclxuXHJcbiAgICB2YXIgaU1pbiA9IGksXHJcbiAgICAgIGZsdWN0SW4ybmRIYWxmID0gZmFsc2U7XHJcbiAgICBkbyB7XHJcbiAgICAgIGkgPSBpTWluO1xyXG4gICAgICBkTG4gPSBhcnJheVtpXVsxXTtcclxuICAgICAgdmFyIG1heFBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgLy8gTG9va2luZyBmb3IgbWluaW1hIGJldHdlZW4gMC4wNCBWIGFuZCBWbWF4XHJcbiAgICAgICAgaS0tO1xyXG4gICAgICAgIHByZXYgPSBkTG47XHJcbiAgICAgICAgZExuID0gYXJyYXlbaV1bMV07XHJcblxyXG4gICAgICAgIGZsdWN0SW4ybmRIYWxmICs9IE1hdGguYWJzKGRMbiAtIHByZXYpID4gYXZEICYmIGkgPCBhcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgIG1heFBhc3NlZCArPSBwcmV2ID4gZExuICYmIE1hdGguYWJzKGRMbiAtIHByZXYpIDwgYXZEO1xyXG4gICAgICAgIHZhciBjYXJyeU9uID0gIW1heFBhc3NlZCB8fCBkTG4gPCBwcmV2O1xyXG4gICAgICB9IHdoaWxlIChpID49IDAgJiYgYXJyYXlbaV1bMF0gPiAwLjA0ICYmIGNhcnJ5T24gJiYgIWZsdWN0SW4ybmRIYWxmKTtcclxuXHJcbiAgICAgIGlNaW4gPSBpICsgMTtcclxuICAgICAgZExuTWluID0gcHJldjtcclxuXHJcbiAgICAgIGxldCBkTG5NYXggPSBkTG5NaW47XHJcblxyXG4gICAgICBwcmV2ID0gLUluZmluaXR5O1xyXG4gICAgICBpID0gaU1pbiAtIDE7XHJcbiAgICAgIHZhciBpTWF4ID0gaU1pbjtcclxuXHJcbiAgICAgIHdoaWxlIChpID49IDAgJiYgYXJyYXlbaV1bMF0gPiAwLjA0KSB7XHJcbiAgICAgICAgLy8gTG9va2luZyBmb3IgYSBtYXhpbWEgYmV0d2VlbiAwLjA0IFYgYW5kIFZtYXhcclxuICAgICAgICBkTG4gPSBhcnJheVtpXVsxXTtcclxuXHJcbiAgICAgICAgaWYgKGRMbiA8IHByZXYgJiYgcHJldiA+IGRMbk1heCAmJiBNYXRoLmFicyhkTG4gLSBwcmV2KSA8IGF2RCkge1xyXG4gICAgICAgICAgaU1heCA9IGk7XHJcbiAgICAgICAgICBkTG5NYXggPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2ID0gZExuO1xyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRMbk1heCAtIGRMbk1pbiA+IGRlbHRhTG5NYXgpIHtcclxuICAgICAgICBkZWx0YUxuTWF4ID0gZExuTWF4IC0gZExuTWluO1xyXG4gICAgICAgIHZhciBpTWF4TWF4ID0gaU1heDtcclxuICAgICAgfVxyXG4gICAgICBqKys7XHJcbiAgICB9IHdoaWxlIChpTWF4ICE9IGlNaW4gJiYgaiA8IDEwICYmICFmbHVjdEluMm5kSGFsZik7XHJcblxyXG4gICAgaWYgKCFpTWF4TWF4KSB7XHJcbiAgICAgIHJldHVybiAnbm9EaW9kZSc7XHJcbiAgICB9XHJcblxyXG4gICAgaSA9IGlNYXggPSBpTWF4TWF4O1xyXG4gICAgZExuID0gYXJyYXlbaV1bMV07XHJcbiAgICBkbyB7XHJcbiAgICAgIHByZXYgPSBkTG47XHJcbiAgICAgIGktLTtcclxuICAgICAgZExuID0gYXJyYXlbaV1bMV07XHJcbiAgICB9IHdoaWxlIChNYXRoLmFicyhkTG4pIDwgTWF0aC5hYnMocHJldikgfHwgZExuID49IDApO1xyXG5cclxuICAgIGxldCBpRDEgPSBpICsgMixcclxuICAgICAgRDFkTG4gPSBhcnJheTFbaUQxICsgMV1bMV07XHJcblxyXG4gICAgaSA9IGlNYXg7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICBwcmV2ID0gZExuO1xyXG4gICAgICBpKys7XHJcbiAgICAgIGRMbiA9IGFycmF5W2ldWzFdO1xyXG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoZExuKSA8IE1hdGguYWJzKHByZXYpIHx8IGRMbiA+PSAwKTtcclxuXHJcbiAgICBsZXQgaUQyID0gaSAtIDEsXHJcbiAgICAgIEQyZExuID0gYXJyYXkxW2lEMiArIDFdWzFdO1xyXG5cclxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCAtIDI7XHJcblxyXG4gICAgaUQyID0gbGVuZ3RoIC0gaUQyO1xyXG4gICAgaUQxID0gbGVuZ3RoIC0gaUQxO1xyXG5cclxuICAgIC8qIGlEMiAoYW5kIGlEMSkgYXJlIHRoZSBpbmRleGVzIG9mIHRoZSBtYXhpbWEgKGFuZCBtaW5pbWEpLCBzdGFydGluZyBmcm9tIHRoZSAqZW5kKiBvZiB0aGUgb3JpZ2luYWwgYXJyYXksXHJcbiAgICBpbiBjYXNlIHBvaW50cyBpbiByZXZlcnNlIGFyZSBtaXNzaW5nIGFmdGVyIHJlbW92YWwgb2YgSXJwIGFuZCBTQ0xDICovXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbm9JcnBOb1NDTENhcnJheTogbm9JcnBOb1NDTENhcnJheSxcclxuICAgICAgZGlvZGVzOiBbRDJkTG4sIEQxZExuLCBpRDIsIGlEMV1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlc3RpbUQxRDJScyhwYXJhbXMsIHVzZXJEYXRhLCBmaW5kRGlvZGVzUmVzdWx0KSB7XHJcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlcmllcycpLmNoZWNrZWQpIHtcclxuICAgICAgLy8gRm9yIG5vdywgbm8gZXN0aW1hdGlvbiBmb3Igc2VyaWVzIG1vZGVsXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYXJhbVZhbHVlcyA9IHBhcmFtcy52YWx1ZSxcclxuICAgICAgcGFyYW1DaGVja2VkID0gcGFyYW1zLmNoZWNrZWQ7XHJcblxyXG4gICAgbGV0IG1heG1pbiA9IGZpbmREaW9kZXNSZXN1bHQuZGlvZGVzO1xyXG5cclxuICAgIGlmIChtYXhtaW4gPT09ICdub0Rpb2RlJykge1xyXG4gICAgICAvLyBUT0RPOiBEaXNwbGF5IG1lc3NhZ2VcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkdWFsRGlvZGUgPSAhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpbmdsZURpb2RlJykuY2hlY2tlZCxcclxuICAgICAgYXJyYXkgPSBmaW5kRGlvZGVzUmVzdWx0Lm5vSXJwTm9TQ0xDYXJyYXksXHJcblxyXG4gICAgICBEMWRMbiA9IG1heG1pblsxXSxcclxuICAgICAgRDJkTG4gPSBtYXhtaW5bMF0sXHJcbiAgICAgIFZJQXRkMSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDQgLSBtYXhtaW5bM11dLFxyXG4gICAgICBWSUF0ZDIgPSBhcnJheVthcnJheS5sZW5ndGggLSA0IC0gbWF4bWluWzJdXSxcclxuICAgICAgVCA9IHBhcmFtVmFsdWVzLnQsXHJcbiAgICAgIEEgPSBxIC8gKGsgKiBUKSxcclxuICAgICAgbjIgPSBBIC8gRDJkTG4sXHJcbiAgICAgIG4sIG4xLCBJczEsIFJzLCBJczI7XHJcblxyXG4gICAgaWYgKGR1YWxEaW9kZSkge1xyXG4gICAgICBpZiAocGFyYW1DaGVja2VkLm4yKSB7XHJcbiAgICAgICAgbiA9IG4yO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSBuMiA9IHBhcmFtVmFsdWVzLm4yO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJhbUNoZWNrZWQubjEpIHtcclxuICAgICAgICBuMSA9IEEgLyBEMWRMbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuMSA9IHBhcmFtVmFsdWVzLm4xO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJhbUNoZWNrZWQuaXMxKSB7XHJcbiAgICAgICAgSXMxID0gVklBdGQxWzFdIC8gKE1hdGguZXhwKChWSUF0ZDFbMF0gKiBBIC8gbjEpIC0gMSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIElzMSA9IHBhcmFtVmFsdWVzLmlzMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gU2luZ2xlIGRpb2RlXHJcbiAgICAgIG4gPSBuMjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyYW1DaGVja2VkLnJzKSB7XHJcbiAgICAgIFJzID0gZXN0aW1ScyhhcnJheSwgVCwgbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBScyA9IHBhcmFtVmFsdWVzLnJzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJhbUNoZWNrZWQuaXMyKSB7XHJcbiAgICAgIElzMiA9IFZJQXRkMlsxXSAvIChNYXRoLmV4cCgoVklBdGQyWzBdIC0gVklBdGQyWzFdICogUnMpICogQSAvIG4yKSAtIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgSXMyID0gcGFyYW1WYWx1ZXMuaXMyO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBuZXdScDtcclxuXHJcbiAgICBpZiAocGFyYW1DaGVja2VkLnJwMSkge1xyXG4gICAgICBuZXdScCA9IHVzZXJEYXRhLmVzdGltYXRlZFBhcmFtZXRlcnMuUnA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXdScCA9IHBhcmFtVmFsdWVzLnJwMTtcclxuICAgIH1cclxuXHJcbiAgICAkKCd0ZC5lc3RpbWF0aW9uI3JwMScpLnRleHQobmV3UnAudG9QcmVjaXNpb24oMykpO1xyXG4gICAgJCgndGQuZXN0aW1hdGlvbiNycycpLnRleHQoUnMudG9QcmVjaXNpb24oMikpO1xyXG5cclxuICAgIGlmIChkdWFsRGlvZGUpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBuMTogbjEsXHJcbiAgICAgICAgbjI6IG4yLFxyXG4gICAgICAgIElzMTogSXMxLFxyXG4gICAgICAgIElzMjogSXMyLFxyXG4gICAgICAgIFJwMTogbmV3UnAsXHJcbiAgICAgICAgUnM6IFJzXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG4xOiBuMixcclxuICAgICAgICBJczE6IElzMixcclxuICAgICAgICBScDE6IG5ld1JwLFxyXG4gICAgICAgIFJzOiBSc1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXN0aW1ScyhhcnJheSwgVCwgbikge1xyXG4gICAgdmFyIGRJZFYgPSBkZXJpdihhcnJheSksXHJcbiAgICAgIGkgPSBhcnJheS5sZW5ndGggLSAyLFxyXG4gICAgICBkSWRWYXRpID0gZElkVltpIC0gMV1bMV0sXHJcbiAgICAgIGV4cCxcclxuICAgICAgQSA9IHEgLyAobiAqIGsgKiBUKSxcclxuICAgICAgQiwgQyxcclxuICAgICAgSVZhdGkgPSBhcnJheVtpXSxcclxuICAgICAgSSA9IElWYXRpWzFdLFxyXG4gICAgICBWID0gSVZhdGlbMF0sXHJcbiAgICAgIFJzID0gMDtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIGV4cCA9IE1hdGguZXhwKEEgKiAoViAtIEkgKiBScykpO1xyXG4gICAgICBCID0gQSAqIGV4cCAvIChleHAgLSAxKTtcclxuICAgICAgQyA9IEIgLyAoMSAvIEkgKyBScyAqIEIpO1xyXG4gICAgICBScyArPSAwLjAxO1xyXG4gICAgfSB3aGlsZSAoQyA+IGRJZFZhdGkpO1xyXG5cclxuICAgIHJldHVybiBScztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVBhcmFtcyhwYXJhbXMsIHBsb3QsIHVwZGF0ZVJhbmdlSW5wdXQpIHtcclxuICAgIC8vIFVwZGF0ZSBudW1iZXIgaW5wdXQgYW5kIHJlc3VsdCB0YWJsZVxyXG5cclxuICAgIGlmICh1cGRhdGVSYW5nZUlucHV0KSB7XHJcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgICBldnQuaW5pdEV2ZW50KCdjaGFuZ2UnLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IHBhcmFtIG9mIHBhcmFtcykge1xyXG4gICAgICBjb25zdCBpZCA9IHBhcmFtWzBdLFxyXG4gICAgICAgIHZhbHVlID0gcGFyYW1bMV07XHJcblxyXG4gICAgICBsZXQgZWxlbWVudCA9ICQoJ1t0eXBlPW51bWJlcl0uJyArIGlkKS5nZXQoMCk7XHJcblxyXG4gICAgICBpZiAodXBkYXRlUmFuZ2VJbnB1dCkge1xyXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCAkdGQgPSAkKCd0ZCNmaW5hbC0nICsgaWQpLFxyXG4gICAgICAgIGlzU2NhbGVMb2cgPSAkKGVsZW1lbnQpLmhhc0NsYXNzKCdsb2dzY2FsZScpLFxyXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlID0gKGlzU2NhbGVMb2cpID8gdmFsdWUudG9FeHBvbmVudGlhbCgyKSA6IHZhbHVlLnRvUHJlY2lzaW9uKDIpO1xyXG5cclxuICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAkdGRcclxuICAgICAgICAudGV4dChmb3JtYXR0ZWRWYWx1ZSk7XHJcblxyXG4gICAgICBwYXJhbWV0ZXJzLnVwZGF0ZSgkKGVsZW1lbnQpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpdlJlc3VsdCA9IGNhbGNJVihwYXJhbWV0ZXJzLCBnZXRNb2RlbCgpKTtcclxuXHJcbiAgICBhcnJheUNhbGMgPSBpdlJlc3VsdC5hcnJheUNhbGM7XHJcbiAgICBwbG90U3R5bGUgPSBpdlJlc3VsdC5wbG90U3R5bGU7XHJcblxyXG4gICAgY2FsY1NxUmVzU3VtKHBhcmFtZXRlcnMsIHVzZXJEYXRhLmRhdGFBcnJheSwgYXJyYXlDYWxjKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHZhcnkoKSB7XHJcbiAgICAvLyBWYXJpZXMgY2hlY2tlZCBkaW9kZSBwYXJhbWV0ZXJzIHVudGlsXHJcbiAgICAvLyBzdW0gb2Ygc3F1YXJlIHJlc2lkdWFscyBpcyBtaW5pbWl6ZWRcclxuXHJcbiAgICBjb25zdCBlcHMgPSBtY2hFcHM7XHJcblxyXG4gICAgdmFyIG4xID0gcGFyYW1ldGVycy5uMS52YWx1ZSxcclxuICAgICAgbjF2YXJ5ID0gcGFyYW1ldGVycy5uMS5jaGVja2VkLFxyXG4gICAgICBJczEgPSBwYXJhbWV0ZXJzLmlzMS52YWx1ZSxcclxuICAgICAgSXMxdmFyeSA9IHBhcmFtZXRlcnMuaXMxLmNoZWNrZWQsXHJcbiAgICAgIFJwID0gcGFyYW1ldGVycy5ycDEudmFsdWUsXHJcbiAgICAgIFJwdmFyeSA9IHBhcmFtZXRlcnMucnAxLmNoZWNrZWQsXHJcbiAgICAgIFJzID0gcGFyYW1ldGVycy5ycy52YWx1ZSxcclxuICAgICAgUnN2YXJ5ID0gcGFyYW1ldGVycy5ycy5jaGVja2VkO1xyXG5cclxuICAgIC8vIFNpbmdsZSBkaW9kZSBtb2RlbFxyXG4gICAgbGV0IHBhcmFtcyA9IFtcclxuICAgICAgWyduMScsIG4xLCBlcHMsIG4xdmFyeV0sXHJcbiAgICAgIFsnaXMxJywgSXMxLCBlcHMsIElzMXZhcnldLFxyXG4gICAgICBbJ3JwMScsIFJwLCBlcHMsIFJwdmFyeV0sXHJcbiAgICAgIFsncnMnLCBScywgZXBzLCBSc3ZhcnldXHJcbiAgICBdO1xyXG5cclxuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG91YmxlRGlvZGUnKS5jaGVja2VkKSB7XHJcbiAgICAgIC8vIER1YWwgZGlvZGUgbW9kZWxcclxuICAgICAgdmFyIElzMiA9IHBhcmFtZXRlcnMuaXMyLnZhbHVlLFxyXG4gICAgICAgIElzMnZhcnkgPSBwYXJhbWV0ZXJzLmlzMi5jaGVja2VkLFxyXG4gICAgICAgIG4yID0gcGFyYW1ldGVycy5uMi52YWx1ZSxcclxuICAgICAgICBuMnZhcnkgPSBwYXJhbWV0ZXJzLm4yLmNoZWNrZWQ7XHJcbiAgICAgIHBhcmFtcyA9IFtbJ24xJywgbjEsIGVwcywgbjF2YXJ5XSwgWyduMicsIG4yLCBlcHMsIG4ydmFyeV0sIFsnaXMxJywgSXMxLCBlcHMsIElzMXZhcnldLCBbJ2lzMicsIElzMiwgZXBzLCBJczJ2YXJ5XSwgWydycDEnLCBScCwgZXBzLCBScHZhcnldLCBbJ3JzJywgUnMsIGVwcywgUnN2YXJ5XV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlbCxcclxuICAgICAgUyxcclxuICAgICAgbmV3UGFyLFxyXG4gICAgICBqID0gMCxcclxuICAgICAgaWkgPSAwLFxyXG4gICAgICBzaWduLFxyXG4gICAgICBzdG9wID0gZmFsc2U7XHJcblxyXG4gICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcclxuICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFMgPSBTcVJlc1N1bTtcclxuICAgICAgICB2YXIgbmV3UGFycyA9IFtdO1xyXG4gICAgICAgIC8vZGVsID0gZGVsUztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHBhcmFtc1tpXVszXSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHBhcmFtZXRlciBpcyBhbGxvd2VkIHRvIHZhcnlcclxuICAgICAgICAgICAgZGVsID0gZGVsU1tpXTtcclxuICAgICAgICAgICAgc2lnbiA9IGRlbCAvIE1hdGguYWJzKGRlbCk7XHJcblxyXG4gICAgICAgICAgICBuZXdQYXIgPSBwYXJhbXNbaV1bMV0gKiBNYXRoLnBvdygoMSArIHBhcmFtc1tpXVsyXSksIC1zaWduKTsgLy91cGRhdGUgcGFyYW1ldGVyXHJcblxyXG4gICAgICAgICAgICB1cGRhdGVQYXJhbXMoW1twYXJhbXNbaV1bMF0sIG5ld1Bhcl1dLCBmYWxzZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChkZWwgLyBNYXRoLmFicyhkZWwpICE9IGRlbFNbaV0gLyBNYXRoLmFicyhkZWxTW2ldKSAmJiBqIDwgMTAwICYmIG5ld1BhciAhPT0gMCkge1xyXG4gICAgICAgICAgICAgIHBhcmFtc1tpXVsyXSAvPSAyO1xyXG4gICAgICAgICAgICAgIG5ld1BhciA9IHBhcmFtc1tpXVsxXSAqIE1hdGgucG93KCgxICsgcGFyYW1zW2ldWzJdKSwgLXNpZ24pOyAvL3VwZGF0ZSBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICB1cGRhdGVQYXJhbXMoW1twYXJhbXNbaV1bMF0sIG5ld1Bhcl1dLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGpqID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGRlbCAvIE1hdGguYWJzKGRlbCkgPT0gZGVsU1tpXSAvIE1hdGguYWJzKGRlbFNbaV0pICYmIGpqIDwgMTAwICYmIG5ld1BhciAhPT0gMCkge1xyXG4gICAgICAgICAgICAgIHBhcmFtc1tpXVsyXSAqPSAyO1xyXG4gICAgICAgICAgICAgIG5ld1BhciA9IHBhcmFtc1tpXVsxXSAqIE1hdGgucG93KCgxICsgcGFyYW1zW2ldWzJdKSwgLXNpZ24pOyAvL3VwZGF0ZSBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICB1cGRhdGVQYXJhbXMoW1twYXJhbXNbaV1bMF0sIG5ld1Bhcl1dLCBmYWxzZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICBqaisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtc1tpXVsxXSA9IG5ld1BhcjtcclxuICAgICAgICAgICAgbmV3UGFycy5wdXNoKG5ld1Bhcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNOYU4obmV3UGFyKSkge1xyXG4gICAgICAgICAgICAgIHN0b3AgKz0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWkrKztcclxuXHJcbiAgICAgICAgY29uc3QgZFMgPSBTcVJlc1N1bSAtIFM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgUyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICQoJyNkcycpLnRleHQoZFMudG9FeHBvbmVudGlhbCgyKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICQoJyNkcycpLmVtcHR5KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGhyZXNob2xkJykudmFsdWUsXHJcbiAgICAgICAgICBmaXRTdWNjZXNzZnVsID0gTWF0aC5hYnMoZFMpIDwgdGhyZXNob2xkO1xyXG5cclxuICAgICAgICBpZiAoZml0U3VjY2Vzc2Z1bCB8fCBpaSA+IDEwMDAgfHwgc3RvcCkge1xyXG4gICAgICAgICAgaWYgKGZpdFN1Y2Nlc3NmdWwpIHtcclxuICAgICAgICAgICAgY29uc3QgYWRkQ29udGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRhYmxlU3VjY2Vzc0NvbnRleHQoYWRkQ29udGV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0b2dnbGVQbGF5QnV0dG9uKCk7XHJcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGZhbHNlO1xyXG4gICAgICAgICAgc3RhcnRQYXVzZVZhcnkoc3RhcnQpO1xyXG5cclxuICAgICAgICAgIC8vIFN5bmMgbnVtYmVyIGFuZCByYW5nZSBpbnB1dHNcclxuICAgICAgICAgIHN5bmNBbGxJbnB1dHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LndlYmtpdEhpZGRlbikge1xyXG4gICAgICAgICAgLy8gTm8gdXNlIHRvIHBsb3Q6IHRoZSBwYWdlIGlzIG5vdCB2aXNpYmxlIChXZWJraXQgb25seSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29tYkRhdGFBbmRDYWxjKC8qYXJyYXlDYWxjLCBwbG90U3R5bGUsIHNjYWxlKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAsIDEpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RhcnRQYXVzZVZhcnkoc3RhcnQpIHtcclxuICAgIC8vIHN0YXJ0IHBhcmFtZXRlciBpcyBhIGJvb2xlYW5cclxuXHJcbiAgICBpZiAoc3RhcnQgPT09IHRydWUpIHtcclxuICAgICAgY29uc3QgYWRkQ29udGV4dCA9IGZhbHNlO1xyXG4gICAgICB0YWJsZVN1Y2Nlc3NDb250ZXh0KGFkZENvbnRleHQpO1xyXG4gICAgICB2YXJ5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7fTtcclxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);